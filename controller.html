<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="version" content="3.12.1-c0db40a">
    <title>Kinemon - Controller v3.12.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            touch-action: none;
        }

        #container {
            width: 100%;
            max-width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        .screen {
            display: none;
            max-width: 500px;
            width: 100%;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }

        p {
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.8;
            line-height: 1.6;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
            display: inline-block;
            min-width: 200px;
        }

        .btn:active {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
        }

        .btn-secondary:active {
            background: #0b7dda;
        }

        .btn-danger {
            background: #F44336;
        }

        .btn-danger:active {
            background: #da190b;
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 18px;
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid #F44336;
        }

        #controlSchemeSelect {
            cursor: pointer;
        }

        #controlSchemeSelect:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 2px;
        }

        #controlSelector {
            user-select: none;
            -webkit-user-select: none;
        }

        .calibration-indicator {
            font-size: 64px;
            margin: 20px 0;
        }

        .instruction {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .tilt-display {
            font-size: 48px;
            font-weight: bold;
            color: #4CAF50;
            margin: 20px 0;
        }

        #deathScreen {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1a1a 100%);
        }

        #deathScore {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 8px;
        }

        .info {
            font-size: 14px;
            opacity: 0.6;
            margin-top: 20px;
        }

        #qrReader {
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
        }

        #qrReader video {
            width: 100%;
            border-radius: 10px;
        }

        .room-display {
            font-size: 36px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 4px;
            margin: 20px 0;
        }

        /* Role selection panel */
        .role-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .role-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 15px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .role-btn:active:not(:disabled) {
            background: #0b7dda;
            transform: scale(0.98);
        }

        .role-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .role-btn.selected {
            background: #4CAF50;
        }

        #releaseRoleBtn {
            background: #f44336;
            width: 100%;
        }

        #releaseRoleBtn:active {
            background: #da190b;
        }

        #readyBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #readyHint {
            font-size: 14px;
            color: #999;
            margin-top: 5px;
        }

        .role-panel-title {
            font-size: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Room Input Screen -->
        <div id="roomInputScreen" class="screen active">
            <h1 id="gameTitle">GAME</h1>
            <h2 id="roomNameDisplay" style="font-size: 28px; color: #4CAF50; margin-bottom: 30px;">ROOMNAME ROOM</h2>

            <label for="playerName" style="display: block; font-size: 16px; margin-bottom: 8px; opacity: 0.8;">–í–∞—à–µ –∏–º—è:</label>
            <input type="text" id="playerName" placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è" maxlength="20">
            <br>
            <div id="teamSelector" style="display: none; margin: 10px 0;">
                <select id="teamSelect" style="width: 100%; padding: 15px; font-size: 16px; border-radius: 10px; background: #222; color: white; border: 2px solid #444;">
                    <option value="Blue">üîµ –°–∏–Ω—è—è –∫–æ–º–∞–Ω–¥–∞</option>
                    <option value="Red">üî¥ –ö—Ä–∞—Å–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞</option>
                    <option value="Yellow">üü° –ñ—ë–ª—Ç–∞—è –∫–æ–º–∞–Ω–¥–∞</option>
                    <option value="Green">üü¢ –ó–µ–ª—ë–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞</option>
                    <option value="White">‚ö™ –ë–µ–ª–∞—è –∫–æ–º–∞–Ω–¥–∞</option>
                </select>
            </div>

            <!-- Role Selection Panel (Ship only) -->
            <div id="roleSelectionPanel" style="display: none;">
                <div class="role-panel-title">–í—ã–±–æ—Ä —Ä–æ–ª–∏:</div>
                <div class="role-buttons">
                    <button class="role-btn" data-role="engine">‚öôÔ∏è –î–≤–∏–≥–∞—Ç–µ–ª—å</button>
                    <button class="role-btn" data-role="rudder">üß≠ –†—É–ª—å</button>
                    <button class="role-btn" data-role="weapon">üî´ –û—Ä—É–∂–∏–µ</button>
                    <button class="role-btn" data-role="weaponDirection">üéØ –ü—Ä–∏—Ü–µ–ª</button>
                    <button class="role-btn" data-role="shield">üõ°Ô∏è –©–∏—Ç</button>
                </div>

                <!-- Ready button (disabled until role is selected) -->
                <button id="readyBtn" class="btn" style="margin-top: 15px; width: 100%;" disabled>–ì–æ—Ç–æ–≤</button>
                <div id="readyHint">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å</div>
            </div>

            <button class="btn btn-secondary" id="manualJoinBtn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>

            <!-- Debug Display (for mobile testing) -->
            <div id="debugDisplay" style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; font-size: 12px; text-align: left; max-height: 200px; overflow-y: auto; display: none;">
                <div style="font-weight: bold; margin-bottom: 10px; color: #4CAF50;">üîç Debug Info:</div>
                <div id="debugLog"></div>
            </div>
        </div>

        <!-- QR Scanner Screen removed - now using native camera app -->

        <!-- Calibration Min Screen -->
        <div id="calibrationMinScreen" class="screen">
            <h2>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay1"></span></div>
            <div class="calibration-indicator">‚¨áÔ∏è</div>
            <div class="instruction">
                <p><strong>–®–∞–≥ 1 –∏–∑ 2</strong></p>
                <p>–ù–∞–∫–ª–æ–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ<br>–¥–ª—è –ù–ò–ñ–ù–ï–ô –ø–æ–∑–∏—Ü–∏–∏</p>
            </div>
            <button id="setMinBtn" class="btn">–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <!-- Calibration Max Screen -->
        <div id="calibrationMaxScreen" class="screen">
            <h2>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay2"></span></div>
            <div class="calibration-indicator">‚¨ÜÔ∏è</div>
            <div class="instruction">
                <p><strong>–®–∞–≥ 2 –∏–∑ 2</strong></p>
                <p>–ù–∞–∫–ª–æ–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ<br>–¥–ª—è –í–ï–†–•–ù–ï–ô –ø–æ–∑–∏—Ü–∏–∏</p>
            </div>
            <button id="setMaxBtn" class="btn">–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <!-- Controller Screen -->
        <div id="controllerScreen" class="screen">
            <h2>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay3"></span></div>
            <div class="tilt-display" id="tiltDisplay">0.50</div>
            <p>–ù–∞–∫–ª–æ–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</p>
            <div class="info">
                <p id="playerInfo">–ò–≥—Ä–æ–∫: <span id="playerNameDisplay"></span></p>
                <p id="axisInfo" style="display: none; margin-top: 10px; font-size: 18px; font-weight: bold;">–í–∞—à–∞ –æ—Å—å: <span id="axisDisplay"></span></p>
            </div>

            <!-- Role Selection Panel (Ship only, during game) -->
            <div id="roleSelectionPanelGame" style="display: none;">
                <div class="role-panel-title">–°–º–µ–Ω–∞ —Ä–æ–ª–∏:</div>
                <div class="role-buttons">
                    <button class="role-btn" data-role="engine">‚öôÔ∏è –î–≤–∏–≥–∞—Ç–µ–ª—å</button>
                    <button class="role-btn" data-role="rudder">üß≠ –†—É–ª—å</button>
                    <button class="role-btn" data-role="weapon">üî´ –û—Ä—É–∂–∏–µ</button>
                    <button class="role-btn" data-role="weaponDirection">üéØ –ü—Ä–∏—Ü–µ–ª</button>
                    <button class="role-btn" data-role="shield">üõ°Ô∏è –©–∏—Ç</button>
                </div>
            </div>

            <button class="btn btn-danger" id="disconnectBtn">–û—Ç–∫–ª—é—á–∏—Ç—å—Å—è</button>
        </div>

        <!-- Death Screen -->
        <div id="deathScreen" class="screen">
            <h1 style="font-size: 36px; margin-bottom: 30px;">üíÄ –ü–æ—Ä–∞–∂–µ–Ω–∏–µ</h1>
            <p id="deathMessage" style="font-size: 20px; line-height: 1.6; margin-bottom: 40px;">
                –£ —Ç–µ–±—è –±—ã–ª–æ <span id="deathScore" style="color: #FFD700; font-size: 28px; font-weight: bold;">0</span> –ø–∏—Ü—Ü –Ω–∞ –º–æ–º–µ–Ω—Ç —Å–º–µ—Ä—Ç–∏
            </p>
            <p style="font-size: 18px; opacity: 0.8; margin-bottom: 40px;">
                –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –≤ –±–æ–π, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –∏—Ö –æ–±—Ä–∞—Ç–Ω–æ!
            </p>
            <button class="btn" id="respawnBtn" style="font-size: 24px; padding: 20px 40px;">
                üîÑ –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –±–æ–π!
            </button>
        </div>

    </div>

    <script src="motionController.js"></script>
    <script src="calibration.js"></script>
    <script>
        // Generate random player name on page load
        function generateRandomPlayerName() {
            const adjectives = ['Brave', 'Lazy', 'Happy', 'Angry', 'Clever', 'Tiny', 'Huge', 'Swift', 'Bold', 'Shy',
                                'Wild', 'Calm', 'Loud', 'Quiet', 'Crazy', 'Smart', 'Lucky', 'Grumpy'];
            const nouns = ['Fox', 'Bear', 'Wolf', 'Eagle', 'Tiger', 'Shark', 'Panda', 'Lion', 'Owl', 'Raven',
                           'Falcon', 'Jaguar', 'Lynx', 'Otter', 'Hawk', 'Moose', 'Bison', 'Crane'];

            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];

            return `${adj} ${noun}`;
        }

        let ws = null;
        let motionController = null;
        let calibration = null;
        let playerId = null;
        let roomId = null;
        let gameType = 'snake'; // Default game type
        let wakeLock = null;
        let pingInterval = null;

        // Load saved control preference from localStorage
        let currentControlScheme = localStorage.getItem('playerControlScheme') || 'rotation_smooth';

        const roomInputScreen = document.getElementById('roomInputScreen');
        const calibrationMinScreen = document.getElementById('calibrationMinScreen');
        const calibrationMaxScreen = document.getElementById('calibrationMaxScreen');
        const controllerScreen = document.getElementById('controllerScreen');
        const deathScreen = document.getElementById('deathScreen');

        const playerNameInput = document.getElementById('playerName');
        const manualJoinBtn = document.getElementById('manualJoinBtn');
        const gameTitle = document.getElementById('gameTitle');
        const roomNameDisplay = document.getElementById('roomNameDisplay');
        const setMinBtn = document.getElementById('setMinBtn');
        const setMaxBtn = document.getElementById('setMaxBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const tiltDisplay = document.getElementById('tiltDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');

        // Debug logging function (displays on screen for mobile testing) - MUST BE DECLARED FIRST
        const debugDisplay = document.getElementById('debugDisplay');
        const debugLog = document.getElementById('debugLog');
        let debugMessages = [];

        function addDebugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff5252' : type === 'success' ? '#4CAF50' : '#fff';

            debugMessages.push(`<div style="color: ${color}; margin: 5px 0;">[${timestamp}] ${message}</div>`);
            if (debugMessages.length > 20) debugMessages.shift(); // Keep last 20 messages

            debugLog.innerHTML = debugMessages.join('');
            debugDisplay.style.display = 'block';

            console.log(`[DEBUG] ${message}`);
        }

        // Debug: Log all URL info
        console.log('=== QR Code Auto-fill Debug ===');
        console.log('Full URL:', window.location.href);
        console.log('Search params:', window.location.search);

        // Check URL parameters FIRST (from QR code scan)
        const urlParams = new URLSearchParams(window.location.search);
        const roomFromUrl = urlParams.get('room');
        const serverFromUrl = urlParams.get('server');
        const gameFromUrl = urlParams.get('game');

        console.log('Parsed URL params:', {
            room: roomFromUrl,
            server: serverFromUrl,
            game: gameFromUrl
        });

        // Set default server URL based on current location
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '';
        const defaultServer = isLocalhost ? 'ws://localhost:8080' : 'wss://kinemon.onrender.com';

        // Initial page load log
        addDebugLog('üì± –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ [CODE-v3]', 'success');
        addDebugLog(`Room: ${roomFromUrl || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}`, 'info');
        addDebugLog(`Game: ${gameFromUrl || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}`, 'info');
        addDebugLog(`Server: ${serverFromUrl || defaultServer}`, 'info');

        // Set game type if provided
        if (gameFromUrl) {
            gameType = gameFromUrl;
            console.log('Game type from URL:', gameType);
            addDebugLog(`üéØ gameType —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: "${gameType}"`, 'info');

            // Update game title based on game type
            const gameTitles = {
                'pong': 'PONG',
                'snake': 'PIZZA SNAKE',
                'pushers': '–¢–û–õ–ö–ê–¢–ï–õ–ò',
                'ship': 'SHIP GAME'
            };
            const newTitle = gameTitles[gameType] || 'GAME';
            gameTitle.textContent = newTitle;
            addDebugLog(`‚úèÔ∏è –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏–≥—Ä—ã –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: "${newTitle}"`, 'success');
        }

        // Set room name if provided
        if (roomFromUrl) {
            const newRoomName = `${roomFromUrl} ROOM`;
            roomNameDisplay.textContent = newRoomName;
            addDebugLog(`üè† –ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: "${newRoomName}"`, 'success');
            console.log('Room from URL:', roomFromUrl);
        }

        // Set random player name on page load
        playerNameInput.value = generateRandomPlayerName();
        console.log('Generated player name:', playerNameInput.value);

        // Log initial state to debug display
        addDebugLog(`üì± –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞`);
        addDebugLog(`Room: ${roomFromUrl || '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}`, roomFromUrl ? 'success' : 'error');
        addDebugLog(`Game: ${gameFromUrl || '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}`, gameFromUrl ? 'success' : 'error');
        addDebugLog(`Server: ${serverFromUrl || defaultServer}`);

        // Wake up Render server on page load (free tier spins down after inactivity)
        if (!isLocalhost) {
            console.log('üîÑ Waking up Render server...');
            fetch('https://kinemon.onrender.com')
                .then(() => console.log('‚úÖ Server wake-up request sent'))
                .catch((err) => console.log('‚ö†Ô∏è Server wake-up failed:', err));
        }

        // Game title already set above from gameType URL parameter
        // No need to update it again here

        // Show team selector for pushers game (unless single-square mode)
        if (gameType === 'pushers') {
            const singleSquareMode = localStorage.getItem('pushersSingleSquare') === 'true';
            if (!singleSquareMode) {
                document.getElementById('teamSelector').style.display = 'block';
            }
        }

        // Show role selection panel for Ship game
        if (gameType === 'ship') {
            document.getElementById('roleSelectionPanel').style.display = 'block';
        }

        console.log('=== End Debug ===');

        function showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if (screenName === 'room-input') {
                roomInputScreen.classList.add('active');
            } else if (screenName === 'calibration-min') {
                calibrationMinScreen.classList.add('active');
            } else if (screenName === 'calibration-max') {
                calibrationMaxScreen.classList.add('active');
            } else if (screenName === 'controller') {
                controllerScreen.classList.add('active');
            } else if (screenName === 'death') {
                deathScreen.classList.add('active');
            }
        }

        function updateRoomDisplay(room) {
            document.getElementById('roomDisplay1').textContent = room;
            document.getElementById('roomDisplay2').textContent = room;
            document.getElementById('roomDisplay3').textContent = room;
        }

        // QR Scanner removed - users can scan QR with native camera app

        // Manual join
        manualJoinBtn.addEventListener('click', async () => {
            addDebugLog('üîò –ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è', 'info');

            console.log('=== Join button clicked ===');
            console.log('roomFromUrl:', roomFromUrl);
            console.log('serverFromUrl:', serverFromUrl);
            console.log('gameType:', gameType);

            const room = roomFromUrl;
            const server = serverFromUrl || defaultServer;

            addDebugLog(`Room: ${room || '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}`, room ? 'success' : 'error');
            addDebugLog(`Server: ${server}`);

            if (!room) {
                addDebugLog('‚ùå –ù–µ—Ç –∫–æ–¥–∞ –∫–æ–º–Ω–∞—Ç—ã –≤ URL', 'error');
                alert('–ù–µ—Ç –∫–æ–¥–∞ –∫–æ–º–Ω–∞—Ç—ã –≤ URL. –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ —Å —ç–∫—Ä–∞–Ω–∞.');
                return;
            }

            // CRITICAL: Request sensor permission IMMEDIATELY on user click
            // iOS only allows this during direct user interaction
            try {
                addDebugLog('üì≤ –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞—Ç—á–∏–∫–∞–º...', 'info');
                console.log('Requesting motion permission...');
                manualJoinBtn.textContent = '–ó–∞–ø—Ä–æ—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è...';

                motionController = new MotionController();
                await motionController.requestPermission();

                addDebugLog('‚úÖ –î–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –ø–æ–ª—É—á–µ–Ω', 'success');
                console.log('‚úÖ Sensor permission granted');

                // Now connect to server
                addDebugLog(`üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ ${room}...`, 'info');
                console.log('Connecting to room:', room, 'server:', server);
                connectToRoom(room, server);
            } catch (err) {
                addDebugLog(`‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è: ${err.message}`, 'error');
                console.error('Permission error:', err);
                manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                alert('‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º –¥–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –¥–≤–∏–∂–µ–Ω–∏—è.\n\n–û—à–∏–±–∫–∞: ' + err.message + '\n\n–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Safari.');
            }
        });

        async function connectToRoom(room, serverUrl) {
            roomId = room;
            updateRoomDisplay(roomId);

            try {
                addDebugLog(`üåê –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...`, 'info');
                console.log('Connecting to:', serverUrl, 'Room:', room);

                // Show loading state
                manualJoinBtn.disabled = true;
                manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';

                // Connect to WebSocket server
                addDebugLog(`WebSocket: ${serverUrl}`, 'info');
                ws = new WebSocket(serverUrl);

                // Timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        alert('‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.\n\n–°–µ—Ä–≤–µ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ—Å—ã–ø–∞—Ç—å—Å—è (–ø–æ–¥–æ–∂–¥–∏—Ç–µ 30-60 —Å–µ–∫).\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.');
                        manualJoinBtn.disabled = false;
                        manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                        showScreen('room-input');
                    }
                }, 60000); // 60 seconds timeout

                ws.onopen = async () => {
                    clearTimeout(connectionTimeout);
                    addDebugLog('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É', 'success');
                    console.log('‚úÖ Connected to server');
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';

                    // Send ping every 30 seconds to keep connection alive
                    pingInterval = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 30000);

                    // Motion controller already initialized with permission granted
                    // Initialize calibration
                    calibration = new Calibration(motionController);

                    // Set calibration complete callback
                    calibration.onComplete = async (min, max) => {
                        console.log('Calibration complete:', min, max);

                        // Send join message with game type and control scheme
                        const joinMessage = {
                            type: 'join',
                            roomId: roomId,
                            name: playerNameInput.value.trim() || 'Player',
                            gameType: gameType,
                            controlScheme: currentControlScheme
                        };

                        // Add team for pushers game
                        if (gameType === 'pushers') {
                            joinMessage.team = document.getElementById('teamSelect').value;
                        }

                        ws.send(JSON.stringify(joinMessage));

                        playerNameDisplay.textContent = playerNameInput.value.trim() || 'Player';
                        showScreen('controller');

                        // Request wake lock to prevent phone sleep
                        if ('wakeLock' in navigator) {
                            try {
                                wakeLock = await navigator.wakeLock.request('screen');
                                console.log('Wake Lock acquired');

                                wakeLock.addEventListener('release', () => {
                                    console.log('Wake Lock released');
                                });
                            } catch (err) {
                                console.error('Wake Lock failed:', err);
                            }
                        }

                        // Vibration feedback tracking
                        let previousZone = null; // Track which zone we were in
                        let vibrationEnabled = 'vibrate' in navigator;
                        let vibrationWorking = false;

                        console.log('üîî Vibration setup:', {
                            api_available: vibrationEnabled,
                            user_agent: navigator.userAgent
                        });

                        // Start sending tilt data
                        motionController.onTiltChange = (normalized) => {
                            tiltDisplay.textContent = normalized.toFixed(2);

                            // Haptic feedback for zone transitions
                            // Zones: 'bottom' (0-0.2), 'center' (0.4-0.6), 'top' (0.8-1.0)
                            let currentZone = null;

                            if (normalized <= 0.2) {
                                currentZone = 'bottom';
                            } else if (normalized >= 0.8) {
                                currentZone = 'top';
                            } else if (normalized >= 0.4 && normalized <= 0.6) {
                                currentZone = 'center';
                            }

                            // Vibrate when entering a new zone
                            if (currentZone !== null && currentZone !== previousZone) {
                                if (vibrationEnabled) {
                                    try {
                                        // Strong vibration pattern: vibrate 100ms, pause 50ms, vibrate 100ms
                                        const vibrated = navigator.vibrate([100, 50, 100]);
                                        console.log('üîî Zone vibration:', currentZone, 'at', normalized.toFixed(2), 'result:', vibrated);
                                    } catch (err) {
                                        console.error('‚ùå Vibration failed:', err);
                                    }
                                } else {
                                    console.log('‚ö†Ô∏è Vibration not available (zone:', currentZone + ')');
                                }
                                previousZone = currentZone;
                            } else if (currentZone === null && previousZone !== null) {
                                // Exited a zone
                                previousZone = null;
                            }

                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'input',
                                    tilt: normalized
                                }));
                            }
                        };
                    };

                    // Start motion tracking and calibration
                    try {
                        motionController.start();
                        await calibration.start();
                        showScreen('calibration-min');
                    } catch (err) {
                        alert('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message);
                        showScreen('room-input');
                    }
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    addDebugLog('‚ùå –û—à–∏–±–∫–∞ WebSocket', 'error');
                    console.error('‚ùå WebSocket error:', error);
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ Render\n2. URL –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: ' + serverUrl + '\n3. –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                    showScreen('room-input');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    addDebugLog(`üîå –û—Ç–∫–ª—é—á–µ–Ω–æ (–∫–æ–¥: ${event.code})`, 'error');
                    console.log('Disconnected from server. Code:', event.code, 'Reason:', event.reason);
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';

                    // Clear ping interval
                    if (pingInterval) {
                        clearInterval(pingInterval);
                        pingInterval = null;
                    }

                    // Release wake lock
                    if (wakeLock !== null) {
                        wakeLock.release().then(() => {
                            wakeLock = null;
                        });
                    }

                    if (event.code !== 1000 && event.code !== 1001) {
                        // Abnormal closure
                        alert('‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ.\n\nCode: ' + event.code);
                    }
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'init') {
                        playerId = data.playerId;
                        console.log('Received player ID:', playerId);
                        addDebugLog(`üéÆ Init –ø–æ–ª—É—á–µ–Ω, gameType: "${gameType}"`, 'info');
                        console.log('Current gameType:', gameType, 'Type:', typeof gameType);

                        // For pushers game, show the assigned axis
                        if (gameType === 'pushers' && data.gameState && data.gameState.players) {
                            const myPlayer = data.gameState.players.find(p => p.id === playerId);
                            if (myPlayer && myPlayer.axis) {
                                document.getElementById('axisDisplay').textContent = myPlayer.axis;
                                document.getElementById('axisInfo').style.display = 'block';
                                console.log('Assigned axis:', myPlayer.axis);
                            }

                            // Hide team selector in single-square mode
                            if (data.gameState.singleSquareMode) {
                                document.getElementById('teamSelector').style.display = 'none';
                                console.log('Single-square mode: team selector hidden');
                            }
                        }

                        // For Ship game, setup role selection handlers
                        addDebugLog(`üîç –ü—Ä–æ–≤–µ—Ä–∫–∞: gameType === 'ship' ? ${gameType === 'ship'} (gameType="${gameType}")`, 'info');
                        if (gameType === 'ship') {
                            addDebugLog('‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Ä–æ–ª–µ–π –¥–ª—è Ship', 'info');
                            console.log('Setting up Ship role handlers, found buttons:', document.querySelectorAll('.role-btn').length);

                            // Role button click handler
                            document.querySelectorAll('.role-btn').forEach((btn, index) => {
                                btn.addEventListener('click', () => {
                                    const role = btn.dataset.role;
                                    addDebugLog(`üîò –ö–ª–∏–∫ –Ω–∞ –∫–Ω–æ–ø–∫—É —Ä–æ–ª–∏: ${role}`, 'info');

                                    if (ws && ws.readyState === WebSocket.OPEN) {
                                        addDebugLog(`üéØ –û—Ç–ø—Ä–∞–≤–∫–∞ change_role: ${role}`, 'success');
                                        ws.send(JSON.stringify({
                                            type: 'change_role',
                                            role: role
                                        }));
                                    } else {
                                        addDebugLog(`‚ùå WebSocket –Ω–µ –≥–æ—Ç–æ–≤ (readyState: ${ws?.readyState})`, 'error');
                                    }
                                });
                                console.log(`Added handler for role button ${index}: ${btn.dataset.role}`);
                            });

                            // Ready button click handler
                            const readyBtn = document.getElementById('readyBtn');
                            if (readyBtn) {
                                readyBtn.addEventListener('click', () => {
                                    if (ws && ws.readyState === WebSocket.OPEN) {
                                        addDebugLog('‚úÖ –ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ –ì–æ—Ç–æ–≤', 'success');
                                        ws.send(JSON.stringify({
                                            type: 'player_ready'
                                        }));
                                    }
                                });
                            }

                            // Initial role buttons update
                            if (data.gameState) {
                                updateRoleButtons(data.gameState);
                            }
                        }
                    }

                    if (data.type === 'update' && data.gameState) {
                        // Update role buttons for Ship game
                        if (data.gameState.gameType === 'ship') {
                            updateRoleButtons(data.gameState);
                        }

                        // Check if this player died (only for Snake, not Pong)
                        if (data.gameState.gameType === 'snake') {
                            const myPlayer = data.gameState.players.find(p => p.id === playerId);

                            if (myPlayer && !myPlayer.alive) {
                                // Show death screen
                                document.getElementById('deathScore').textContent = myPlayer.score;
                                showScreen('death');

                                // Stop sending motion data while dead
                                motionController.onTiltChange = null;
                            }
                        }
                    }
                };
            } catch (error) {
                addDebugLog(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ${error.message}`, 'error');
                console.error('Connection error:', error);
                alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                showScreen('room-input');
            }
        }

        setMinBtn.addEventListener('click', () => {
            calibration.setMinPosition();
            showScreen('calibration-max');
        });

        setMaxBtn.addEventListener('click', () => {
            calibration.setMaxPosition();
        });

        disconnectBtn.addEventListener('click', () => {
            if (ws) {
                ws.close();
            }
            if (motionController) {
                motionController.stop();
            }
            showScreen('room-input');
        });

        document.getElementById('respawnBtn').addEventListener('click', () => {
            // Request respawn from server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'respawn',
                    controlScheme: currentControlScheme
                }));

                // Return to controller screen
                showScreen('controller');

                // Show control selector again
                document.getElementById('controlSelector').style.display = 'block';

                // Resume sending motion data
                motionController.onTiltChange = (normalized) => {
                    tiltDisplay.textContent = normalized.toFixed(2);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'input',
                            tilt: normalized
                        }));
                    }
                };
            }
        });

        // Role selection logic for Ship game
        let currentRole = null;
        let isReady = false;

        function updateRoleButtons(gameState) {
            if (gameType !== 'ship') return;

            const roleButtons = document.querySelectorAll('.role-btn');
            const players = gameState.players || [];
            const myPlayer = players.find(p => p.id === playerId);

            roleButtons.forEach(btn => {
                const role = btn.dataset.role;
                const occupiedBy = players.find(p => p.systemRole === role);

                // Reset button text to default
                const roleNames = {
                    engine: '‚öôÔ∏è –î–≤–∏–≥–∞—Ç–µ–ª—å',
                    rudder: 'üß≠ –†—É–ª—å',
                    weapon: 'üî´ –û—Ä—É–∂–∏–µ',
                    weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                    shield: 'üõ°Ô∏è –©–∏—Ç'
                };
                btn.textContent = roleNames[role];

                if (occupiedBy && occupiedBy.id !== playerId) {
                    // Role is taken by another player
                    btn.disabled = true;
                    btn.textContent = `${roleNames[role].split(' ')[0]} ${occupiedBy.name}`;
                    btn.style.opacity = '0.5';
                    btn.classList.remove('selected');
                } else if (occupiedBy && occupiedBy.id === playerId) {
                    // This is my role
                    btn.disabled = false;
                    btn.style.opacity = '1.0';
                    btn.classList.add('selected');
                    currentRole = role;
                } else {
                    // Role is free
                    btn.disabled = false;
                    btn.style.opacity = '1.0';
                    btn.classList.remove('selected');
                }
            });

            // Update Ready button state (only on room input screen)
            const readyBtn = document.getElementById('readyBtn');
            const readyHint = document.getElementById('readyHint');

            if (readyBtn) {
                if (currentRole) {
                    readyBtn.disabled = false;
                    if (readyHint) readyHint.style.display = 'none';
                } else {
                    readyBtn.disabled = true;
                    if (readyHint) readyHint.style.display = 'block';
                }

                // If player is ready, show different text
                if (myPlayer && myPlayer.ready) {
                    readyBtn.textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤...';
                    readyBtn.disabled = true;
                    isReady = true;
                }

                // If game started, switch to controller screen
                if (gameState.gameStarted && roomInputScreen.classList.contains('active')) {
                    showScreen('calibration-min');
                }
            }
        }

        // Show role panel if Ship game (moved to page load)
        if (gameType === 'ship') {
            const rolePanel = document.getElementById('roleSelectionPanel');
            if (rolePanel) {
                rolePanel.style.display = 'block';
            }
        }
    </script>
</body>
</html>
