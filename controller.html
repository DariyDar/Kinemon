<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="version" content="3.12.1-c0db40a">
    <title>Kinemon - Controller v3.12.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            touch-action: none;
        }

        #container {
            width: 100%;
            max-width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        .screen {
            display: none;
            max-width: 500px;
            width: 100%;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }

        p {
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.8;
            line-height: 1.6;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
            display: inline-block;
            min-width: 200px;
        }

        .btn:active {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
        }

        .btn-secondary:active {
            background: #0b7dda;
        }

        .btn-danger {
            background: #F44336;
        }

        .btn-danger:active {
            background: #da190b;
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 18px;
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid #F44336;
        }

        #controlSchemeSelect {
            cursor: pointer;
        }

        #controlSchemeSelect:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 2px;
        }

        #controlSelector {
            user-select: none;
            -webkit-user-select: none;
        }

        .calibration-indicator {
            font-size: 64px;
            margin: 20px 0;
        }

        .instruction {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .tilt-display {
            font-size: 48px;
            font-weight: bold;
            color: #4CAF50;
            margin: 20px 0;
        }

        #deathScreen {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1a1a 100%);
        }

        #deathScore {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 8px;
        }

        .info {
            font-size: 14px;
            opacity: 0.6;
            margin-top: 20px;
        }

        #qrReader {
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
        }

        #qrReader video {
            width: 100%;
            border-radius: 10px;
        }

        .room-display {
            font-size: 36px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 4px;
            margin: 20px 0;
        }

        /* Role selection panel */
        .role-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .role-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 15px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .role-btn:active:not(:disabled) {
            background: #0b7dda;
            transform: scale(0.98);
        }

        .role-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .role-btn.selected {
            background: #4CAF50;
        }

        /* Role buttons in overlay (match lobby styling) */
        .role-btn-overlay {
            background: #2196F3;
            color: white;
            border: none;
            padding: 15px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .role-btn-overlay:active:not(:disabled) {
            background: #0b7dda;
            transform: scale(0.98);
        }

        .role-btn-overlay:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .role-btn-overlay.selected {
            background: #4CAF50;
        }

        .role-btn-overlay.exit-role {
            background: #f44336;
        }

        .role-btn-overlay.exit-role:active:not(:disabled) {
            background: #da190b;
        }

        /* Exit role state for both lobby and overlay buttons */
        .role-btn.exit-role,
        .role-btn-overlay.exit-role {
            background: #f44336;
        }

        .role-btn.exit-role:active:not(:disabled),
        .role-btn-overlay.exit-role:active:not(:disabled) {
            background: #da190b;
        }

        /* Team selector buttons */
        .team-btn {
            flex: 1;
            background: #555;
            color: white;
            border: none;
            padding: 20px;
            font-size: 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .team-btn:active:not(:disabled) {
            transform: scale(0.98);
        }

        .team-btn.selected {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        #blueTeamBtn.selected {
            background: #2196F3;
        }

        #pinkTeamBtn.selected {
            background: #E91E63;
        }

        #releaseRoleBtn {
            background: #f44336;
            width: 100%;
        }

        #releaseRoleBtn:active {
            background: #da190b;
        }

        #readyBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #readyHint {
            font-size: 14px;
            color: #999;
            margin-top: 5px;
        }

        .role-panel-title {
            font-size: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* Adaptive styles for small screens */
        @media (max-height: 700px) {
            #container {
                padding: 10px;
            }

            h1 {
                font-size: 32px;
                margin-bottom: 10px;
            }

            h2 {
                font-size: 24px;
                margin-bottom: 10px;
            }

            h3 {
                font-size: 18px;
                margin-bottom: 8px;
            }

            p {
                font-size: 14px;
                margin-bottom: 15px;
            }

            .btn {
                padding: 12px 24px;
                font-size: 16px;
                margin: 6px;
                min-width: 150px;
            }

            .role-btn {
                padding: 12px 20px;
                font-size: 16px;
                margin: 5px;
            }

            .team-btn {
                padding: 10px 16px;
                font-size: 14px;
            }

            .calibration-indicator {
                font-size: 48px;
                margin: 10px 0;
            }

            .instruction {
                font-size: 14px;
            }

            .tilt-display {
                font-size: 36px;
                margin: 10px 0;
            }

            .info p {
                font-size: 14px;
                margin-bottom: 8px;
            }

            .role-panel-title {
                font-size: 16px;
                margin-bottom: 8px;
            }

            #lobbyPlayers {
                margin-top: 15px;
                padding: 10px;
            }

            #leavePostBtn, #recalibrateBtn {
                padding: 8px 16px;
                font-size: 14px;
            }

            #leavePostBtn {
                left: 8px;
                top: 8px;
            }

            #recalibrateBtn {
                left: 140px;
                top: 8px;
            }
        }

        @media (max-height: 600px) {
            h1 {
                font-size: 24px;
                margin-bottom: 8px;
            }

            h2 {
                font-size: 20px;
                margin-bottom: 8px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 14px;
                margin: 4px;
            }

            .role-btn {
                padding: 10px 16px;
                font-size: 14px;
                margin: 4px;
            }

            .calibration-indicator {
                font-size: 36px;
                margin: 8px 0;
            }

            .tilt-display {
                font-size: 28px;
                margin: 8px 0;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Room Input Screen -->
        <div id="roomInputScreen" class="screen active">
            <h1 id="gameTitle">GAME</h1>
            <h2 id="roomNameDisplay" style="font-size: 28px; color: #4CAF50; margin-bottom: 30px;">ROOMNAME ROOM</h2>

            <label for="playerName" style="display: block; font-size: 16px; margin-bottom: 8px; opacity: 0.8;">–í–∞—à–µ –∏–º—è:</label>
            <input type="text" id="playerName" placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è" maxlength="20">
            <br>
            <button class="btn btn-secondary" id="manualJoinBtn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>

        </div>

        <!-- Lobby Screen (Ship only) -->
        <div id="lobbyScreen" class="screen">
            <h2>üöÄ –õ–æ–±–±–∏</h2>
            <h3 id="lobbyRoomName" style="font-size: 24px; color: #4CAF50; margin-bottom: 20px;">ROOM NAME</h3>

            <!-- Team Selection (Ship only) -->
            <div id="teamSelector" style="display: none; margin-bottom: 20px;">
                <div class="role-panel-title">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:</div>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button id="blueTeamBtn" class="team-btn" data-team="blue">üîµ –ì–æ–ª—É–±–∞—è –∫–æ–º–∞–Ω–¥–∞</button>
                    <button id="pinkTeamBtn" class="team-btn" data-team="pink">ü©∑ –†–æ–∑–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞</button>
                </div>
                <div id="teamHint" style="font-size: 14px; opacity: 0.7;">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –ø–µ—Ä–µ–¥ –≤—ã–±–æ—Ä–æ–º —Ä–æ–ª–∏</div>
            </div>

            <!-- Role Selection Panel -->
            <div id="roleSelectionPanel" style="display: block;">
                <div class="role-panel-title">–í—ã–±–æ—Ä —Ä–æ–ª–∏:</div>
                <div class="role-buttons">
                    <button class="role-btn" data-role="engine">‚öôÔ∏è –¢—è–≥–∞</button>
                    <button class="role-btn" data-role="rudder">üß≠ –†—É–ª—å</button>
                    <button class="role-btn" data-role="weapon">üî´ –ü—É—à–∫–∞</button>
                    <button class="role-btn" data-role="weaponDirection">üéØ –ü—Ä–∏—Ü–µ–ª</button>
                    <button class="role-btn" data-role="shield">üõ°Ô∏è –©–∏—Ç</button>
                </div>

                <!-- Ready button (disabled until role is selected) -->
                <button id="readyBtn" class="btn" style="margin-top: 15px; width: 100%;" disabled>üòä –ì–æ—Ç–æ–≤</button>
                <div id="readyHint" style="margin-top: 10px; font-size: 14px; opacity: 0.7;">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å</div>
            </div>

            <!-- Other Players in Lobby -->
            <div id="lobbyPlayers" style="margin-top: 30px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                <div style="font-weight: bold; margin-bottom: 10px; font-size: 16px;">–î—Ä—É–≥–∏–µ –∏–≥—Ä–æ–∫–∏:</div>
                <div id="lobbyPlayersList" style="font-size: 14px; line-height: 1.8;">
                    <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è -->
                </div>
            </div>
        </div>

        <!-- QR Scanner Screen removed - now using native camera app -->

        <!-- Calibration Min Screen -->
        <div id="calibrationMinScreen" class="screen">
            <h2>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay1"></span></div>
            <div class="calibration-indicator">‚¨áÔ∏è</div>
            <div class="instruction">
                <p><strong>–®–∞–≥ 1 –∏–∑ 2</strong></p>
                <p>–ù–∞–∫–ª–æ–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ<br>–¥–ª—è –ù–ò–ñ–ù–ï–ô –ø–æ–∑–∏—Ü–∏–∏</p>
            </div>
            <button id="setMinBtn" class="btn">–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <!-- Calibration Max Screen -->
        <div id="calibrationMaxScreen" class="screen">
            <h2>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay2"></span></div>
            <div class="calibration-indicator">‚¨ÜÔ∏è</div>
            <div class="instruction">
                <p><strong>–®–∞–≥ 2 –∏–∑ 2</strong></p>
                <p>–ù–∞–∫–ª–æ–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ<br>–¥–ª—è –í–ï–†–•–ù–ï–ô –ø–æ–∑–∏—Ü–∏–∏</p>
            </div>
            <button id="setMaxBtn" class="btn">–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <!-- Controller Screen -->
        <div id="controllerScreen" class="screen">
            <!-- Change Role button (Ship only) -->
            <button id="leavePostBtn" style="display: none; position: absolute; top: 10px; left: 10px; padding: 10px 20px; background: #FF9800; color: white; border: none; border-radius: 8px; font-size: 16px; z-index: 100;">
                üîÑ –°–º–µ–Ω–∏—Ç—å —Ä–æ–ª—å
            </button>

            <!-- Calibration button (Ship only) -->
            <button id="recalibrateBtn" style="display: none; position: absolute; top: 10px; left: 200px; padding: 10px 15px; font-size: 14px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 100;">
                üìê –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞
            </button>

            <h2>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay3"></span></div>
            <div class="tilt-display" id="tiltDisplay">0.50</div>
            <p>–ù–∞–∫–ª–æ–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</p>
            <div class="info">
                <p id="playerInfo">–ò–≥—Ä–æ–∫: <span id="playerNameDisplay"></span></p>
                <p id="roleInfo" style="display: none; margin-top: 10px; font-size: 18px; font-weight: bold; color: #4CAF50;">
                    <span id="teamDisplay" style="display: none;"></span><br>
                    –í–∞—à–∞ —Ä–æ–ª—å: <span id="roleDisplay"></span>
                </p>
                <p id="axisInfo" style="display: none; margin-top: 10px; font-size: 18px; font-weight: bold;">–í–∞—à–∞ –æ—Å—å: <span id="axisDisplay"></span></p>
            </div>

            <button class="btn btn-danger" id="disconnectBtn">–û—Ç–∫–ª—é—á–∏—Ç—å—Å—è</button>
        </div>

        <!-- Role Change Overlay (Ship only, during game) -->
        <div id="roleChangeOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.9); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: #1a1a2e; padding: 30px; border-radius: 15px; max-width: 500px; width: 90%;">
                <h3 style="margin-bottom: 20px;">–°–º–µ–Ω–∞ —Ä–æ–ª–∏</h3>

                <div id="roleSelectionInGame">
                    <div class="role-panel-title">–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é —Ä–æ–ª—å:</div>
                    <div class="role-buttons">
                        <button class="role-btn-overlay" data-role="engine">‚öôÔ∏è –¢—è–≥–∞</button>
                        <button class="role-btn-overlay" data-role="rudder">üß≠ –†—É–ª—å</button>
                        <button class="role-btn-overlay" data-role="weapon">üî´ –ü—É—à–∫–∞</button>
                        <button class="role-btn-overlay" data-role="weaponDirection">üéØ –ü—Ä–∏—Ü–µ–ª</button>
                        <button class="role-btn-overlay" data-role="shield">üõ°Ô∏è –©–∏—Ç</button>
                    </div>
                </div>

                <button id="cancelRoleChange" class="btn" style="margin-top: 20px; width: 100%;">–û—Ç–º–µ–Ω–∞</button>
            </div>
        </div>

        <!-- Death Screen -->
        <div id="deathScreen" class="screen">
            <h1 style="font-size: 36px; margin-bottom: 30px;">üíÄ –ü–æ—Ä–∞–∂–µ–Ω–∏–µ</h1>
            <p id="deathMessage" style="font-size: 20px; line-height: 1.6; margin-bottom: 40px;">
                –£ —Ç–µ–±—è –±—ã–ª–æ <span id="deathScore" style="color: #FFD700; font-size: 28px; font-weight: bold;">0</span> –ø–∏—Ü—Ü –Ω–∞ –º–æ–º–µ–Ω—Ç —Å–º–µ—Ä—Ç–∏
            </p>
            <p style="font-size: 18px; opacity: 0.8; margin-bottom: 40px;">
                –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –≤ –±–æ–π, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –∏—Ö –æ–±—Ä–∞—Ç–Ω–æ!
            </p>
            <button class="btn" id="respawnBtn" style="font-size: 24px; padding: 20px 40px;">
                üîÑ –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –±–æ–π!
            </button>
        </div>

    </div>

    <script src="motionController.js"></script>
    <script src="calibration.js"></script>
    <script>
        // Generate random player name on page load
        function generateRandomPlayerName() {
            const adjectives = ['Brave', 'Lazy', 'Happy', 'Angry', 'Clever', 'Tiny', 'Huge', 'Swift', 'Bold', 'Shy',
                                'Wild', 'Calm', 'Loud', 'Quiet', 'Crazy', 'Smart', 'Lucky', 'Grumpy'];
            const nouns = ['Fox', 'Bear', 'Wolf', 'Eagle', 'Tiger', 'Shark', 'Panda', 'Lion', 'Owl', 'Raven',
                           'Falcon', 'Jaguar', 'Lynx', 'Otter', 'Hawk', 'Moose', 'Bison', 'Crane'];

            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];

            return `${adj} ${noun}`;
        }

        let ws = null;
        let motionController = null;
        let calibration = null;
        let playerId = null;
        let roomId = null;
        let gameType = 'snake'; // Default game type
        let wakeLock = null;
        let pingInterval = null;
        let roleBeforeChange = null; // Track role before opening change overlay

        // Load saved control preference from localStorage
        let currentControlScheme = localStorage.getItem('playerControlScheme') || 'rotation_smooth';

        const roomInputScreen = document.getElementById('roomInputScreen');
        const lobbyScreen = document.getElementById('lobbyScreen');
        const calibrationMinScreen = document.getElementById('calibrationMinScreen');
        const calibrationMaxScreen = document.getElementById('calibrationMaxScreen');
        const controllerScreen = document.getElementById('controllerScreen');
        const deathScreen = document.getElementById('deathScreen');

        const playerNameInput = document.getElementById('playerName');
        const manualJoinBtn = document.getElementById('manualJoinBtn');
        const gameTitle = document.getElementById('gameTitle');
        const roomNameDisplay = document.getElementById('roomNameDisplay');
        const setMinBtn = document.getElementById('setMinBtn');
        const setMaxBtn = document.getElementById('setMaxBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const tiltDisplay = document.getElementById('tiltDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');

        // Debug logging function (displays on screen for mobile testing) - MUST BE DECLARED FIRST
        // Debug logging disabled in production
        function addDebugLog(message, type = 'info') {
            // No-op - debug logs removed from UI
        }

        // Debug: Log all URL info
        console.log('=== QR Code Auto-fill Debug ===');
        console.log('Full URL:', window.location.href);
        console.log('Search params:', window.location.search);

        // Check URL parameters FIRST (from QR code scan)
        const urlParams = new URLSearchParams(window.location.search);
        const roomFromUrl = urlParams.get('room');
        const serverFromUrl = urlParams.get('server');
        const gameFromUrl = urlParams.get('game');

        console.log('Parsed URL params:', {
            room: roomFromUrl,
            server: serverFromUrl,
            game: gameFromUrl
        });

        // Set default server URL based on current location
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '';
        const defaultServer = isLocalhost ? 'ws://localhost:8080' : 'wss://kinemon.onrender.com';

        // Initial page load log
        addDebugLog('üì± –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ [v3.16.1 - Two-Team Ship Gameplay]', 'success');
        addDebugLog(`Room: ${roomFromUrl || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}`, 'info');
        addDebugLog(`Game: ${gameFromUrl || '–Ω–µ —É–∫–∞–∑–∞–Ω–æ'}`, 'info');
        addDebugLog(`Server: ${serverFromUrl || defaultServer}`, 'info');

        // Set game type if provided
        if (gameFromUrl) {
            gameType = gameFromUrl;
            console.log('Game type from URL:', gameType);
            addDebugLog(`üéØ gameType —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: "${gameType}"`, 'info');

            // Update game title based on game type
            const gameTitles = {
                'pong': 'PONG',
                'snake': 'PIZZA SNAKE',
                'pushers': '–¢–û–õ–ö–ê–¢–ï–õ–ò',
                'ship': 'SHIP GAME'
            };
            const newTitle = gameTitles[gameType] || 'GAME';
            gameTitle.textContent = newTitle;
            addDebugLog(`‚úèÔ∏è –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏–≥—Ä—ã –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: "${newTitle}"`, 'success');
        }

        // Set room name if provided
        if (roomFromUrl) {
            const newRoomName = `${roomFromUrl} ROOM`;
            roomNameDisplay.textContent = newRoomName;
            addDebugLog(`üè† –ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: "${newRoomName}"`, 'success');
            console.log('Room from URL:', roomFromUrl);
        }

        // Set random player name on page load
        playerNameInput.value = generateRandomPlayerName();
        console.log('Generated player name:', playerNameInput.value);

        // Log initial state to debug display
        addDebugLog(`üì± –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞`);
        addDebugLog(`Room: ${roomFromUrl || '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}`, roomFromUrl ? 'success' : 'error');
        addDebugLog(`Game: ${gameFromUrl || '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}`, gameFromUrl ? 'success' : 'error');
        addDebugLog(`Server: ${serverFromUrl || defaultServer}`);

        // Wake up Render server on page load (free tier spins down after inactivity)
        if (!isLocalhost) {
            console.log('üîÑ Waking up Render server...');
            fetch('https://kinemon.onrender.com')
                .then(() => console.log('‚úÖ Server wake-up request sent'))
                .catch((err) => console.log('‚ö†Ô∏è Server wake-up failed:', err));
        }

        // Game title already set above from gameType URL parameter
        // No need to update it again here

        // Show team selector for pushers game (unless single-square mode)
        if (gameType === 'pushers') {
            const singleSquareMode = localStorage.getItem('pushersSingleSquare') === 'true';
            if (!singleSquareMode) {
                document.getElementById('teamSelector').style.display = 'block';
            }
        }

        // Show role selection panel and team selector for Ship game
        if (gameType === 'ship') {
            document.getElementById('roleSelectionPanel').style.display = 'block';
            document.getElementById('teamSelector').style.display = 'block';
        }

        console.log('=== End Debug ===');

        function showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if (screenName === 'room-input') {
                roomInputScreen.classList.add('active');
            } else if (screenName === 'lobby') {
                lobbyScreen.classList.add('active');
            } else if (screenName === 'calibration-min') {
                calibrationMinScreen.classList.add('active');
            } else if (screenName === 'calibration-max') {
                calibrationMaxScreen.classList.add('active');
            } else if (screenName === 'controller') {
                controllerScreen.classList.add('active');
                // Ensure role change and calibration buttons are visible for Ship game players
                const leavePostBtn = document.getElementById('leavePostBtn');
                const recalibrateBtn = document.getElementById('recalibrateBtn');
                if (gameType === 'ship') {
                    if (leavePostBtn) leavePostBtn.style.display = 'block';
                    if (recalibrateBtn) recalibrateBtn.style.display = 'block';
                }
            } else if (screenName === 'death') {
                deathScreen.classList.add('active');
            }
        }

        function updateRoomDisplay(room) {
            document.getElementById('roomDisplay1').textContent = room;
            document.getElementById('roomDisplay2').textContent = room;
            document.getElementById('roomDisplay3').textContent = room;
        }

        // QR Scanner removed - users can scan QR with native camera app

        // Manual join
        manualJoinBtn.addEventListener('click', async () => {
            addDebugLog('üîò –ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è', 'info');

            console.log('=== Join button clicked ===');
            console.log('roomFromUrl:', roomFromUrl);
            console.log('serverFromUrl:', serverFromUrl);
            console.log('gameType:', gameType);

            const room = roomFromUrl;
            const server = serverFromUrl || defaultServer;

            addDebugLog(`Room: ${room || '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}`, room ? 'success' : 'error');
            addDebugLog(`Server: ${server}`);

            if (!room) {
                addDebugLog('‚ùå –ù–µ—Ç –∫–æ–¥–∞ –∫–æ–º–Ω–∞—Ç—ã –≤ URL', 'error');
                alert('–ù–µ—Ç –∫–æ–¥–∞ –∫–æ–º–Ω–∞—Ç—ã –≤ URL. –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ —Å —ç–∫—Ä–∞–Ω–∞.');
                return;
            }

            // CRITICAL: Request sensor permission IMMEDIATELY on user click
            // iOS only allows this during direct user interaction
            try {
                addDebugLog('üì≤ –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞—Ç—á–∏–∫–∞–º...', 'info');
                console.log('Requesting motion permission...');
                manualJoinBtn.textContent = '–ó–∞–ø—Ä–æ—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è...';

                motionController = new MotionController();
                await motionController.requestPermission();

                addDebugLog('‚úÖ –î–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –ø–æ–ª—É—á–µ–Ω', 'success');
                console.log('‚úÖ Sensor permission granted');

                // Now connect to server
                addDebugLog(`üîå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ ${room}...`, 'info');
                console.log('Connecting to room:', room, 'server:', server);
                connectToRoom(room, server);
            } catch (err) {
                addDebugLog(`‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è: ${err.message}`, 'error');
                console.error('Permission error:', err);
                manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                alert('‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º –¥–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –¥–≤–∏–∂–µ–Ω–∏—è.\n\n–û—à–∏–±–∫–∞: ' + err.message + '\n\n–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Safari.');
            }
        });

        async function connectToRoom(room, serverUrl) {
            roomId = room;
            updateRoomDisplay(roomId);

            try {
                addDebugLog(`üåê –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...`, 'info');
                console.log('Connecting to:', serverUrl, 'Room:', room);

                // Show loading state
                manualJoinBtn.disabled = true;
                manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';

                // Connect to WebSocket server
                addDebugLog(`WebSocket: ${serverUrl}`, 'info');
                ws = new WebSocket(serverUrl);

                // Timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        alert('‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.\n\n–°–µ—Ä–≤–µ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ—Å—ã–ø–∞—Ç—å—Å—è (–ø–æ–¥–æ–∂–¥–∏—Ç–µ 30-60 —Å–µ–∫).\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.');
                        manualJoinBtn.disabled = false;
                        manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                        showScreen('room-input');
                    }
                }, 60000); // 60 seconds timeout

                ws.onopen = async () => {
                    clearTimeout(connectionTimeout);
                    addDebugLog('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É', 'success');
                    console.log('‚úÖ Connected to server');
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';

                    // Send ping every 30 seconds to keep connection alive
                    pingInterval = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 30000);

                    // Motion controller already initialized with permission granted
                    // Initialize calibration
                    calibration = new Calibration(motionController);

                    // Set calibration step change callback
                    calibration.onStepChange = (step) => {
                        console.log('Calibration step changed:', step);
                        if (step === 'waiting_min') {
                            showScreen('calibration-min');
                        } else if (step === 'waiting_max') {
                            showScreen('calibration-max');
                        }
                    };

                    // Set calibration complete callback
                    calibration.onComplete = async (min, max) => {
                        console.log('Calibration complete:', min, max);
                        addDebugLog('‚úÖ –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞', 'success');

                        // Check if this is recalibration (don't send player_ready again)
                        if (window.isRecalibrating) {
                            addDebugLog('üîÑ –†–µ–∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –≤–æ–∑–≤—Ä–∞—Ç –∫ –∏–≥—Ä–µ', 'success');
                            window.isRecalibrating = false;

                            // Restore role after recalibration
                            if (window.roleBeforeRecalibration && ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'change_role',
                                    role: window.roleBeforeRecalibration
                                }));
                                addDebugLog(`üéÆ –í–æ–∑–≤—Ä–∞—Ç —Ä–æ–ª–∏: ${window.roleBeforeRecalibration}`, 'success');
                                window.roleBeforeRecalibration = null;
                            }

                            showScreen('controller');
                            return;
                        }

                        // For Ship game: send player_ready after calibration
                        if (gameType === 'ship') {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'player_ready'
                                }));
                                addDebugLog('üéÆ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ player_ready', 'success');
                            }
                        } else {
                            // For other games: send join message with game type and control scheme
                            const joinMessage = {
                                type: 'join',
                                roomId: roomId,
                                name: playerNameInput.value.trim() || 'Player',
                                gameType: gameType,
                                controlScheme: currentControlScheme
                            };

                            // Add team for pushers game
                            if (gameType === 'pushers') {
                                joinMessage.team = document.getElementById('teamSelect').value;
                            }

                            ws.send(JSON.stringify(joinMessage));
                        }

                        playerNameDisplay.textContent = playerNameInput.value.trim() || 'Player';
                        showScreen('controller');

                        // Request wake lock to prevent phone sleep
                        if ('wakeLock' in navigator) {
                            try {
                                wakeLock = await navigator.wakeLock.request('screen');
                                console.log('Wake Lock acquired');

                                wakeLock.addEventListener('release', () => {
                                    console.log('Wake Lock released');
                                });
                            } catch (err) {
                                console.error('Wake Lock failed:', err);
                            }
                        }

                        // Vibration feedback tracking
                        let previousZone = null; // Track which zone we were in
                        let vibrationEnabled = 'vibrate' in navigator;
                        let vibrationWorking = false;

                        console.log('üîî Vibration setup:', {
                            api_available: vibrationEnabled,
                            user_agent: navigator.userAgent
                        });

                        // Start sending tilt data
                        motionController.onTiltChange = (normalized) => {
                            tiltDisplay.textContent = normalized.toFixed(2);

                            // Haptic feedback for zone transitions
                            // Zones: 'bottom' (0-0.2), 'center' (0.4-0.6), 'top' (0.8-1.0)
                            let currentZone = null;

                            if (normalized <= 0.2) {
                                currentZone = 'bottom';
                            } else if (normalized >= 0.8) {
                                currentZone = 'top';
                            } else if (normalized >= 0.4 && normalized <= 0.6) {
                                currentZone = 'center';
                            }

                            // Vibrate when entering a new zone
                            if (currentZone !== null && currentZone !== previousZone) {
                                if (vibrationEnabled) {
                                    try {
                                        // Strong vibration pattern: vibrate 100ms, pause 50ms, vibrate 100ms
                                        const vibrated = navigator.vibrate([100, 50, 100]);
                                        console.log('üîî Zone vibration:', currentZone, 'at', normalized.toFixed(2), 'result:', vibrated);
                                    } catch (err) {
                                        console.error('‚ùå Vibration failed:', err);
                                    }
                                } else {
                                    console.log('‚ö†Ô∏è Vibration not available (zone:', currentZone + ')');
                                }
                                previousZone = currentZone;
                            } else if (currentZone === null && previousZone !== null) {
                                // Exited a zone
                                previousZone = null;
                            }

                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'input',
                                    tilt: normalized
                                }));
                            }
                        };
                    };

                    // For Ship game: send join immediately, show role selection
                    if (gameType === 'ship') {
                        addDebugLog('üö¢ Ship –∏–≥—Ä–∞ - –æ—Ç–ø—Ä–∞–≤–∫–∞ join —Å—Ä–∞–∑—É', 'info');
                        const joinMessage = {
                            type: 'join',
                            roomId: roomId,
                            name: playerNameInput.value.trim() || 'Player',
                            gameType: gameType,
                            controlScheme: currentControlScheme
                        };
                        ws.send(JSON.stringify(joinMessage));
                        addDebugLog('‚úÖ Join –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω, –æ–∂–∏–¥–∞–µ–º init...', 'success');
                        console.log('Sent join message for Ship game:', joinMessage);

                        // Don't start calibration yet - wait for role selection
                        // Calibration will start when player clicks "Ready" button
                    } else {
                        // For other games: start calibration immediately
                        try {
                            motionController.start();
                            await calibration.start();
                            showScreen('calibration-min');
                        } catch (err) {
                            alert('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message);
                            showScreen('room-input');
                        }
                    }
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    addDebugLog('‚ùå –û—à–∏–±–∫–∞ WebSocket', 'error');
                    console.error('‚ùå WebSocket error:', error);
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ Render\n2. URL –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: ' + serverUrl + '\n3. –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                    showScreen('room-input');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    addDebugLog(`üîå –û—Ç–∫–ª—é—á–µ–Ω–æ (–∫–æ–¥: ${event.code})`, 'error');
                    console.log('Disconnected from server. Code:', event.code, 'Reason:', event.reason);
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';

                    // Clear ping interval
                    if (pingInterval) {
                        clearInterval(pingInterval);
                        pingInterval = null;
                    }

                    // Release wake lock
                    if (wakeLock !== null) {
                        wakeLock.release().then(() => {
                            wakeLock = null;
                        });
                    }

                    // Always show friendly message for all disconnect types
                    alert('üëã –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–∫–∏–Ω—É–ª–∏ –∏–≥—Ä—É, –∑–∞—Ö–æ–¥–∏—Ç–µ –µ—â—ë!');
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    // Only log important messages to avoid spam
                    if (data.type !== 'update' && data.type !== 'pong') {
                        addDebugLog(`üì© –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: ${data.type}`, 'info');
                        console.log('WS Message received:', data);
                    }

                    if (data.type === 'init') {
                        playerId = data.playerId;
                        console.log('Received player ID:', playerId);
                        addDebugLog(`üéÆ Init –ø–æ–ª—É—á–µ–Ω, gameType: "${gameType}"`, 'info');
                        console.log('Current gameType:', gameType, 'Type:', typeof gameType);

                        // For pushers game, show the assigned axis
                        if (gameType === 'pushers' && data.gameState && data.gameState.players) {
                            const myPlayer = data.gameState.players.find(p => p.id === playerId);
                            if (myPlayer && myPlayer.axis) {
                                document.getElementById('axisDisplay').textContent = myPlayer.axis;
                                document.getElementById('axisInfo').style.display = 'block';
                                console.log('Assigned axis:', myPlayer.axis);
                            }

                            // Hide team selector in single-square mode
                            if (data.gameState.singleSquareMode) {
                                document.getElementById('teamSelector').style.display = 'none';
                                console.log('Single-square mode: team selector hidden');
                            }
                        }

                        // For Ship game, setup role selection handlers
                        addDebugLog(`üîç –ü—Ä–æ–≤–µ—Ä–∫–∞: gameType === 'ship' ? ${gameType === 'ship'} (gameType="${gameType}")`, 'info');
                        if (gameType === 'ship') {
                            addDebugLog('‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Ä–æ–ª–µ–π –¥–ª—è Ship', 'info');

                            const roleButtons = document.querySelectorAll('.role-btn');
                            addDebugLog(`üîò –ù–∞–π–¥–µ–Ω–æ –∫–Ω–æ–ø–æ–∫ —Ä–æ–ª–µ–π: ${roleButtons.length}`, 'info');
                            console.log('Setting up Ship role handlers, found buttons:', roleButtons.length);
                            console.log('Role buttons:', roleButtons);

                            // Role button click handler
                            roleButtons.forEach((btn, index) => {
                                addDebugLog(`‚ûï –î–æ–±–∞–≤–ª—è—é –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ ${index}: ${btn.dataset.role}`, 'info');

                                btn.addEventListener('click', () => {
                                    const role = btn.dataset.role;

                                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —ç—Ç–æ –∫–Ω–æ–ø–∫–∞ –≤—ã—Ö–æ–¥–∞ –∏–ª–∏ –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏
                                    const myPlayer = window.currentGameState?.players?.find(p => p.id === playerId);
                                    const isMyRole = myPlayer && myPlayer.systemRole === role;

                                    if (isMyRole) {
                                        // –í—ã—Ö–æ–¥ –∏–∑ —Ä–æ–ª–∏
                                        addDebugLog('üö™ –í—ã—Ö–æ–¥ –∏–∑ —Ä–æ–ª–∏', 'info');

                                        if (ws && ws.readyState === WebSocket.OPEN) {
                                            ws.send(JSON.stringify({
                                                type: 'change_role',
                                                role: null
                                            }));
                                        }
                                    } else {
                                        // –í—ã–±–æ—Ä –Ω–æ–≤–æ–π —Ä–æ–ª–∏
                                        addDebugLog(`üîò –ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ —Ä–æ–ª–∏: ${role}`, 'success');

                                        if (ws && ws.readyState === WebSocket.OPEN) {
                                            ws.send(JSON.stringify({
                                                type: 'change_role',
                                                role: role
                                            }));
                                        } else {
                                            addDebugLog(`‚ùå WebSocket –Ω–µ –≥–æ—Ç–æ–≤ (readyState: ${ws?.readyState})`, 'error');
                                        }
                                    }
                                }, { capture: true });

                                console.log(`Added handler for role button ${index}: ${btn.dataset.role}`);
                            });

                            // Team button click handlers
                            const teamButtons = document.querySelectorAll('.team-btn');
                            const blueTeamBtn = document.getElementById('blueTeamBtn');
                            const pinkTeamBtn = document.getElementById('pinkTeamBtn');
                            let selectedTeam = null;

                            teamButtons.forEach(btn => {
                                btn.addEventListener('click', () => {
                                    const team = btn.dataset.team;

                                    addDebugLog(`üé® –í—ã–±—Ä–∞–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: ${team}`, 'success');

                                    // Update selection state
                                    teamButtons.forEach(b => b.classList.remove('selected'));
                                    btn.classList.add('selected');
                                    selectedTeam = team;

                                    // Send to server
                                    if (ws && ws.readyState === WebSocket.OPEN) {
                                        ws.send(JSON.stringify({
                                            type: 'select_team',
                                            team: team
                                        }));
                                    }

                                    // Update hint
                                    document.getElementById('teamHint').textContent = `–ö–æ–º–∞–Ω–¥–∞ ${team === 'blue' ? '–ì–æ–ª—É–±–∞—è' : '–†–æ–∑–æ–≤–∞—è'} –≤—ã–±—Ä–∞–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å.`;
                                });
                            });

                            // Show team selector for Ship game
                            document.getElementById('teamSelector').style.display = 'block';

                            // Ready button click handler (toggle ready/unready)
                            const readyBtn = document.getElementById('readyBtn');
                            if (readyBtn) {
                                readyBtn.addEventListener('click', () => {
                                    if (!isReady) {
                                        // Player is marking themselves as ready
                                        addDebugLog('‚úÖ –û—Ç–ø—Ä–∞–≤–∫–∞ player_ready', 'success');

                                        if (ws && ws.readyState === WebSocket.OPEN) {
                                            ws.send(JSON.stringify({ type: 'player_ready' }));
                                            isReady = true;
                                            readyBtn.textContent = '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å';
                                            readyBtn.disabled = false; // Keep enabled for unready
                                        } else {
                                            addDebugLog('‚ùå WebSocket –Ω–µ –≥–æ—Ç–æ–≤', 'error');
                                        }
                                    } else {
                                        // Player is cancelling their ready state
                                        addDebugLog('‚èπÔ∏è –û—Ç–ø—Ä–∞–≤–∫–∞ player_unready', 'info');

                                        if (ws && ws.readyState === WebSocket.OPEN) {
                                            ws.send(JSON.stringify({ type: 'player_unready' }));
                                            isReady = false;
                                            readyBtn.textContent = 'üòä –ì–æ—Ç–æ–≤';
                                            readyBtn.disabled = false;
                                        } else {
                                            addDebugLog('‚ùå WebSocket –Ω–µ –≥–æ—Ç–æ–≤', 'error');
                                        }
                                    }
                                });
                            }

                            // Initial role buttons update
                            if (data.gameState) {
                                updateRoleButtons(data.gameState);
                                updateLobbyPlayers(data.gameState);
                            }

                            // Check if game already started (late-join handling)
                            if (data.gameStarted) {
                                addDebugLog('üéÆ –ò–≥—Ä–∞ —É–∂–µ –Ω–∞—á–∞–ª–∞—Å—å, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ª–æ–±–±–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ä–æ–ª–∏', 'info');
                                // Game already running - show lobby for role selection (calibration will follow after role chosen)
                                document.getElementById('lobbyRoomName').textContent = roomId.toUpperCase() + ' ROOM';
                                showScreen('lobby');
                                window.isLateJoiner = true; // Flag to trigger calibration after role selection
                                addDebugLog('üéØ –ü–æ–∫–∞–∑–∞–Ω –ª–æ–±–±–∏ –¥–ª—è late-joiner, –æ–∂–∏–¥–∞–µ–º –≤—ã–±–æ—Ä —Ä–æ–ª–∏', 'success');
                            } else {
                                // Game in lobby - show lobby screen
                                document.getElementById('lobbyRoomName').textContent = roomId.toUpperCase() + ' ROOM';
                                showScreen('lobby');
                                addDebugLog('üëÅÔ∏è –ü–æ–∫–∞–∑–∞–Ω —ç–∫—Ä–∞–Ω –ª–æ–±–±–∏', 'success');
                            }
                        }
                    }

                    if (data.type === 'update' && data.gameState) {
                        // Save current game state for overlay updates
                        window.currentGameState = data.gameState;

                        // Update role buttons and lobby for Ship game
                        if (data.gameState.gameType === 'ship') {
                            updateRoleButtons(data.gameState);
                            updateLobbyPlayers(data.gameState);
                            updateOverlayRoleButtons(); // Update overlay buttons if open

                            // Ensure Ship game buttons are always visible (regardless of active screen)
                            const leavePostBtn = document.getElementById('leavePostBtn');
                            const recalibrateBtn = document.getElementById('recalibrateBtn');
                            if (leavePostBtn) leavePostBtn.style.display = 'block';
                            if (recalibrateBtn) recalibrateBtn.style.display = 'block';
                        } else {
                            // Hide buttons for non-Ship games
                            const leavePostBtn = document.getElementById('leavePostBtn');
                            const recalibrateBtn = document.getElementById('recalibrateBtn');
                            if (leavePostBtn) leavePostBtn.style.display = 'none';
                            if (recalibrateBtn) recalibrateBtn.style.display = 'none';
                        }

                            // Update role display on controller screen
                            const myPlayer = data.gameState.players.find(p => p.id === playerId);
                            if (myPlayer && myPlayer.systemRole) {
                                const roleNames = {
                                    engine: '‚öôÔ∏è –¢—è–≥–∞',
                                    rudder: 'üß≠ –†—É–ª—å',
                                    weapon: 'üî´ –ü—É—à–∫–∞',
                                    weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                                    shield: 'üõ°Ô∏è –©–∏—Ç'
                                };
                                const roleInfo = document.getElementById('roleInfo');
                                const roleDisplay = document.getElementById('roleDisplay');
                                const teamDisplay = document.getElementById('teamDisplay');
                                if (roleInfo && roleDisplay) {
                                    roleInfo.style.display = 'block';
                                    roleDisplay.textContent = roleNames[myPlayer.systemRole];

                                    // Show team for Ship game
                                    if (myPlayer.team && teamDisplay) {
                                        const teamNames = { blue: 'üîµ –ì–æ–ª—É–±–∞—è –∫–æ–º–∞–Ω–¥–∞', pink: 'ü©∑ –†–æ–∑–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞' };
                                        teamDisplay.textContent = teamNames[myPlayer.team] || myPlayer.team;
                                        teamDisplay.style.display = 'inline';
                                        teamDisplay.style.color = myPlayer.team === 'blue' ? '#2196F3' : '#E91E63';
                                    }
                                }

                                // Close overlay only if role changed from what it was when overlay opened
                                const roleChangeOverlay = document.getElementById('roleChangeOverlay');
                                if (roleChangeOverlay && roleChangeOverlay.style.display === 'flex') {
                                    // Check if role actually changed
                                    if (myPlayer.systemRole !== roleBeforeChange) {
                                        roleChangeOverlay.style.display = 'none';
                                        addDebugLog(`‚úÖ –†–æ–ª—å –∏–∑–º–µ–Ω–µ–Ω–∞: ${roleBeforeChange} ‚Üí ${myPlayer.systemRole}`, 'success');

                                        // For late-joiners: if game started and just got assigned a role, start calibration immediately
                                        if (window.isLateJoiner && myPlayer.systemRole) {
                                            addDebugLog('üéÆ Late-joiner –ø–æ–ª—É—á–∏–ª —Ä–æ–ª—å, –∑–∞–ø—É—Å–∫–∞–µ–º –∫–∞–ª–∏–±—Ä–æ–≤–∫—É –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ', 'info');
                                            window.isLateJoiner = false; // Clear flag
                                            (async () => {
                                                try {
                                                    motionController.start();
                                                    await calibration.start();
                                                    addDebugLog('üìê –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –Ω–∞—á–∞—Ç–∞ –¥–ª—è late-joiner', 'info');
                                                } catch (err) {
                                                    addDebugLog('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message, 'error');
                                                    alert('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message);
                                                }
                                            })();
                                        }

                                        roleBeforeChange = null; // Reset
                                    } else {
                                        addDebugLog('‚è≥ –†–æ–ª—å –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å, overlay –æ—Å—Ç–∞—ë—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º', 'info');
                                    }
                                }
                            } else {
                                // No role - hide role display
                                const roleInfo = document.getElementById('roleInfo');
                                if (roleInfo) {
                                    roleInfo.style.display = 'none';
                                }
                            }
                        }

                        // Check if this player died (only for Snake, not Pong)
                        if (data.gameState.gameType === 'snake') {
                            const myPlayer = data.gameState.players.find(p => p.id === playerId);

                            if (myPlayer && !myPlayer.alive) {
                                // Show death screen
                                document.getElementById('deathScore').textContent = myPlayer.score;
                                showScreen('death');

                                // Stop sending motion data while dead
                                motionController.onTiltChange = null;
                            }
                        }
                    }

                    // Handle lobby countdown cancelled
                    if (data.type === 'lobby_countdown_cancelled') {
                        addDebugLog('‚ö†Ô∏è Countdown –æ—Ç–º–µ–Ω—ë–Ω - –∫—Ç–æ-—Ç–æ —Å–Ω—è–ª –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å', 'info');

                        // Stop countdown timer
                        if (window.lobbyCountdownInterval) {
                            clearInterval(window.lobbyCountdownInterval);
                            window.lobbyCountdownInterval = null;
                        }

                        // Reset button text
                        const readyBtn = document.getElementById('readyBtn');
                        if (readyBtn && isReady) {
                            readyBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                            readyBtn.disabled = true;
                        }
                    }

                    // Handle lobby countdown
                    if (data.type === 'lobby_countdown') {
                        addDebugLog('‚è±Ô∏è Countdown –Ω–∞—á–∞–ª—Å—è!', 'success');

                        const readyBtn = document.getElementById('readyBtn');
                        if (!readyBtn) return;

                        const duration = data.duration; // 5000ms
                        const startTime = data.startTime;
                        let remainingSeconds = Math.ceil(duration / 1000); // 5

                        // Update immediately
                        readyBtn.textContent = `–ü–æ–¥–∫–ª—é—á–∞–µ–º –∫ –∏–≥—Ä–µ: ${remainingSeconds}`;
                        readyBtn.disabled = true;

                        // Clear existing interval if any
                        if (window.lobbyCountdownInterval) {
                            clearInterval(window.lobbyCountdownInterval);
                        }

                        // Update every second
                        window.lobbyCountdownInterval = setInterval(() => {
                            const elapsed = Date.now() - startTime;
                            remainingSeconds = Math.max(1, Math.ceil((duration - elapsed) / 1000));

                            if (remainingSeconds > 0) {
                                readyBtn.textContent = `–ü–æ–¥–∫–ª—é—á–∞–µ–º –∫ –∏–≥—Ä–µ: ${remainingSeconds}`;
                            } else {
                                clearInterval(window.lobbyCountdownInterval);
                                window.lobbyCountdownInterval = null;
                            }
                        }, 1000);
                    }

                    // Handle start calibration (after countdown finishes)
                    if (data.type === 'start_calibration') {
                        // Only start calibration if we haven't already calibrated
                        if (!calibration || !calibration.isComplete()) {
                            addDebugLog('üéÆ –ù–∞—á–∏–Ω–∞–µ–º –∫–∞–ª–∏–±—Ä–æ–≤–∫—É –ø–æ—Å–ª–µ countdown', 'info');
                            (async () => {
                                try {
                                    motionController.start();
                                    await calibration.start();
                                    addDebugLog('üìê –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –Ω–∞—á–∞—Ç–∞', 'info');
                                } catch (err) {
                                    addDebugLog('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message, 'error');
                                    alert('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message);
                                }
                            })();
                        } else {
                            addDebugLog('‚úÖ –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º', 'info');
                        }
                    }
                };
            } catch (error) {
                addDebugLog(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ${error.message}`, 'error');
                console.error('Connection error:', error);
                alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                showScreen('room-input');
            }
        }

        setMinBtn.addEventListener('click', () => {
            calibration.setMinPosition();
            showScreen('calibration-max');
        });

        setMaxBtn.addEventListener('click', () => {
            calibration.setMaxPosition();
        });

        disconnectBtn.addEventListener('click', () => {
            if (ws) {
                ws.close();
            }
            if (motionController) {
                motionController.stop();
            }
            showScreen('room-input');
        });

        document.getElementById('respawnBtn').addEventListener('click', () => {
            // Request respawn from server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'respawn',
                    controlScheme: currentControlScheme
                }));

                // Return to controller screen
                showScreen('controller');

                // Show control selector again
                document.getElementById('controlSelector').style.display = 'block';

                // Resume sending motion data
                motionController.onTiltChange = (normalized) => {
                    tiltDisplay.textContent = normalized.toFixed(2);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'input',
                            tilt: normalized
                        }));
                    }
                };
            }
        });

        // Role selection logic for Ship game
        let currentRole = null;
        let isReady = false;

        function updateRoleButtons(gameState) {
            if (gameType !== 'ship') return;

            const roleButtons = document.querySelectorAll('.role-btn');
            const players = gameState.players || [];
            const myPlayer = players.find(p => p.id === playerId);

            // Update team selector state
            if (myPlayer && myPlayer.team) {
                const blueTeamBtn = document.getElementById('blueTeamBtn');
                const pinkTeamBtn = document.getElementById('pinkTeamBtn');

                if (blueTeamBtn && pinkTeamBtn) {
                    const teamButtons = document.querySelectorAll('.team-btn');
                    teamButtons.forEach(b => b.classList.remove('selected'));

                    if (myPlayer.team === 'blue') {
                        blueTeamBtn.classList.add('selected');
                    } else if (myPlayer.team === 'pink') {
                        pinkTeamBtn.classList.add('selected');
                    }

                    document.getElementById('teamHint').textContent = `–ö–æ–º–∞–Ω–¥–∞ ${myPlayer.team === 'blue' ? '–ì–æ–ª—É–±–∞—è' : '–†–æ–∑–æ–≤–∞—è'} –≤—ã–±—Ä–∞–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å.`;
                }
            }

            // Filter players to only same team
            const teamPlayers = myPlayer && myPlayer.team
                ? players.filter(p => p.team === myPlayer.team)
                : [];

            // If no team selected, disable all role buttons
            if (!myPlayer || !myPlayer.team) {
                roleButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    const roleNames = {
                        engine: '‚öôÔ∏è –¢—è–≥–∞',
                        rudder: 'üß≠ –†—É–ª—å',
                        weapon: 'üî´ –ü—É—à–∫–∞',
                        weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                        shield: 'üõ°Ô∏è –©–∏—Ç'
                    };
                    btn.textContent = roleNames[btn.dataset.role];
                    btn.classList.remove('selected', 'exit-role');
                });
                return;
            }

            roleButtons.forEach(btn => {
                const role = btn.dataset.role;
                const occupiedBy = teamPlayers.find(p => p.systemRole === role);

                const roleNames = {
                    engine: '‚öôÔ∏è –¢—è–≥–∞',
                    rudder: 'üß≠ –†—É–ª—å',
                    weapon: 'üî´ –ü—É—à–∫–∞',
                    weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                    shield: 'üõ°Ô∏è –©–∏—Ç'
                };
                btn.textContent = roleNames[role];

                if (occupiedBy && occupiedBy.id !== playerId) {
                    // –†–æ–ª—å –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–∏–º –∏–≥—Ä–æ–∫–æ–º
                    btn.disabled = true;
                    btn.textContent = `${roleNames[role]} ${occupiedBy.name}`;
                    btn.style.opacity = '0.5';
                    btn.classList.remove('selected', 'exit-role');
                } else if (occupiedBy && occupiedBy.id === playerId) {
                    // –≠—Ç–æ –ú–û–Ø —Ä–æ–ª—å - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –≤—ã—Ö–æ–¥–∞
                    btn.disabled = false;
                    btn.style.opacity = '1.0';
                    btn.classList.remove('selected');
                    btn.classList.add('exit-role');
                    btn.textContent = `${roleNames[role]}\nüö™ –í—ã–π—Ç–∏ –∏–∑ —Ä–æ–ª–∏`;
                    currentRole = role;
                } else {
                    // –†–æ–ª—å —Å–≤–æ–±–æ–¥–Ω–∞
                    btn.disabled = false;
                    btn.style.opacity = '1.0';
                    btn.classList.remove('selected', 'exit-role');
                }
            });

            // Update Ready button state (only on room input screen)
            const readyBtn = document.getElementById('readyBtn');
            const readyHint = document.getElementById('readyHint');

            if (readyBtn) {
                if (currentRole) {
                    readyBtn.disabled = false;
                    if (readyHint) readyHint.style.display = 'none';
                } else {
                    readyBtn.disabled = true;
                    if (readyHint) readyHint.style.display = 'block';
                }

                // If player is ready, disable button
                if (myPlayer && myPlayer.ready) {
                    readyBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                    readyBtn.disabled = true;
                    isReady = true;
                }

                // If game started, switch to controller screen
                if (gameState.gameStarted && roomInputScreen.classList.contains('active')) {
                    showScreen('calibration-min');
                }
            }
        }

        // Update lobby players list
        function updateLobbyPlayers(gameState) {
            if (gameType !== 'ship') return;

            const lobbyPlayersList = document.getElementById('lobbyPlayersList');
            if (!lobbyPlayersList) return;

            const players = gameState.players || [];
            const otherPlayers = players.filter(p => p.id !== playerId);

            if (otherPlayers.length === 0) {
                lobbyPlayersList.innerHTML = '<div style="opacity: 0.5;">–û–∂–∏–¥–∞–Ω–∏–µ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤...</div>';
                return;
            }

            const roleNames = {
                engine: '‚öôÔ∏è –¢—è–≥–∞',
                rudder: 'üß≠ –†—É–ª—å',
                weapon: 'üî´ –ü—É—à–∫–∞',
                weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                shield: 'üõ°Ô∏è –©–∏—Ç'
            };

            lobbyPlayersList.innerHTML = otherPlayers.map(player => {
                const roleName = player.systemRole ? roleNames[player.systemRole] : '‚Äî';
                const readyIcon = player.ready ? '‚úì' : '‚úó';
                const readyColor = player.ready ? '#4CAF50' : '#FF5252';

                return `<div style="display: flex; justify-content: space-between; padding: 5px 0;">
                    <span style="color: ${player.color};">${player.name}</span>
                    <span>${roleName}</span>
                    <span style="color: ${readyColor}; font-weight: bold;">${readyIcon}</span>
                </div>`;
            }).join('');
        }

        // Update overlay role buttons (for in-game role change)
        function updateOverlayRoleButtons() {
            if (gameType !== 'ship' || !window.currentGameState) return;

            const roleButtons = document.querySelectorAll('.role-btn-overlay');
            const players = window.currentGameState.players || [];
            const myPlayer = players.find(p => p.id === playerId);

            const roleNames = {
                engine: '‚öôÔ∏è –¢—è–≥–∞',
                rudder: 'üß≠ –†—É–ª—å',
                weapon: 'üî´ –ü—É—à–∫–∞',
                weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                shield: 'üõ°Ô∏è –©–∏—Ç'
            };

            roleButtons.forEach(btn => {
                const role = btn.dataset.role;
                const occupiedBy = players.find(p => p.systemRole === role);

                btn.textContent = roleNames[role];

                if (occupiedBy && occupiedBy.id !== playerId) {
                    // –ó–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–∏–º
                    btn.disabled = true;
                    btn.textContent = `${roleNames[role].split(' ')[0]} ${occupiedBy.name}`;
                    btn.style.opacity = '0.5';
                    btn.classList.remove('selected', 'exit-role');
                } else if (occupiedBy && occupiedBy.id === playerId) {
                    // –ú–æ—è —Ä–æ–ª—å - exit button
                    btn.disabled = false;
                    btn.style.opacity = '1.0';
                    btn.classList.remove('selected');
                    btn.classList.add('exit-role');
                    btn.textContent = `${roleNames[role]}\nüö™ –í—ã–π—Ç–∏ –∏–∑ —Ä–æ–ª–∏`;
                } else {
                    // –°–≤–æ–±–æ–¥–Ω–∞
                    btn.disabled = false;
                    btn.style.opacity = '1.0';
                    btn.classList.remove('selected', 'exit-role');
                }
            });
        }

        // Show role panel if Ship game (moved to page load)
        if (gameType === 'ship') {
            const rolePanel = document.getElementById('roleSelectionPanel');
            if (rolePanel) {
                rolePanel.style.display = 'block';
            }
        }

        // Global initialization of role change and calibration buttons (Ship game)
        if (gameType === 'ship') {
            const leavePostBtn = document.getElementById('leavePostBtn');
            const roleChangeOverlay = document.getElementById('roleChangeOverlay');
            const cancelRoleChange = document.getElementById('cancelRoleChange');
            const recalibrateBtn = document.getElementById('recalibrateBtn');

            // Setup Change Role button handler
            if (leavePostBtn) {
                leavePostBtn.addEventListener('click', () => {
                    addDebugLog('üîÑ –û—Ç–∫—Ä—ã—Ç–∏–µ –º–µ–Ω—é —Å–º–µ–Ω—ã —Ä–æ–ª–∏', 'info');

                    // Save current role before opening overlay
                    if (window.currentGameState) {
                        const myPlayer = window.currentGameState.players.find(p => p.id === playerId);
                        roleBeforeChange = myPlayer ? myPlayer.systemRole : null;
                        addDebugLog(`üíæ –¢–µ–∫—É—â–∞—è —Ä–æ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: ${roleBeforeChange}`, 'info');
                    }

                    roleChangeOverlay.style.display = 'flex';

                    // Update available roles in overlay
                    updateOverlayRoleButtons();
                });
            }

            // Setup Cancel button handler
            if (cancelRoleChange) {
                cancelRoleChange.addEventListener('click', () => {
                    addDebugLog('‚ùå –û—Ç–º–µ–Ω–∞ —Å–º–µ–Ω—ã —Ä–æ–ª–∏', 'info');
                    roleChangeOverlay.style.display = 'none';
                    roleBeforeChange = null; // Reset saved role
                });
            }

            // Setup role button handlers in overlay
            const overlayRoleButtons = document.querySelectorAll('.role-btn-overlay');
            overlayRoleButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const role = btn.dataset.role;

                    const myPlayer = window.currentGameState?.players?.find(p => p.id === playerId);
                    const isMyRole = myPlayer && myPlayer.systemRole === role;

                    if (isMyRole) {
                        // –í—ã—Ö–æ–¥ –∏–∑ —Ä–æ–ª–∏
                        addDebugLog('üö™ –í—ã—Ö–æ–¥ –∏–∑ —Ä–æ–ª–∏ –≤ overlay', 'info');

                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'change_role',
                                role: null
                            }));
                        }
                    } else {
                        // –í—ã–±–æ—Ä —Ä–æ–ª–∏
                        addDebugLog(`üéØ –í—ã–±—Ä–∞–Ω–∞ —Ä–æ–ª—å: ${role}`, 'success');

                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'change_role',
                                role: role
                            }));
                        }
                    }
                });
            });

            // Setup Recalibration button handler
            if (recalibrateBtn) {
                recalibrateBtn.addEventListener('click', () => {
                    addDebugLog('üìê –ù–∞—á–∞–ª–æ –ø–µ—Ä–µ–∫–∞–ª–∏–±—Ä–æ–≤–∫–∏', 'info');

                    // Save current role before recalibration
                    const myPlayer = window.currentGameState?.players?.find(p => p.id === playerId);
                    window.roleBeforeRecalibration = myPlayer?.systemRole || null;

                    // Temporarily release role to autopilot during recalibration
                    if (window.roleBeforeRecalibration && ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'change_role',
                            role: null,
                            recalibrating: true
                        }));
                        addDebugLog('ü§ñ –†–æ–ª—å –ø–µ—Ä–µ–¥–∞–Ω–∞ –∞–≤—Ç–æ–ø–∏–ª–æ—Ç—É –Ω–∞ –≤—Ä–µ–º—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏', 'info');
                    }

                    // Reset calibration
                    calibration.reset();
                    addDebugLog('üîÑ –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞', 'info');

                    // Set flag to prevent sending player_ready again during recalibration
                    window.isRecalibrating = true;

                    // Start calibration process (screen will be shown automatically via onStepChange)
                    // After user completes calibration, onComplete callback will return to controller screen
                    calibration.start();
                    addDebugLog('üìê –ü–æ–∫–∞–∑–∞–Ω—ã —ç–∫—Ä–∞–Ω—ã –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏', 'info');
                });
            }
        }
    </script>
</body>
</html>
