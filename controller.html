<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kinemon - Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            touch-action: none;
        }

        #container {
            width: 100%;
            max-width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        .screen {
            display: none;
            max-width: 500px;
            width: 100%;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }

        p {
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.8;
            line-height: 1.6;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
            display: inline-block;
            min-width: 200px;
        }

        .btn:active {
            background: #45a049;
        }

        .btn-secondary {
            background: #2196F3;
        }

        .btn-secondary:active {
            background: #0b7dda;
        }

        .btn-danger {
            background: #F44336;
        }

        .btn-danger:active {
            background: #da190b;
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 18px;
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid #F44336;
        }

        #controlSchemeSelect {
            cursor: pointer;
        }

        #controlSchemeSelect:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 2px;
        }

        #controlSelector {
            user-select: none;
            -webkit-user-select: none;
        }

        .calibration-indicator {
            font-size: 64px;
            margin: 20px 0;
        }

        .instruction {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .tilt-display {
            font-size: 48px;
            font-weight: bold;
            color: #4CAF50;
            margin: 20px 0;
        }

        #deathScreen {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1a1a 100%);
        }

        #deathScore {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 8px;
        }

        .info {
            font-size: 14px;
            opacity: 0.6;
            margin-top: 20px;
        }

        #qrReader {
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
        }

        #qrReader video {
            width: 100%;
            border-radius: 10px;
        }

        .room-display {
            font-size: 36px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 4px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Room Input Screen -->
        <div id="roomInputScreen" class="screen active">
            <h1>üì± –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä</h1>
            <p id="joinPrompt">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –∏–≥—Ä–µ</p>

            <button class="btn" id="scanQrBtn">üì∑ –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å QR-–∫–æ–¥</button>
            <p style="font-size: 14px; opacity: 0.5;">–∏–ª–∏</p>

            <input type="text" id="roomIdInput" placeholder="–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: ABC123)" maxlength="6" style="text-transform: uppercase;">
            <br>
            <input type="text" id="playerName" placeholder="–í–∞—à–µ –∏–º—è" maxlength="20" value="Player">
            <br>
            <input type="text" id="serverUrl" placeholder="–ê–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞" value="">
            <br>
            <button class="btn btn-secondary" id="manualJoinBtn">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
            <p id="qrHint" style="font-size: 14px; opacity: 0.6; margin-top: 20px; display: none;">
                ‚úÖ –î–∞–Ω–Ω—ã–µ –∏–∑ QR-–∫–æ–¥–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã<br>
                –ù–∞–∂–º–∏—Ç–µ "–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è" –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
            </p>
        </div>

        <!-- QR Scanner Screen removed - now using native camera app -->

        <!-- Calibration Min Screen -->
        <div id="calibrationMinScreen" class="screen">
            <h2>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay1"></span></div>
            <div class="calibration-indicator">‚¨áÔ∏è</div>
            <div class="instruction">
                <p><strong>–®–∞–≥ 1 –∏–∑ 2</strong></p>
                <p>–ù–∞–∫–ª–æ–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ<br>–¥–ª—è –ù–ò–ñ–ù–ï–ô –ø–æ–∑–∏—Ü–∏–∏</p>
            </div>
            <button id="setMinBtn" class="btn">–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <!-- Calibration Max Screen -->
        <div id="calibrationMaxScreen" class="screen">
            <h2>–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay2"></span></div>
            <div class="calibration-indicator">‚¨ÜÔ∏è</div>
            <div class="instruction">
                <p><strong>–®–∞–≥ 2 –∏–∑ 2</strong></p>
                <p>–ù–∞–∫–ª–æ–Ω–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –≤ –ø–æ–ª–æ–∂–µ–Ω–∏–µ<br>–¥–ª—è –í–ï–†–•–ù–ï–ô –ø–æ–∑–∏—Ü–∏–∏</p>
            </div>
            <button id="setMaxBtn" class="btn">–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <!-- Controller Screen -->
        <div id="controllerScreen" class="screen">
            <h2>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h2>
            <div class="room-display">–ö–æ–º–Ω–∞—Ç–∞: <span id="roomDisplay3"></span></div>
            <div id="statusDisplay" class="status connected">–ü–æ–¥–∫–ª—é—á–µ–Ω–æ</div>
            <div class="tilt-display" id="tiltDisplay">0.50</div>
            <div id="vibrationStatus" style="padding: 15px; margin: 15px 0; border-radius: 10px; background: rgba(255,255,255,0.1); font-size: 16px; cursor: pointer; user-select: none;">
                üîî –í–∏–±—Ä–∞—Ü–∏—è: <span id="vibrationStatusText">–ø—Ä–æ–≤–µ—Ä–∫–∞...</span><br>
                <small style="opacity: 0.7; font-size: 12px;">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è —Ç–µ—Å—Ç–∞</small>
            </div>
            <p>–ù–∞–∫–ª–æ–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</p>
            <div class="info">
                <p id="playerInfo">–ò–≥—Ä–æ–∫: <span id="playerNameDisplay"></span></p>
            </div>
            <button class="btn btn-danger" id="disconnectBtn">–û—Ç–∫–ª—é—á–∏—Ç—å—Å—è</button>
        </div>

        <!-- Death Screen -->
        <div id="deathScreen" class="screen">
            <h1 style="font-size: 36px; margin-bottom: 30px;">üíÄ –ü–æ—Ä–∞–∂–µ–Ω–∏–µ</h1>
            <p id="deathMessage" style="font-size: 20px; line-height: 1.6; margin-bottom: 40px;">
                –£ —Ç–µ–±—è –±—ã–ª–æ <span id="deathScore" style="color: #FFD700; font-size: 28px; font-weight: bold;">0</span> –ø–∏—Ü—Ü –Ω–∞ –º–æ–º–µ–Ω—Ç —Å–º–µ—Ä—Ç–∏
            </p>
            <p style="font-size: 18px; opacity: 0.8; margin-bottom: 40px;">
                –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –≤ –±–æ–π, —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –∏—Ö –æ–±—Ä–∞—Ç–Ω–æ!
            </p>
            <button class="btn" id="respawnBtn" style="font-size: 24px; padding: 20px 40px;">
                üîÑ –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –±–æ–π!
            </button>
        </div>

        <!-- Control Scheme Selector (shown during gameplay) -->
        <div id="controlSelector" style="position: fixed; top: 20px; right: 20px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; display: none;">
            <div style="font-size: 14px; margin-bottom: 10px; opacity: 0.8;">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</div>
            <select id="controlSchemeSelect" style="background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px; border-radius: 5px; font-size: 14px; width: 200px;">
                <option value="rotation_smooth">–ü–æ–≤–æ—Ä–æ—Ç (–ø–ª–∞–≤–Ω—ã–π)</option>
                <option value="center_straight">–¶–µ–Ω—Ç—Ä = –ø—Ä—è–º–æ</option>
                <option value="rotation_linear">–ü–æ–≤–æ—Ä–æ—Ç (–±—ã—Å—Ç—Ä—ã–π)</option>
                <option value="fixed_updown">–§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ ‚Üë‚Üì</option>
                <option value="nonlinear_a">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π A</option>
                <option value="nonlinear_b">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π B</option>
            </select>
        </div>
    </div>

    <script src="motionController.js"></script>
    <script src="calibration.js"></script>
    <script>
        let ws = null;
        let motionController = null;
        let calibration = null;
        let playerId = null;
        let roomId = null;
        let gameType = 'snake'; // Default game type
        let wakeLock = null;
        let pingInterval = null;

        // Load saved control preference from localStorage
        let currentControlScheme = localStorage.getItem('playerControlScheme') || 'rotation_smooth';

        const roomInputScreen = document.getElementById('roomInputScreen');
        const calibrationMinScreen = document.getElementById('calibrationMinScreen');
        const calibrationMaxScreen = document.getElementById('calibrationMaxScreen');
        const controllerScreen = document.getElementById('controllerScreen');
        const deathScreen = document.getElementById('deathScreen');

        const playerNameInput = document.getElementById('playerName');
        const roomIdInput = document.getElementById('roomIdInput');
        const serverUrlInput = document.getElementById('serverUrl');
        const scanQrBtn = document.getElementById('scanQrBtn');
        const manualJoinBtn = document.getElementById('manualJoinBtn');
        const setMinBtn = document.getElementById('setMinBtn');
        const setMaxBtn = document.getElementById('setMaxBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusDisplay = document.getElementById('statusDisplay');
        const tiltDisplay = document.getElementById('tiltDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');

        // Debug: Log all URL info
        console.log('=== QR Code Auto-fill Debug ===');
        console.log('Full URL:', window.location.href);
        console.log('Search params:', window.location.search);

        // Check URL parameters FIRST (from QR code scan)
        const urlParams = new URLSearchParams(window.location.search);
        const roomFromUrl = urlParams.get('room');
        const serverFromUrl = urlParams.get('server');
        const gameFromUrl = urlParams.get('game');

        console.log('Parsed URL params:', {
            room: roomFromUrl,
            server: serverFromUrl,
            game: gameFromUrl
        });

        // Set game type if provided
        if (gameFromUrl) {
            gameType = gameFromUrl;
            console.log('Game type from URL:', gameType);
        }

        // Set default server URL based on current location
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '';
        const defaultServer = isLocalhost ? 'ws://localhost:8080' : 'wss://kinemon.onrender.com';

        console.log('Default server:', defaultServer);
        console.log('Server input element exists?', serverUrlInput !== null);
        console.log('Room input element exists?', roomIdInput !== null);

        // Use server from URL if available, otherwise use default
        if (serverFromUrl) {
            serverUrlInput.value = serverFromUrl;
            console.log('‚úÖ Set server from URL:', serverFromUrl);
        } else {
            serverUrlInput.value = defaultServer;
            console.log('‚úÖ Set default server:', defaultServer);
        }

        console.log('Server input current value:', serverUrlInput.value);

        // Wake up Render server on page load (free tier spins down after inactivity)
        if (!isLocalhost) {
            console.log('üîÑ Waking up Render server...');
            fetch('https://kinemon.onrender.com')
                .then(() => console.log('‚úÖ Server wake-up request sent'))
                .catch((err) => console.log('‚ö†Ô∏è Server wake-up failed:', err));
        }

        // Update header with game name
        const gameName = gameType === 'pong' ? 'Pong' : 'Pizza Snake';
        document.querySelector('#roomInputScreen h1').textContent = `üéÆ ${gameName} Controller`;

        // Auto-fill room code if available from QR scan
        if (roomFromUrl) {
            console.log('üéØ Auto-filling from QR code...');
            console.log('Room code:', roomFromUrl);

            // Auto-fill room field
            roomIdInput.value = roomFromUrl;
            console.log('‚úÖ Set room code:', roomIdInput.value);

            // Change button text to indicate auto-filled data
            manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ ' + roomFromUrl;
            manualJoinBtn.style.fontSize = '20px';

            // Show hint
            document.getElementById('qrHint').style.display = 'block';
            document.getElementById('joinPrompt').textContent = `‚úÖ QR-–∫–æ–¥ –æ—Ç—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω! –ò–≥—Ä–∞: ${gameName}`;

            console.log('‚úÖ QR auto-fill complete!');

            // DO NOT auto-connect - iOS requires user interaction for sensor permission
            // User must click the button to grant permission
        } else {
            console.log('‚ÑπÔ∏è No room code in URL - manual entry required');
        }

        console.log('=== End Debug ===');

        function showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if (screenName === 'room-input') {
                roomInputScreen.classList.add('active');
            } else if (screenName === 'calibration-min') {
                calibrationMinScreen.classList.add('active');
            } else if (screenName === 'calibration-max') {
                calibrationMaxScreen.classList.add('active');
            } else if (screenName === 'controller') {
                controllerScreen.classList.add('active');
            } else if (screenName === 'death') {
                deathScreen.classList.add('active');
            }
        }

        function updateRoomDisplay(room) {
            document.getElementById('roomDisplay1').textContent = room;
            document.getElementById('roomDisplay2').textContent = room;
            document.getElementById('roomDisplay3').textContent = room;
        }

        // QR Scanner (now using built-in camera app)
        scanQrBtn.addEventListener('click', () => {
            alert('üì± –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—é:\n\n1. –û—Ç–∫—Ä–æ–π—Ç–µ –∫–∞–º–µ—Ä—É –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ\n2. –ù–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ QR-–∫–æ–¥\n3. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø–æ—è–≤–∏–≤—à–µ–µ—Å—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ\n4. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–∫—Ä–æ–µ—Ç—Å—è —ç—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏!\n\n–ò–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã –≤—Ä—É—á–Ω—É—é –Ω–∏–∂–µ.');
        });

        // Cancel scan button removed - now using native camera

        // Manual join
        manualJoinBtn.addEventListener('click', async () => {
            const room = roomIdInput.value.trim().toUpperCase();
            const server = serverUrlInput.value.trim();

            if (!room) {
                alert('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã');
                return;
            }

            // CRITICAL: Request sensor permission IMMEDIATELY on user click
            // iOS only allows this during direct user interaction
            try {
                manualJoinBtn.textContent = '–ó–∞–ø—Ä–æ—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è...';
                motionController = new MotionController();
                await motionController.requestPermission();
                console.log('‚úÖ Sensor permission granted');

                // Now connect to server
                connectToRoom(room, server);
            } catch (err) {
                manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                alert('‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º –¥–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –¥–≤–∏–∂–µ–Ω–∏—è.\n\n–û—à–∏–±–∫–∞: ' + err.message + '\n\n–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Safari.');
            }
        });

        async function connectToRoom(room, serverUrl) {
            roomId = room;
            updateRoomDisplay(roomId);

            try {
                console.log('Connecting to:', serverUrl, 'Room:', room);

                // Show loading state
                manualJoinBtn.disabled = true;
                manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';

                // Connect to WebSocket server
                ws = new WebSocket(serverUrl);

                // Timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        alert('‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.\n\n–°–µ—Ä–≤–µ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ—Å—ã–ø–∞—Ç—å—Å—è (–ø–æ–¥–æ–∂–¥–∏—Ç–µ 30-60 —Å–µ–∫).\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.');
                        manualJoinBtn.disabled = false;
                        manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                        showScreen('room-input');
                    }
                }, 60000); // 60 seconds timeout

                ws.onopen = async () => {
                    clearTimeout(connectionTimeout);
                    console.log('‚úÖ Connected to server');
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';

                    // Send ping every 30 seconds to keep connection alive
                    pingInterval = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 30000);

                    // Motion controller already initialized with permission granted
                    // Initialize calibration
                    calibration = new Calibration(motionController);

                    // Set calibration complete callback
                    calibration.onComplete = async (min, max) => {
                        console.log('Calibration complete:', min, max);

                        // Send join message with game type and control scheme
                        ws.send(JSON.stringify({
                            type: 'join',
                            roomId: roomId,
                            name: playerNameInput.value.trim() || 'Player',
                            gameType: gameType,
                            controlScheme: currentControlScheme
                        }));

                        playerNameDisplay.textContent = playerNameInput.value.trim() || 'Player';
                        showScreen('controller');

                        // Show control selector and set current value
                        document.getElementById('controlSelector').style.display = 'block';
                        document.getElementById('controlSchemeSelect').value = currentControlScheme;

                        // Request wake lock to prevent phone sleep
                        if ('wakeLock' in navigator) {
                            try {
                                wakeLock = await navigator.wakeLock.request('screen');
                                console.log('Wake Lock acquired');

                                wakeLock.addEventListener('release', () => {
                                    console.log('Wake Lock released');
                                });
                            } catch (err) {
                                console.error('Wake Lock failed:', err);
                            }
                        }

                        // Vibration feedback tracking
                        let previousZone = null; // Track which zone we were in
                        let vibrationEnabled = 'vibrate' in navigator;
                        let vibrationWorking = false;

                        console.log('üîî Vibration setup:', {
                            api_available: vibrationEnabled,
                            user_agent: navigator.userAgent
                        });

                        // Test vibration function
                        const statusText = document.getElementById('vibrationStatusText');
                        const statusBox = document.getElementById('vibrationStatus');

                        function testVibration() {
                            if (vibrationEnabled) {
                                try {
                                    vibrationWorking = navigator.vibrate([200]);
                                    if (vibrationWorking) {
                                        statusText.textContent = '—Ä–∞–±–æ—Ç–∞–µ—Ç ‚úÖ';
                                        statusBox.style.background = 'rgba(76, 175, 80, 0.3)';
                                        statusBox.style.border = '2px solid rgba(76, 175, 80, 0.6)';
                                    } else {
                                        statusText.textContent = '–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è ‚ö†Ô∏è';
                                        statusBox.style.background = 'rgba(255, 152, 0, 0.3)';
                                        statusBox.style.border = '2px solid rgba(255, 152, 0, 0.6)';
                                    }
                                } catch (err) {
                                    statusText.textContent = '–æ—à–∏–±–∫–∞ ‚ùå';
                                    statusBox.style.background = 'rgba(244, 67, 54, 0.3)';
                                    statusBox.style.border = '2px solid rgba(244, 67, 54, 0.6)';
                                    console.error('Vibration test failed:', err);
                                }
                            } else {
                                statusText.textContent = '–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º ‚ùå';
                                statusBox.style.background = 'rgba(244, 67, 54, 0.3)';
                                statusBox.style.border = '2px solid rgba(244, 67, 54, 0.6)';
                            }
                        }

                        // Test immediately
                        testVibration();

                        // Allow manual retest by clicking
                        statusBox.addEventListener('click', () => {
                            testVibration();
                        });

                        // Start sending tilt data
                        motionController.onTiltChange = (normalized) => {
                            tiltDisplay.textContent = normalized.toFixed(2);

                            // Haptic feedback for zone transitions
                            // Zones: 'bottom' (0-0.2), 'center' (0.4-0.6), 'top' (0.8-1.0)
                            let currentZone = null;

                            if (normalized <= 0.2) {
                                currentZone = 'bottom';
                            } else if (normalized >= 0.8) {
                                currentZone = 'top';
                            } else if (normalized >= 0.4 && normalized <= 0.6) {
                                currentZone = 'center';
                            }

                            // Vibrate when entering a new zone
                            if (currentZone !== null && currentZone !== previousZone) {
                                if (vibrationEnabled) {
                                    try {
                                        // Strong vibration pattern: vibrate 100ms, pause 50ms, vibrate 100ms
                                        const vibrated = navigator.vibrate([100, 50, 100]);
                                        console.log('üîî Zone vibration:', currentZone, 'at', normalized.toFixed(2), 'result:', vibrated);
                                    } catch (err) {
                                        console.error('‚ùå Vibration failed:', err);
                                    }
                                } else {
                                    console.log('‚ö†Ô∏è Vibration not available (zone:', currentZone + ')');
                                }
                                previousZone = currentZone;
                            } else if (currentZone === null && previousZone !== null) {
                                // Exited a zone
                                previousZone = null;
                            }

                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'input',
                                    tilt: normalized
                                }));
                            }
                        };
                    };

                    // Start motion tracking and calibration
                    try {
                        motionController.start();
                        await calibration.start();
                        showScreen('calibration-min');
                    } catch (err) {
                        alert('‚ùå –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: ' + err.message);
                        showScreen('room-input');
                    }
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå WebSocket error:', error);
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ Render\n2. URL –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: ' + serverUrl + '\n3. –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
                    showScreen('room-input');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    console.log('Disconnected from server. Code:', event.code, 'Reason:', event.reason);
                    statusDisplay.textContent = '–û—Ç–∫–ª—é—á–µ–Ω–æ';
                    statusDisplay.className = 'status disconnected';
                    manualJoinBtn.disabled = false;
                    manualJoinBtn.textContent = '–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';

                    // Clear ping interval
                    if (pingInterval) {
                        clearInterval(pingInterval);
                        pingInterval = null;
                    }

                    // Release wake lock
                    if (wakeLock !== null) {
                        wakeLock.release().then(() => {
                            wakeLock = null;
                        });
                    }

                    if (event.code !== 1000 && event.code !== 1001) {
                        // Abnormal closure
                        alert('‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ.\n\nCode: ' + event.code);
                    }
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'init') {
                        playerId = data.playerId;
                        console.log('Received player ID:', playerId);
                    }

                    if (data.type === 'update' && data.gameState) {
                        // Check if this player died (only for Snake, not Pong)
                        if (data.gameState.gameType === 'snake') {
                            const myPlayer = data.gameState.players.find(p => p.id === playerId);

                            if (myPlayer && !myPlayer.alive) {
                                // Show death screen
                                document.getElementById('deathScore').textContent = myPlayer.score;
                                showScreen('death');

                                // Hide control selector
                                document.getElementById('controlSelector').style.display = 'none';

                                // Stop sending motion data while dead
                                motionController.onTiltChange = null;
                            }
                        }
                    }
                };
            } catch (error) {
                console.error('Connection error:', error);
                alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                showScreen('room-input');
            }
        }

        setMinBtn.addEventListener('click', () => {
            calibration.setMinPosition();
            showScreen('calibration-max');
        });

        setMaxBtn.addEventListener('click', () => {
            calibration.setMaxPosition();
        });

        disconnectBtn.addEventListener('click', () => {
            if (ws) {
                ws.close();
            }
            if (motionController) {
                motionController.stop();
            }
            showScreen('room-input');
        });

        document.getElementById('respawnBtn').addEventListener('click', () => {
            // Request respawn from server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'respawn',
                    controlScheme: currentControlScheme
                }));

                // Return to controller screen
                showScreen('controller');

                // Show control selector again
                document.getElementById('controlSelector').style.display = 'block';

                // Resume sending motion data
                motionController.onTiltChange = (normalized) => {
                    tiltDisplay.textContent = normalized.toFixed(2);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'input',
                            tilt: normalized
                        }));
                    }
                };
            }
        });

        // Control scheme selector change handler
        document.getElementById('controlSchemeSelect').addEventListener('change', (e) => {
            const newScheme = e.target.value;
            currentControlScheme = newScheme;

            // Save to localStorage
            localStorage.setItem('playerControlScheme', newScheme);

            // Send to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'change_control',
                    controlScheme: newScheme
                }));
            }

            console.log('Control scheme changed to:', newScheme);
        });
    </script>
</body>
</html>
