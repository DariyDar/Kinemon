<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinemon - Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .screen {
            text-align: center;
            padding: 10px;
            display: none;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        h2 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        p {
            font-size: 16px;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
        }

        .btn:hover {
            background: #45a049;
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 400px;
        }

        #gameCanvas {
            border: 2px solid #333;
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        #gameCanvas.active {
            display: block;
        }

        #scoreboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
            pointer-events: none;
        }

        .player-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 18px;
        }

        .player-name {
            font-weight: bold;
            margin-right: 20px;
        }

        .player-status {
            font-size: 12px;
            opacity: 0.6;
        }

        .player-status.dead {
            color: #F44336;
        }

        /* Waiting for players screen styles */
        #waitingScreen {
            max-width: 600px;
        }

        .room-code {
            font-size: 72px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 12px;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
        }

        #qrcode {
            background: white;
            padding: 20px;
            border-radius: 15px;
            display: inline-block;
            margin: 20px 0;
        }

        .instruction {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .room-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
        }

        .room-label {
            font-size: 14px;
            opacity: 0.6;
        }

        .room-id-display {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 4px;
        }

        /* Settings screen styles */
        #settingsScreen {
            max-width: 100%;
            width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
        }

        #settingsForm {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .setting-group {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
        }

        .setting-group label {
            display: block;
            font-size: 14px;
            margin-bottom: 6px;
            color: #4CAF50;
            font-weight: bold;
        }

        .setting-group select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            cursor: pointer;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #66BB6A;
        }

        .setting-info {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }

        /* Live Physics Settings Panel */
        #physicsPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-top: 2px solid #4CAF50;
            padding: 15px 20px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-height: 50vh;
            overflow-y: auto;
        }

        #physicsPanel.open {
            transform: translateY(0);
        }

        #physicsToggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: #4CAF50;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s, background 0.2s;
        }

        #physicsToggle:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        #physicsToggle:active {
            transform: scale(0.95);
        }

        .physics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .physics-control {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
        }

        .physics-control label {
            display: block;
            font-size: 12px;
            color: #4CAF50;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .physics-control .value-display {
            float: right;
            color: #FFD700;
            font-family: monospace;
        }

        .physics-control input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        .physics-control input[type="range"]::-webkit-slider-thumb {
            background: #4CAF50;
        }

        .physics-control input[type="range"]::-moz-range-thumb {
            background: #4CAF50;
        }

        .physics-section {
            margin-bottom: 15px;
        }

        .physics-section h3 {
            font-size: 14px;
            color: #FFD700;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Settings Screen -->
        <div id="settingsScreen" class="screen active">
            <h1 id="gameTitle">üéÆ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã</h1>
            <button class="btn" id="startGameBtn" style="margin-bottom: 20px;">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            <div id="settingsForm">
                <!-- Settings will be populated by JavaScript based on game type -->
            </div>
        </div>

        <!-- Connection Screen -->
        <div id="connectionScreen" class="screen">
            <h1>üñ•Ô∏è –≠–∫—Ä–∞–Ω –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</h1>
            <p>–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...</p>
            <p style="font-size: 14px; opacity: 0.6; margin-top: 20px;">
                ‚è±Ô∏è –ü–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 30-60 —Å–µ–∫<br>
                (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –ø—Ä–æ—Å—ã–ø–∞–µ—Ç—Å—è)
            </p>
        </div>

        <!-- Waiting for Players Screen -->
        <div id="waitingScreen" class="screen">
            <h2>–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤</h2>
            <div class="room-code" id="roomCodeDisplay">------</div>
            <p style="font-size: 24px; margin: 10px 0;">–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</p>

            <div id="qrcode"></div>

            <div class="instruction">
                <p><strong>–ö–∞–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è:</strong></p>
                <p>üì± –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –∫–∞–º–µ—Ä–æ–π —Ç–µ–ª–µ—Ñ–æ–Ω–∞</p>
                <p style="font-size: 14px; opacity: 0.5;">–∏–ª–∏</p>
                <p>‚å®Ô∏è –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã –≤—Ä—É—á–Ω—É—é</p>
            </div>

            <p id="playerCount" style="font-size: 20px; color: #4CAF50;">–ò–≥—Ä–æ–∫–æ–≤: 0</p>
        </div>

        <!-- Lobby Screen (Ship only) -->
        <div id="lobbyScreen" class="screen">
            <h2>üöÄ –õ–æ–±–±–∏</h2>
            <div class="room-code" id="lobbyRoomCode">------</div>
            <p style="font-size: 20px; margin-bottom: 40px;">–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</p>

            <table style="width: 100%; max-width: 600px; margin: 0 auto; border-collapse: collapse; font-size: 20px;">
                <thead>
                    <tr style="border-bottom: 2px solid #4CAF50;">
                        <th style="padding: 15px; text-align: left;">–†–æ–ª—å</th>
                        <th style="padding: 15px; text-align: left;">–ò–≥—Ä–æ–∫</th>
                        <th style="padding: 15px; text-align: center;">–°—Ç–∞—Ç—É—Å</th>
                    </tr>
                </thead>
                <tbody id="lobbyTableBody">
                    <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è -->
                </tbody>
            </table>

            <!-- Countdown Display -->
            <div id="lobbyCountdownDisplay" style="display: none; margin-top: 50px; text-align: center; padding: 30px; background: rgba(76, 175, 80, 0.2); border-radius: 20px; border: 4px solid #4CAF50; max-width: 400px; margin-left: auto; margin-right: auto;">
                <h1 id="lobbyCountdownNumber" style="font-size: 120px; margin: 0; color: #4CAF50; font-weight: bold;">5</h1>
                <p style="margin: 20px 0 0 0; font-size: 24px; font-weight: bold;">–í—Å–µ –≥–æ—Ç–æ–≤—ã! –ò–≥—Ä–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è...</p>
            </div>

            <div id="lobbyQRCode" style="margin-top: 40px;"></div>
        </div>

        <!-- Win Screen -->
        <div id="winScreen" class="screen">
            <h1>üèÜ –ü–æ–±–µ–¥–∞!</h1>
            <p id="winnerName" style="font-size: 32px; margin: 20px 0;"></p>
            <p id="winMessage">–°–æ–±—Ä–∞–ª 50 –ø–∏—Ü—Ü!</p>
            <button class="btn" onclick="window.location.href='index.html'">–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é</button>
        </div>

        <!-- Game Display -->
        <canvas id="gameCanvas" width="600" height="800"></canvas>

        <!-- Persistent QR Code (bottom-left corner) -->
        <div id="persistentQRDisplay" style="
            position: fixed;
            bottom: 15px;
            left: 15px;
            width: 80px;
            height: 80px;
            background: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
        "></div>

        <div id="roomInfo" class="room-info" style="display: none;">
            <div class="room-label">–ö–æ–º–Ω–∞—Ç–∞</div>
            <div class="room-id-display" id="roomIdInfo">------</div>
        </div>

        <div id="scoreboard" style="display: none;">
            <h3>–ò–≥—Ä–æ–∫–∏</h3>
            <div id="playerList"></div>
        </div>
    </div>

    <!-- Physics Settings Toggle Button -->
    <button id="physicsToggle" style="display: none;">‚öôÔ∏è</button>

    <!-- Physics Settings Panel -->
    <div id="physicsPanel">
        <!-- Pump System Parameters -->
        <div id="pumpParams" class="physics-section" style="display: none;">
            <h3>‚ö° Pump System</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–≠–Ω–µ—Ä–≥–∏—è –æ—Ç –Ω–∞–∫–∞—á–∫–∏ <span class="value-display" id="pumpEnergyValue">16.0</span></label>
                    <input type="range" id="pumpEnergy" min="1" max="20" step="0.5" value="16">
                </div>
                <div class="physics-control">
                    <label>–ó–∞—Ç—É—Ö–∞–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ <span class="value-display" id="energyDecayValue">0.05</span></label>
                    <input type="range" id="energyDecay" min="0.01" max="0.2" step="0.01" value="0.05">
                </div>
                <div class="physics-control">
                    <label>–ú–∏–Ω. –¥–µ–ª—å—Ç–∞ pump <span class="value-display" id="pumpMinDeltaValue">0.15</span></label>
                    <input type="range" id="pumpMinDelta" min="0" max="0.5" step="0.01" value="0.15">
                </div>
            </div>
        </div>

        <!-- Gradient System Parameters -->
        <div id="gradientParams" class="physics-section">
            <h3>üìä Gradient System</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–ë–∞–∑–æ–≤–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ <span class="value-display" id="gradientBaseDecayValue">100</span> –µ–¥/—Å–µ–∫</label>
                    <input type="range" id="gradientBaseDecay" min="10" max="200" step="5" value="100">
                </div>
            </div>
        </div>

        <!-- Shared Parameters -->
        <div class="physics-section">
            <h3>üöÄ –î–≤–∏–∂–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ç—è–≥–∏ <span class="value-display" id="thrustMultValue">1.0</span></label>
                    <input type="range" id="thrustMult" min="0.1" max="2.0" step="0.1" value="1.0">
                </div>
                <div class="physics-control">
                    <label>–ò–Ω–µ—Ä—Ü–∏—è (—Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ) <span class="value-display" id="inertiaValue">50</span></label>
                    <input type="range" id="inertia" min="0" max="100" step="1" value="50">
                    <div class="setting-info">0 = –±—ã—Å—Ç—Ä–æ–µ —Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ, 100 = –¥–æ–ª–≥–∏–π –¥—Ä–µ–π—Ñ</div>
                </div>
                <div class="physics-control">
                    <label>–ú–∞–∫—Å. —Å–∫–æ—Ä–æ—Å—Ç—å <span class="value-display" id="maxSpeedValue">3.0</span></label>
                    <input type="range" id="maxSpeed" min="3" max="15" step="0.5" value="3">
                </div>
                <div class="physics-control">
                    <label>–ü–æ—Ä–æ–≥ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ <span class="value-display" id="stopThresholdValue">0.01</span></label>
                    <input type="range" id="stopThreshold" min="0.01" max="0.5" step="0.01" value="0.01">
                </div>
            </div>
        </div>

        <div class="physics-section">
            <h3>üî• –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –æ–≥–Ω—è</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–ü–æ—Ä–æ–≥ –≤–∏–¥–∏–º–æ—Å—Ç–∏ <span class="value-display" id="fireThresholdValue">0.089</span></label>
                    <input type="range" id="fireThreshold" min="0.001" max="0.2" step="0.001" value="0.089">
                </div>
                <div class="physics-control">
                    <label>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –æ–≥–Ω—è <span class="value-display" id="fireIntensityValue">1.4</span></label>
                    <input type="range" id="fireIntensity" min="0.5" max="3.0" step="0.1" value="1.4">
                </div>
                <div class="physics-control">
                    <label>–ú–∞–∫—Å. —á–∞—Å—Ç–∏—Ü <span class="value-display" id="maxParticlesValue">15</span></label>
                    <input type="range" id="maxParticles" min="3" max="20" step="1" value="15">
                </div>
            </div>
        </div>
    </div>

    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <script>
        let ws = null;
        let gameState = null;
        let roomId = null;
        let gameType = null; // 'pong' or 'snake'
        console.log('üñ•Ô∏è Display loaded [v3.13.5 - Lobby System]');

        let gameSettings = {}; // Store game settings

        // Live physics settings (Ship game only)
        let physicsSettings = {
            // Pump system parameters
            pumpEnergy: 16.0,
            energyDecay: 0.05,
            pumpMinDelta: 0.15,

            // Gradient system parameters
            gradientBaseDecay: 100,    // Base decay rate (units/sec) for gradient system

            // Shared parameters
            thrustMult: 1.0,
            inertia: 50,               // Inertia parameter (0-100) controls friction
            maxSpeed: 3.0,
            stopThreshold: 0.01,
            fireThreshold: 0.089,
            fireIntensity: 1.4,
            maxParticles: 15
        };

        // Visual effects system
        const effects = {
            particles: [],
            screenShake: { active: false, offsetX: 0, offsetY: 0, intensity: 0, startTime: 0, duration: 0 },
            flash: { active: false, color: '#FFF', alpha: 0, startTime: 0, duration: 0 },
            scoreAnims: []
        };

        // Detect available viewport dimensions
        function getAvailableCanvasDimensions() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            console.log(`Viewport: ${availableWidth}x${availableHeight}`);
            return {
                width: Math.floor(availableWidth),
                height: Math.floor(availableHeight)
            };
        }

        const settingsScreen = document.getElementById('settingsScreen');
        const connectionScreen = document.getElementById('connectionScreen');
        const waitingScreen = document.getElementById('waitingScreen');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerList = document.getElementById('playerList');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomIdInfo = document.getElementById('roomIdInfo');
        const roomInfo = document.getElementById('roomInfo');
        const scoreboard = document.getElementById('scoreboard');
        const playerCount = document.getElementById('playerCount');
        const startGameBtn = document.getElementById('startGameBtn');
        const gameTitle = document.getElementById('gameTitle');
        const settingsForm = document.getElementById('settingsForm');

        // Parse game type from URL
        const urlParams = new URLSearchParams(window.location.search);
        gameType = urlParams.get('game') || 'snake'; // default to snake if not specified

        // Set default server URL
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '';
        const defaultServerUrl = isLocalhost ? 'ws://localhost:8080' : 'wss://kinemon.onrender.com';

        // Populate settings based on game type
        function populateSettings() {
            if (gameType === 'pong') {
                gameTitle.textContent = 'üèì –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Pong';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="pongBallSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞</label>
                        <select id="pongBallSpeed">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω–∞—è</option>
                            <option value="2">–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3" selected>–ë—ã—Å—Ç—Ä–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞ –º—è—á–∞</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongPaddleSize">–†–∞–∑–º–µ—Ä —Ä–∞–∫–µ—Ç–∫–∏</label>
                        <select id="pongPaddleSize">
                            <option value="1">–ú–∞–ª–µ–Ω—å–∫–∞—è</option>
                            <option value="2" selected>–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3">–ë–æ–ª—å—à–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä —Ä–∞–∫–µ—Ç–æ–∫ –∏–≥—Ä–æ–∫–æ–≤</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongWinScore">–ü–æ–±–µ–¥–Ω—ã–π —Å—á–µ—Ç</label>
                        <select id="pongWinScore">
                            <option value="5">5 –æ—á–∫–æ–≤</option>
                            <option value="11" selected>11 –æ—á–∫–æ–≤</option>
                            <option value="21">21 –æ—á–∫–æ</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.ballSpeed = parseInt(localStorage.getItem('pongBallSpeed')) || 3;
                gameSettings.paddleSize = parseInt(localStorage.getItem('pongPaddleSize')) || 2;
                gameSettings.winScore = parseInt(localStorage.getItem('pongWinScore')) || 11;

                document.getElementById('pongBallSpeed').value = gameSettings.ballSpeed;
                document.getElementById('pongPaddleSize').value = gameSettings.paddleSize;
                document.getElementById('pongWinScore').value = gameSettings.winScore;

            } else if (gameType === 'pushers') {
                gameTitle.textContent = 'üî≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–æ–ª–∫–∞—Ç–µ–ª–∏';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="pushersWinScore">–û—á–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="pushersWinScore">
                            <option value="10">10 –æ—á–∫–æ–≤</option>
                            <option value="15" selected>15 –æ—á–∫–æ–≤</option>
                            <option value="20">20 –æ—á–∫–æ–≤</option>
                            <option value="25">25 –æ—á–∫–æ–≤</option>
                            <option value="30">30 –æ—á–∫–æ–≤</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–º–∞–π–ª–∏–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã –∫–æ–º–∞–Ω–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="pushersSingleSquare">–†–µ–∂–∏–º –∏–≥—Ä—ã</label>
                        <select id="pushersSingleSquare">
                            <option value="false">–û–±—ã—á–Ω—ã–π - –∫–∞–∂–¥—ã–π –∏–≥—Ä–æ–∫ —Å–≤–æ–π –∫–≤–∞–¥—Ä–∞—Ç</option>
                            <option value="true">–û–¥–∏–Ω –∫–≤–∞–¥—Ä–∞—Ç –Ω–∞ –∫–æ–º–∞–Ω–¥—É - –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤</option>
                        </select>
                        <div class="setting-info">–í –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–µ –¥–≤–∞ –∏–≥—Ä–æ–∫–∞ —É–ø—Ä–∞–≤–ª—è—é—Ç –æ–¥–Ω–∏–º –∫–≤–∞–¥—Ä–∞—Ç–æ–º (–æ–¥–∏–Ω –ø–æ X, –¥—Ä—É–≥–æ–π –ø–æ Y)</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.winScore = parseInt(localStorage.getItem('pushersWinScore')) || 15;
                const singleSquare = localStorage.getItem('pushersSingleSquare') || 'false';

                document.getElementById('pushersWinScore').value = gameSettings.winScore;
                document.getElementById('pushersSingleSquare').value = singleSquare;

            } else if (gameType === 'ship') {
                gameTitle.textContent = 'üöÄ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ö–æ—Ä–∞–±–ª—å';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="shipThrustSystem">–°–∏—Å—Ç–µ–º–∞ —Ç—è–≥–∏</label>
                        <select id="shipThrustSystem">
                            <option value="pump">Pump (—Ä—ã–≤–∫–∏)</option>
                            <option value="gradient" selected>Gradient (–≥—Ä–∞–¥—É—Å—ã)</option>
                        </select>
                        <div class="setting-info">–°–ø–æ—Å–æ–± –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏ –¥–≤–∏–≥–∞—Ç–µ–ª—é</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipEngineFormula">–§–æ—Ä–º—É–ª–∞ –¥–≤–∏–≥–∞—Ç–µ–ª—è</label>
                        <select id="shipEngineFormula">
                            <option value="balanced" selected>–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è</option>
                            <option value="speed">–°–∫–æ—Ä–æ—Å—Ç—å (–±—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–∫—Ü–∏—è)</option>
                            <option value="combo">–ö–æ–º–±–æ (–Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ)</option>
                        </select>
                        <div class="setting-info">–ö–∞–∫ –∞–º–ø–ª–∏—Ç—É–¥–∞ –∏ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Ç—è–≥—É</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipWeaponFormula">–§–æ—Ä–º—É–ª–∞ –æ—Ä—É–∂–∏—è</label>
                        <select id="shipWeaponFormula">
                            <option value="standard" selected>–°—Ç–∞–Ω–¥–∞—Ä—Ç</option>
                            <option value="sniper">–°–Ω–∞–π–ø–µ—Ä (–¥–∞–ª—å–Ω–æ–±–æ–π–Ω–æ—Å—Ç—å)</option>
                            <option value="rapid">–ë—ã—Å—Ç—Ä—ã–π (–∫–æ—Ä–æ—Ç–∫–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è)</option>
                        </select>
                        <div class="setting-info">–î–∞–ª—å–Ω–æ—Å—Ç—å –∏ —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª—å</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipCoinsToWin">–ú–æ–Ω–µ—Ç –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="shipCoinsToWin">
                            <option value="5">5 –º–æ–Ω–µ—Ç</option>
                            <option value="10" selected>10 –º–æ–Ω–µ—Ç</option>
                            <option value="15">15 –º–æ–Ω–µ—Ç</option>
                            <option value="20">20 –º–æ–Ω–µ—Ç</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipAsteroidFrequency">–ß–∞—Å—Ç–æ—Ç–∞ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</label>
                        <select id="shipAsteroidFrequency">
                            <option value="low">–ù–∏–∑–∫–∞—è (3 —Å–µ–∫)</option>
                            <option value="medium" selected>–°—Ä–µ–¥–Ω—è—è (2 —Å–µ–∫)</option>
                            <option value="high">–í—ã—Å–æ–∫–∞—è (1.2 —Å–µ–∫)</option>
                        </select>
                        <div class="setting-info">–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ—è–≤–ª–µ–Ω–∏—è –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.thrustSystem = localStorage.getItem('shipThrustSystem') || 'gradient';
                gameSettings.engineFormula = localStorage.getItem('shipEngineFormula') || 'balanced';
                gameSettings.weaponFormula = localStorage.getItem('shipWeaponFormula') || 'standard';
                gameSettings.coinsToWin = parseInt(localStorage.getItem('shipCoinsToWin')) || 10;
                gameSettings.asteroidFrequency = localStorage.getItem('shipAsteroidFrequency') || 'medium';

                document.getElementById('shipThrustSystem').value = gameSettings.thrustSystem;
                document.getElementById('shipEngineFormula').value = gameSettings.engineFormula;
                document.getElementById('shipWeaponFormula').value = gameSettings.weaponFormula;
                document.getElementById('shipCoinsToWin').value = gameSettings.coinsToWin;
                document.getElementById('shipAsteroidFrequency').value = gameSettings.asteroidFrequency;

                // Add event listener for thrust system change to update physics panel visibility
                document.getElementById('shipThrustSystem').addEventListener('change', (e) => {
                    const system = e.target.value;
                    const pumpParams = document.getElementById('pumpParams');
                    const gradientParams = document.getElementById('gradientParams');

                    if (pumpParams && gradientParams) {
                        pumpParams.style.display = system === 'pump' ? 'block' : 'none';
                        gradientParams.style.display = system === 'gradient' ? 'block' : 'none';
                    }

                    // Save to localStorage
                    localStorage.setItem('shipThrustSystem', system);
                    gameSettings.thrustSystem = system;
                });

                // Initialize panel visibility based on current selection
                const pumpParams = document.getElementById('pumpParams');
                const gradientParams = document.getElementById('gradientParams');
                if (pumpParams && gradientParams) {
                    pumpParams.style.display = gameSettings.thrustSystem === 'pump' ? 'block' : 'none';
                    gradientParams.style.display = gameSettings.thrustSystem === 'gradient' ? 'block' : 'none';
                }

            } else { // snake
                gameTitle.textContent = 'üêç –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Pizza Snake';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="snakeTurnSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞</label>
                        <select id="snakeTurnSpeed">
                            <option value="1">1x - –ú–µ–¥–ª–µ–Ω–Ω–æ</option>
                            <option value="2" selected>2x - –ù–æ—Ä–º–∞–ª—å–Ω–æ</option>
                            <option value="3">3x - –ë—ã—Å—Ç—Ä–æ</option>
                            <option value="4">4x - –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ</option>
                            <option value="5">5x - –≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–æ</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞ –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeControlMapping">–†–µ–∂–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</label>
                        <select id="snakeControlMapping">
                            <option value="rotation_smooth" selected>–ü–æ–≤–æ—Ä–æ—Ç (–ø–ª–∞–≤–Ω—ã–π)</option>
                            <option value="center_straight">–¶–µ–Ω—Ç—Ä = –ø—Ä—è–º–æ</option>
                            <option value="rotation_linear">–ü–æ–≤–æ—Ä–æ—Ç (—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π)</option>
                            <option value="nonlinear_a">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π A (—Å—Ç–∞—Ä—ã–π)</option>
                            <option value="nonlinear_b">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π B (—Å—Ç–∞—Ä—ã–π)</option>
                        </select>
                        <div class="setting-info">–ö–∞–∫ –Ω–∞–∫–ª–æ–Ω –≤–ª–∏—è–µ—Ç –Ω–∞ –ø–æ–≤–æ—Ä–æ—Ç –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeMoveSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è</label>
                        <select id="snakeMoveSpeed">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω–∞—è</option>
                            <option value="2">–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3" selected>–ë—ã—Å—Ç—Ä–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeSize">–†–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏</label>
                        <select id="snakeSize">
                            <option value="1" selected>1 - –ú–∏–Ω–∏–º—É–º</option>
                            <option value="2">2 - –ú–∞–ª–µ–Ω—å–∫–∏–π</option>
                            <option value="3">3 - –°—Ä–µ–¥–Ω–∏–π</option>
                            <option value="4">4 - –ë–æ–ª—å—à–æ–π</option>
                            <option value="5">5 - –ú–∞–∫—Å–∏–º—É–º</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏ –∏ –ø–∏—Ü—Ü—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeWinScore">–ü–∏—Ü—Ü –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="snakeWinScore">
                            <option value="20">20 –ø–∏—Ü—Ü</option>
                            <option value="30">30 –ø–∏—Ü—Ü</option>
                            <option value="50" selected>50 –ø–∏—Ü—Ü</option>
                            <option value="75">75 –ø–∏—Ü—Ü</option>
                            <option value="100">100 –ø–∏—Ü—Ü</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏—Ü—Ü –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeInitialPizzas">–ù–∞—á–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—ã–ª–∏</label>
                        <select id="snakeInitialPizzas">
                            <option value="100" selected>100 —á–∞—Å—Ç–∏—Ü</option>
                            <option value="150">150 —á–∞—Å—Ç–∏—Ü</option>
                            <option value="200">200 —á–∞—Å—Ç–∏—Ü</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤—ë–∑–¥–Ω–æ–π –ø—ã–ª–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.turnSpeed = parseInt(localStorage.getItem('snakeTurnSpeed')) || 2;
                gameSettings.controlMapping = localStorage.getItem('snakeControlMapping') || 'rotation_smooth';
                gameSettings.moveSpeed = parseInt(localStorage.getItem('snakeMoveSpeed')) || 3;
                gameSettings.snakeSize = parseInt(localStorage.getItem('snakeSize')) || 1;
                gameSettings.winScore = parseInt(localStorage.getItem('snakeWinScore')) || 50;
                gameSettings.initialPizzas = parseInt(localStorage.getItem('snakeInitialPizzas')) || 100;

                document.getElementById('snakeTurnSpeed').value = gameSettings.turnSpeed;
                document.getElementById('snakeControlMapping').value = gameSettings.controlMapping;
                document.getElementById('snakeMoveSpeed').value = gameSettings.moveSpeed;
                document.getElementById('snakeSize').value = gameSettings.snakeSize;
                document.getElementById('snakeWinScore').value = gameSettings.winScore;
                document.getElementById('snakeInitialPizzas').value = gameSettings.initialPizzas;
            }
        }

        // Initialize settings on page load
        populateSettings();

        // Start game button - save settings and connect to server
        startGameBtn.addEventListener('click', () => {
            // Save settings to localStorage
            if (gameType === 'pong') {
                gameSettings.ballSpeed = parseInt(document.getElementById('pongBallSpeed').value);
                gameSettings.paddleSize = parseInt(document.getElementById('pongPaddleSize').value);
                gameSettings.winScore = parseInt(document.getElementById('pongWinScore').value);
                localStorage.setItem('pongBallSpeed', gameSettings.ballSpeed);
                localStorage.setItem('pongPaddleSize', gameSettings.paddleSize);
                localStorage.setItem('pongWinScore', gameSettings.winScore);
            } else if (gameType === 'pushers') {
                gameSettings.winScore = parseInt(document.getElementById('pushersWinScore').value);
                gameSettings.singleSquare = document.getElementById('pushersSingleSquare').value === 'true';
                localStorage.setItem('pushersWinScore', gameSettings.winScore);
                localStorage.setItem('pushersSingleSquare', gameSettings.singleSquare);
            } else if (gameType === 'ship') {
                gameSettings.thrustSystem = document.getElementById('shipThrustSystem').value;
                gameSettings.engineFormula = document.getElementById('shipEngineFormula').value;
                gameSettings.weaponFormula = document.getElementById('shipWeaponFormula').value;
                gameSettings.coinsToWin = parseInt(document.getElementById('shipCoinsToWin').value);
                gameSettings.asteroidFrequency = document.getElementById('shipAsteroidFrequency').value;
                localStorage.setItem('shipThrustSystem', gameSettings.thrustSystem);
                localStorage.setItem('shipEngineFormula', gameSettings.engineFormula);
                localStorage.setItem('shipWeaponFormula', gameSettings.weaponFormula);
                localStorage.setItem('shipCoinsToWin', gameSettings.coinsToWin);
                localStorage.setItem('shipAsteroidFrequency', gameSettings.asteroidFrequency);
            } else {
                gameSettings.turnSpeed = parseInt(document.getElementById('snakeTurnSpeed').value);
                gameSettings.controlMapping = document.getElementById('snakeControlMapping').value;
                gameSettings.moveSpeed = parseInt(document.getElementById('snakeMoveSpeed').value);
                gameSettings.snakeSize = parseInt(document.getElementById('snakeSize').value);
                gameSettings.winScore = parseInt(document.getElementById('snakeWinScore').value);
                gameSettings.initialPizzas = parseInt(document.getElementById('snakeInitialPizzas').value);
                localStorage.setItem('snakeTurnSpeed', gameSettings.turnSpeed);
                localStorage.setItem('snakeControlMapping', gameSettings.controlMapping);
                localStorage.setItem('snakeMoveSpeed', gameSettings.moveSpeed);
                localStorage.setItem('snakeSize', gameSettings.snakeSize);
                localStorage.setItem('snakeWinScore', gameSettings.winScore);
                localStorage.setItem('snakeInitialPizzas', gameSettings.initialPizzas);
            }

            console.log('Game settings:', gameSettings);

            // Show connection screen and connect
            showScreen('connection');
            connectToServer();
        });

        // Wake up Render server on page load (free tier spins down after inactivity)
        if (!isLocalhost) {
            console.log('üîÑ Waking up Render server...');
            fetch('https://kinemon.onrender.com')
                .then(() => console.log('‚úÖ Server wake-up request sent'))
                .catch((err) => console.log('‚ö†Ô∏è Server wake-up failed:', err));
        }

        function showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if (screenName === 'settings') {
                settingsScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'connection') {
                connectionScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'waiting') {
                waitingScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'lobby') {
                document.getElementById('lobbyScreen').classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'win') {
                document.getElementById('winScreen').classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'game') {
                canvas.classList.add('active');
                // Hide right panel for Pushers and Ship (team-based/cooperative games use canvas scoreboard)
                if (gameState && (gameState.gameType === 'pushers' || gameState.gameType === 'ship')) {
                    roomInfo.style.display = 'none';
                    scoreboard.style.display = 'none';

                    // Show physics toggle button for Ship game
                    if (gameState.gameType === 'ship') {
                        document.getElementById('physicsToggle').style.display = 'block';
                    }
                } else {
                    roomInfo.style.display = 'block';
                    scoreboard.style.display = 'block';
                }
            }
        }

        // Physics panel toggle
        document.getElementById('physicsToggle').addEventListener('click', () => {
            const panel = document.getElementById('physicsPanel');
            panel.classList.toggle('open');
        });

        // Physics settings event listeners
        function setupPhysicsControls() {
            const controls = [
                // Pump system
                { id: 'pumpEnergy', setting: 'pumpEnergy', display: 'pumpEnergyValue', decimals: 1 },
                { id: 'energyDecay', setting: 'energyDecay', display: 'energyDecayValue', decimals: 2 },
                { id: 'pumpMinDelta', setting: 'pumpMinDelta', display: 'pumpMinDeltaValue', decimals: 2 },
                // Gradient system
                { id: 'gradientBaseDecay', setting: 'gradientBaseDecay', display: 'gradientBaseDecayValue', decimals: 0 },
                // Shared
                { id: 'thrustMult', setting: 'thrustMult', display: 'thrustMultValue', decimals: 1 },
                { id: 'inertia', setting: 'inertia', display: 'inertiaValue', decimals: 0 },
                { id: 'maxSpeed', setting: 'maxSpeed', display: 'maxSpeedValue', decimals: 1 },
                { id: 'stopThreshold', setting: 'stopThreshold', display: 'stopThresholdValue', decimals: 2 },
                { id: 'fireThreshold', setting: 'fireThreshold', display: 'fireThresholdValue', decimals: 3 },
                { id: 'fireIntensity', setting: 'fireIntensity', display: 'fireIntensityValue', decimals: 1 },
                { id: 'maxParticles', setting: 'maxParticles', display: 'maxParticlesValue', decimals: 0 }
            ];

            controls.forEach(ctrl => {
                const slider = document.getElementById(ctrl.id);
                const display = document.getElementById(ctrl.display);

                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    physicsSettings[ctrl.setting] = value;
                    display.textContent = value.toFixed(ctrl.decimals);

                    // Send updated settings to server
                    if (ws && ws.readyState === WebSocket.OPEN && roomId) {
                        ws.send(JSON.stringify({
                            type: 'update_physics',
                            roomId: roomId,
                            physics: physicsSettings
                        }));
                    }
                });
            });
        }

        setupPhysicsControls();

        function connectToServer() {
            const serverUrl = defaultServerUrl;

            try {
                console.log('Connecting to:', serverUrl);

                ws = new WebSocket(serverUrl);

                // Timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        alert('‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.\n\n–°–µ—Ä–≤–µ—Ä Render –º–æ–∂–µ—Ç –ø—Ä–æ—Å—ã–ø–∞—Ç—å—Å—è (–ø–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–Ω–∏–º–∞–µ—Ç 30-60 —Å–µ–∫).\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.');
                        showScreen('settings');
                    }
                }, 60000); // 60 seconds timeout

                ws.onopen = () => {
                    clearTimeout(connectionTimeout);
                    console.log('‚úÖ Connected to server');

                    // Get viewport dimensions for Snake and Ship
                    const dimensions = getAvailableCanvasDimensions();
                    if (gameType === 'snake' || gameType === 'ship') {
                        gameSettings.canvasWidth = dimensions.width;
                        gameSettings.canvasHeight = dimensions.height;
                    }

                    // Request room creation with game type and settings
                    ws.send(JSON.stringify({
                        type: 'create_room',
                        gameType: gameType,
                        settings: gameSettings
                    }));
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå WebSocket error:', error);
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ Render: https://kinemon.onrender.com\n2. URL –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: ' + serverUrl + '\n3. –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
                    showScreen('settings');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    console.log('Disconnected from server. Code:', event.code, 'Reason:', event.reason);
                    showScreen('settings');

                    if (event.code !== 1000 && event.code !== 1001) {
                        alert('‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ.\n\nCode: ' + event.code);
                    }
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'room_created') {
                        // Room created, show QR code
                        roomId = data.roomId;
                        console.log('Room created:', roomId);

                        roomCodeDisplay.textContent = roomId;
                        roomIdInfo.textContent = roomId;

                        // Generate QR code with direct link (for camera scanning)
                        document.getElementById('qrcode').innerHTML = '';

                        // Build controller URL with room, server, and game type parameters
                        const baseUrl = window.location.origin + window.location.pathname.replace('display.html', 'controller.html');
                        const qrData = `${baseUrl}?room=${roomId}&game=${gameType}&server=${encodeURIComponent(serverUrl)}`;

                        console.log('QR Code URL:', qrData);

                        new QRCode(document.getElementById('qrcode'), {
                            text: qrData,
                            width: 256,
                            height: 256,
                            colorDark: '#000000',
                            colorLight: '#ffffff',
                            correctLevel: QRCode.CorrectLevel.H
                        });

                        // Generate persistent QR code in bottom-left corner
                        const persistentQR = document.getElementById('persistentQRDisplay');
                        persistentQR.innerHTML = '';
                        new QRCode(persistentQR, {
                            text: qrData,
                            width: 70,
                            height: 70,
                            colorDark: '#000000',
                            colorLight: '#ffffff',
                            correctLevel: QRCode.CorrectLevel.M
                        });
                        persistentQR.style.display = 'block';

                        showScreen('waiting');

                        // Join the room as display
                        ws.send(JSON.stringify({
                            type: 'join_display',
                            roomId: roomId,
                            gameType: gameType,
                            settings: gameSettings
                        }));

                    } else if (data.type === 'init') {
                        gameState = data.gameState;

                        // Update canvas size from server
                        if (gameState.canvas) {
                            canvas.width = gameState.canvas.width;
                            canvas.height = gameState.canvas.height;
                        }

                        updatePlayerCount();

                    } else if (data.type === 'update') {
                        gameState = data.gameState;

                        // Update canvas size if it changed
                        if (gameState.canvas && (canvas.width !== gameState.canvas.width || canvas.height !== gameState.canvas.height)) {
                            canvas.width = gameState.canvas.width;
                            canvas.height = gameState.canvas.height;
                        }

                        updatePlayerCount();

                        // For Ship game: show lobby instead of game until gameStarted
                        if (gameType === 'ship') {
                            if (gameState.players.length > 0 && !gameState.gameStarted) {
                                const lobbyScreen = document.getElementById('lobbyScreen');
                                if (!lobbyScreen.classList.contains('active')) {
                                    showScreen('lobby');
                                    document.getElementById('lobbyRoomCode').textContent = roomId;
                                    // Generate QR code in lobby
                                    document.getElementById('lobbyQRCode').innerHTML = '';
                                    const baseUrl = window.location.origin + window.location.pathname.replace('display.html', 'controller.html');
                                    const qrData = `${baseUrl}?room=${roomId}&game=${gameType}&server=${encodeURIComponent(serverUrl)}`;
                                    new QRCode(document.getElementById('lobbyQRCode'), {
                                        text: qrData,
                                        width: 200,
                                        height: 200,
                                        colorDark: '#000000',
                                        colorLight: '#ffffff',
                                        correctLevel: QRCode.CorrectLevel.H
                                    });
                                }
                                updateLobbyTable(gameState);
                            } else if (gameState.gameStarted) {
                                const lobbyScreen = document.getElementById('lobbyScreen');
                                if (lobbyScreen.classList.contains('active')) {
                                    showScreen('game');
                                }
                            } else if (gameState.players.length === 0) {
                                showScreen('waiting');
                            }
                        } else {
                            // Other games: switch to game screen when first player joins
                            if (gameState.players.length > 0 && !canvas.classList.contains('active')) {
                                showScreen('game');
                            }

                            // Switch back to waiting screen if all players leave
                            if (gameState.players.length === 0 && canvas.classList.contains('active')) {
                                showScreen('waiting');
                            }
                        }
                    } else if (data.type === 'effect') {
                        handleEffect(data.effectType, data.data);
                    } else if (data.type === 'lobby_countdown') {
                        // Show countdown on lobby screen
                        const lobbyCountdownDisplay = document.getElementById('lobbyCountdownDisplay');
                        const lobbyCountdownNumber = document.getElementById('lobbyCountdownNumber');

                        if (lobbyCountdownDisplay && lobbyCountdownNumber) {
                            lobbyCountdownDisplay.style.display = 'block';

                            const startTime = data.startTime;
                            const duration = data.duration;

                            // Update countdown every 100ms for smooth display
                            window.lobbyCountdownInterval = setInterval(() => {
                                const elapsed = Date.now() - startTime;
                                const remaining = Math.max(0, duration - elapsed);
                                const count = Math.ceil(remaining / 1000);

                                lobbyCountdownNumber.textContent = count;

                                if (count === 0) {
                                    clearInterval(window.lobbyCountdownInterval);
                                    window.lobbyCountdownInterval = null;
                                    // Wait for update message with gameStarted=true
                                }
                            }, 100);
                        }
                    } else if (data.type === 'lobby_countdown_cancelled') {
                        // Hide countdown
                        const lobbyCountdownDisplay = document.getElementById('lobbyCountdownDisplay');
                        if (lobbyCountdownDisplay) {
                            lobbyCountdownDisplay.style.display = 'none';
                        }
                        // Stop countdown timer
                        if (window.lobbyCountdownInterval) {
                            clearInterval(window.lobbyCountdownInterval);
                            window.lobbyCountdownInterval = null;
                        }
                    }
                };
            } catch (error) {
                console.error('Connection error:', error);
                alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                showScreen('settings');
            }
        }

        function updatePlayerCount() {
            if (gameState) {
                playerCount.textContent = `–ò–≥—Ä–æ–∫–æ–≤: ${gameState.players.length}`;
            }
        }

        function updateLobbyTable(gameState) {
            const lobbyTableBody = document.getElementById('lobbyTableBody');
            if (!lobbyTableBody || !gameState || !gameState.players) return;

            const roleNames = {
                engine: '‚öôÔ∏è –î–≤–∏–≥–∞—Ç–µ–ª—å',
                rudder: 'üß≠ –†—É–ª—å',
                weapon: 'üî´ –û—Ä—É–∂–∏–µ',
                weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                shield: 'üõ°Ô∏è –©–∏—Ç'
            };

            const roles = ['engine', 'rudder', 'weapon', 'weaponDirection', 'shield'];
            lobbyTableBody.innerHTML = '';

            roles.forEach(role => {
                const player = gameState.players.find(p => p.systemRole === role);

                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';

                // Role cell
                const roleCell = document.createElement('td');
                roleCell.style.padding = '12px';
                roleCell.textContent = roleNames[role];
                row.appendChild(roleCell);

                // Player cell
                const playerCell = document.createElement('td');
                playerCell.style.padding = '12px';
                playerCell.textContent = player ? player.name : '‚Äî';
                playerCell.style.color = player ? player.color : '#666';
                row.appendChild(playerCell);

                // Status cell
                const statusCell = document.createElement('td');
                statusCell.style.padding = '12px';
                statusCell.style.textAlign = 'center';
                statusCell.style.fontSize = '24px';
                statusCell.textContent = player && player.ready ? '‚úì' : '‚úó';
                statusCell.style.color = player && player.ready ? '#4CAF50' : '#FF5252';
                row.appendChild(statusCell);

                lobbyTableBody.appendChild(row);
            });
        }

        // Visual effects handlers
        function handleEffect(effectType, data) {
            switch (effectType) {
                case 'particle':
                    spawnParticles(data.x, data.y, data.color, data.count || 15);
                    break;
                case 'flash':
                    triggerFlash(data.color, data.intensity || 0.3);
                    break;
                case 'shake':
                    triggerShake(data.intensity || 3);
                    break;
                case 'scoreAnim':
                    spawnScoreAnimation(data.x, data.y, data.text, data.color);
                    break;
                case 'sound':
                    console.log('Sound:', data.sound);
                    break;
            }
        }

        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 2 + Math.random() * 3;
                effects.particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3,
                    color: color,
                    alpha: 1.0,
                    lifetime: 0.4 + Math.random() * 0.3,
                    age: 0
                });
            }
        }

        function triggerFlash(color, intensity) {
            effects.flash = {
                active: true,
                color: color,
                alpha: intensity,
                startTime: Date.now(),
                duration: 200
            };
        }

        function triggerShake(intensity) {
            effects.screenShake = {
                active: true,
                intensity: intensity,
                duration: 200,
                startTime: Date.now(),
                offsetX: 0,
                offsetY: 0
            };
        }

        function spawnScoreAnimation(x, y, text, color) {
            effects.scoreAnims.push({
                x: x, y: y,
                text: text,
                color: color,
                alpha: 1.0,
                lifetime: 1.0,
                age: 0
            });
        }

        function updateEffects() {
            const deltaTime = 1/60;

            // Update particles
            for (let i = effects.particles.length - 1; i >= 0; i--) {
                const p = effects.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.age += deltaTime;
                p.alpha = 1.0 - (p.age / p.lifetime);
                if (p.age >= p.lifetime) {
                    effects.particles.splice(i, 1);
                }
            }

            // Update screen shake
            if (effects.screenShake.active) {
                const elapsed = Date.now() - effects.screenShake.startTime;
                if (elapsed >= effects.screenShake.duration) {
                    effects.screenShake.active = false;
                    effects.screenShake.offsetX = 0;
                    effects.screenShake.offsetY = 0;
                } else {
                    const int = effects.screenShake.intensity;
                    effects.screenShake.offsetX = (Math.random() - 0.5) * int * 2;
                    effects.screenShake.offsetY = (Math.random() - 0.5) * int * 2;
                }
            }

            // Update flash
            if (effects.flash.active) {
                const elapsed = Date.now() - effects.flash.startTime;
                const progress = elapsed / effects.flash.duration;
                effects.flash.alpha = effects.flash.alpha * (1 - progress);
                if (elapsed >= effects.flash.duration) {
                    effects.flash.active = false;
                }
            }

            // Update score animations
            for (let i = effects.scoreAnims.length - 1; i >= 0; i--) {
                const anim = effects.scoreAnims[i];
                anim.y -= 1.5;
                anim.age += deltaTime;
                anim.alpha = 1.0 - (anim.age / anim.lifetime);
                if (anim.age >= anim.lifetime) {
                    effects.scoreAnims.splice(i, 1);
                }
            }
        }

        function render() {
            if (!gameState) return;

            // Check for game over
            if (gameState.gameOver && gameState.winner) {
                showWinScreen(gameState.winner, gameState.gameType);
                return;
            }

            if (gameState.gameType === 'pong') {
                renderPong();
            } else if (gameState.gameType === 'pushers') {
                renderPushers();
            } else if (gameState.gameType === 'ship') {
                renderShip();
            } else {
                renderSnake();
            }

            // Update scoreboard
            updateScoreboard();
        }

        function showWinScreen(winner, gameType) {
            // Set winner name and message
            if (gameType === 'pushers') {
                document.getElementById('winnerName').textContent = `–ö–æ–º–∞–Ω–¥–∞ ${winner.team}`;
                document.getElementById('winMessage').textContent = `–ü–æ–±–µ–¥–∏–ª–∞ —Å ${winner.score} —Å–º–∞–π–ª–∏–∫–∞–º–∏!`;
            } else if (gameType === 'ship') {
                document.getElementById('winnerName').textContent = winner.team || '–≠–∫–∏–ø–∞–∂ –∫–æ—Ä–∞–±–ª—è';
                document.getElementById('winMessage').textContent = `–°–æ–±—Ä–∞–ª ${winner.score} –º–æ–Ω–µ—Ç!`;
            } else {
                document.getElementById('winnerName').textContent = winner.name;
                if (gameType === 'pong') {
                    document.getElementById('winMessage').textContent = `–ü–æ–±–µ–¥–∞ —Å–æ —Å—á—ë—Ç–æ–º ${winner.score}!`;
                } else {
                    document.getElementById('winMessage').textContent = `–°–æ–±—Ä–∞–ª ${winner.score} –ø–∏—Ü—Ü!`;
                }
            }

            // Show win screen
            showScreen('win');

            // Hide game elements
            canvas.classList.remove('active');
            roomInfo.style.display = 'none';
            scoreboard.style.display = 'none';
        }

        function renderPong() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.strokeStyle = '#333';
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Show waiting message if game hasn't started
            if (!gameState.gameStarted) {
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞...', canvas.width / 2, canvas.height / 2);

                ctx.font = '20px sans-serif';
                ctx.fillStyle = '#888';
                ctx.fillText(`–ü–æ–¥–∫–ª—é—á–µ–Ω–æ: ${gameState.players.length}/2`, canvas.width / 2, canvas.height / 2 + 50);
            }

            // Draw ball
            if (gameState.ball) {
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw paddles
            const paddleWidth = 10;
            for (const player of gameState.players) {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.paddleX, player.paddleY, paddleWidth, gameState.paddleSize);

                // Draw player name above paddle
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                const nameX = player.side === 'left' ? player.paddleX + paddleWidth / 2 + 30 : player.paddleX + paddleWidth / 2 - 30;
                ctx.fillText(player.name, nameX, 30);
            }

            ctx.restore();

            // Render visual effects
            // Particles
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Flash
            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Score animations
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        function renderSnake() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bottom boundary
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 40);
            ctx.lineTo(canvas.width, canvas.height - 40);
            ctx.stroke();

            // Get dynamic sizes from server (with defaults)
            const pizzaSize = gameState.pizzaSize || 18;
            const segmentSize = gameState.segmentSize || 15;
            const pizzaRadius = pizzaSize / 2;
            const segmentRadius = segmentSize / 2;

            // Draw stardust particles (was pizzas)
            // Neon color palette
            const neonColors = [
                '#FF006E', // Hot pink
                '#8338EC', // Purple
                '#3A86FF', // Blue
                '#FFBE0B', // Yellow
                '#FB5607', // Orange
                '#06FFA5', // Cyan
                '#FF006E', // Magenta
                '#00F5FF', // Bright cyan
                '#CCFF00', // Lime
                '#FF1744'  // Red
            ];

            for (const pizza of gameState.pizzas) {
                // Assign consistent color based on pizza ID
                const colorIndex = (pizza.id ? String(pizza.id).split('').reduce((sum, char) => sum + char.charCodeAt(0), 0) : Math.floor(Math.random() * neonColors.length)) % neonColors.length;
                const color = neonColors[colorIndex];

                // Draw glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;

                // Draw stardust particle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pizza.x, pizza.y, pizzaRadius, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow for next draw
                ctx.shadowBlur = 0;
            }

            // Draw all players
            for (const player of gameState.players) {
                if (!player.alive) continue;

                // Draw body segments
                ctx.fillStyle = player.color;
                for (let i = 1; i < player.segments.length; i++) {
                    const seg = player.segments[i];
                    ctx.beginPath();
                    ctx.arc(seg.x, seg.y, segmentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw head
                const head = player.segments[0];
                ctx.save();
                ctx.translate(head.x, head.y);
                ctx.rotate(player.angle);

                // Head circle (lighter color)
                const headColor = lightenColor(player.color, 20);
                ctx.fillStyle = headColor;
                ctx.beginPath();
                ctx.arc(0, 0, segmentRadius, 0, Math.PI * 2);
                ctx.fill();

                // Eyes (white) - scaled proportionally
                const eyeRadius = segmentRadius * 0.27;
                const eyeOffsetX = segmentRadius * 0.53;
                const eyeOffsetY = segmentRadius * 0.4;
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (black) - scaled proportionally
                const pupilRadius = segmentRadius * 0.11;
                const pupilOffsetX = segmentRadius * 0.6;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(pupilOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.arc(pupilOffsetX, eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Draw player name above head
                ctx.fillStyle = player.color;
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, head.x, head.y - segmentRadius - 5);
            }
        }

        function renderPushers() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Dark background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Field border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Center grid (dashed lines for orientation)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw skulls at corners
            if (gameState.skulls) {
                for (const skull of gameState.skulls) {
                    // Red glow for skull
                    ctx.fillStyle = '#F44336';
                    ctx.font = `${gameState.skullSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', skull.x, skull.y);
                }
            }

            // Draw ghosts
            if (gameState.ghosts) {
                for (const ghost of gameState.ghosts) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = `${gameState.ghostSize || 30}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëª', ghost.x, ghost.y);
                }
            }

            // Draw smiley
            if (gameState.smiley) {
                ctx.fillStyle = '#FFF';
                ctx.font = `${gameState.smileySize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üòä', gameState.smiley.x, gameState.smiley.y);
            }

            // Draw player squares
            if (gameState.players) {
                const renderedSquares = new Set(); // Track rendered team squares in single-square mode

                for (const player of gameState.players) {
                    const halfSize = gameState.squareSize / 2;

                    // In single-square mode, render only one square per team
                    if (gameState.singleSquareMode) {
                        if (renderedSquares.has(player.team)) {
                            continue; // Skip duplicate team
                        }
                        renderedSquares.add(player.team);
                    }

                    // Blinking effect for invulnerable players
                    if (player.invulnerable) {
                        // Blink every 200ms (5 times per second)
                        const blinkInterval = 200;
                        const currentTime = Date.now();
                        const isVisible = Math.floor(currentTime / blinkInterval) % 2 === 0;

                        if (!isVisible) {
                            continue; // Skip rendering this frame
                        }
                    }

                    // Draw square
                    ctx.fillStyle = player.color;
                    ctx.fillRect(
                        player.x - halfSize,
                        player.y - halfSize,
                        gameState.squareSize,
                        gameState.squareSize
                    );

                    // Draw label above square
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    if (gameState.singleSquareMode) {
                        // Show team name in single-square mode
                        ctx.fillText(player.team, player.x, player.y - halfSize - 5);
                    } else {
                        // Show player name in normal mode
                        ctx.fillText(player.name, player.x, player.y - halfSize - 5);
                    }

                    // Draw axis indicator below square (only in normal mode)
                    if (!gameState.singleSquareMode) {
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(player.axis, player.x, player.y + halfSize + 3);
                    }
                }
            }

            // Draw team scoreboard in top left corner (always show for Pushers)
            if (gameState.teamScores) {
                const teams = [
                    { name: 'Blue', color: '#2196F3' },
                    { name: 'Red', color: '#F44336' },
                    { name: 'Yellow', color: '#FFEB3B' },
                    { name: 'Green', color: '#4CAF50' },
                    { name: 'White', color: '#FFFFFF' }
                ];

                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                let y = 15;
                for (const team of teams) {
                    const score = gameState.teamScores[team.name] || 0;

                    // Show team if it has any players
                    const hasPlayers = gameState.players && gameState.players.some(p => p.team === team.name);

                    if (hasPlayers) {
                        ctx.fillStyle = team.color;
                        const winScore = gameState.winScore || 15;
                        ctx.fillText(`${team.name}: ${score}/${winScore}`, 15, y);
                        y += 20;
                    }
                }
            }

            ctx.restore();

            // Render visual effects
            // Particles
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Flash
            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Score animations
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        // Helper function for Ship rendering
        function getSystemPosition(ship, rotation) {
            const angle = rotation * Math.PI / 180;
            return {
                x: ship.x + Math.cos(angle) * ship.radius,
                y: ship.y + Math.sin(angle) * ship.radius
            };
        }

        function renderShip() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Clear canvas - space background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const ship = gameState.ship;

            // Draw coins
            if (gameState.coins) {
                for (const coin of gameState.coins) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', coin.x, coin.y);
                }
            }

            // Draw hearts
            if (gameState.hearts) {
                for (const heart of gameState.hearts) {
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ù§Ô∏è', heart.x, heart.y);
                }
            }

            // Draw bullets - size and color based on power
            if (gameState.bullets) {
                for (const bullet of gameState.bullets) {
                    ctx.save();

                    // Color: red for max power (10), cyan for others
                    const isMaxPower = bullet.powerLevel === 10;
                    const baseColor = isMaxPower ? '#FF0000' : '#00FFFF';
                    const baseColorRGB = isMaxPower ? '255, 0, 0' : '0, 255, 255';

                    // Size from bullet params (4-16px)
                    const outerRadius = bullet.size || 8;
                    const innerRadius = outerRadius * 0.625;
                    const centerRadius = outerRadius * 0.25;

                    // Outer glow
                    ctx.shadowBlur = outerRadius * 2;
                    ctx.shadowColor = baseColor;
                    ctx.fillStyle = `rgba(${baseColorRGB}, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, outerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner bright core
                    ctx.shadowBlur = outerRadius * 1.25;
                    ctx.fillStyle = `rgba(${baseColorRGB}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, innerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Brightest center
                    ctx.shadowBlur = outerRadius * 0.625;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, centerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }

            // Draw asteroids
            if (gameState.asteroids) {
                for (const asteroid of gameState.asteroids) {
                    ctx.save();
                    ctx.translate(asteroid.x, asteroid.y);
                    ctx.rotate(asteroid.rotation);

                    // Flash white when hit
                    const isFlashing = Date.now() < asteroid.flashUntil;
                    ctx.fillStyle = isFlashing ? '#FFFFFF' : '#888888';

                    // Draw irregular polygon
                    const sides = 8;
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (Math.PI * 2 * i) / sides;
                        const variance = 0.7 + (Math.sin(i * 2.5) * 0.15);
                        const r = asteroid.radius * variance;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Health bar
                    if (asteroid.health < asteroid.maxHealth) {
                        const barWidth = asteroid.radius * 2;
                        const barHeight = 4;
                        const healthPct = asteroid.health / asteroid.maxHealth;

                        ctx.fillStyle = '#333';
                        ctx.fillRect(-barWidth/2, -asteroid.radius - 10, barWidth, barHeight);

                        ctx.fillStyle = healthPct > 0.5 ? '#4CAF50' : '#FF5722';
                        ctx.fillRect(-barWidth/2, -asteroid.radius - 10, barWidth * healthPct, barHeight);
                    }

                    ctx.restore();
                }
            }

            // Draw ship
            if (ship) {
                // Ship body - flash red when damaged
                const timeSinceDamage = Date.now() - ship.lastDamageTime;
                const isRedFlash = timeSinceDamage < 200;

                // Invulnerable blink
                if (ship.invulnerable) {
                    const blinkVisible = Math.floor(Date.now() / 150) % 2 === 0;
                    if (!blinkVisible) {
                        ctx.globalAlpha = 0.5;
                    }
                }

                ctx.fillStyle = isRedFlash ? '#FF0000' : '#2196F3';
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0;

                // Ship hull outline
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Energy progress bar (gradient system only)
                if (gameState.thrustSystem === 'gradient' && gameState.systems && gameState.systems.engine) {
                    const energy = gameState.systems.engine.energy || 0;

                    if (energy > 0) {
                        // 5-level color system
                        const colors = [
                            { color: '#00BFFF', start: 0, end: 150 },      // Blue
                            { color: '#00FF00', start: 150, end: 300 },    // Green
                            { color: '#FFFF00', start: 300, end: 450 },    // Yellow
                            { color: '#FFA500', start: 450, end: 600 },    // Orange
                            { color: '#FF0000', start: 600, end: 750 }     // Red
                        ];

                        ctx.lineWidth = 8;
                        const innerRadius = ship.radius - 10; // Inside ship circle

                        colors.forEach((level, index) => {
                            if (energy > level.start) {
                                const levelEnergy = Math.min(energy, level.end) - level.start;
                                const levelProgress = levelEnergy / (level.end - level.start);
                                const segmentArc = (Math.PI * 2 / 5); // Each level takes 1/5 of circle
                                const arcLength = segmentArc * levelProgress;
                                const startAngle = -Math.PI / 2 + (index * segmentArc); // Start at top, go clockwise
                                const endAngle = startAngle + arcLength;

                                ctx.strokeStyle = level.color;
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = level.color;
                                ctx.beginPath();
                                ctx.arc(ship.x, ship.y, innerRadius, startAngle, endAngle);
                                ctx.stroke();
                            }
                        });

                        ctx.shadowBlur = 0; // Reset shadow
                    }
                }

                // Draw shield arc - semi-transparent with shimmer
                if (gameState.systems && gameState.systems.shield && gameState.systems.shield.active) {
                    ctx.save();
                    const shieldRot = gameState.systems.shield.rotation * Math.PI / 180;
                    const arcSize = gameState.systems.shield.arcSize * Math.PI / 180;

                    // Shimmer effect (pulsing opacity)
                    const shimmer = 0.4 + Math.sin(Date.now() / 200) * 0.2;

                    // Outer glow
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shimmer * 0.5})`;
                    ctx.lineWidth = 12;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00FFFF';
                    ctx.beginPath();
                    ctx.arc(
                        ship.x, ship.y,
                        ship.radius + 8,
                        shieldRot - arcSize/2,
                        shieldRot + arcSize/2
                    );
                    ctx.stroke();

                    // Inner solid line
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shimmer})`;
                    ctx.lineWidth = 6;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(
                        ship.x, ship.y,
                        ship.radius + 8,
                        shieldRot - arcSize/2,
                        shieldRot + arcSize/2
                    );
                    ctx.stroke();

                    // Energy particles along shield
                    ctx.shadowBlur = 5;
                    for (let i = 0; i < 5; i++) {
                        const particleAngle = shieldRot - arcSize/2 + (arcSize * i / 4);
                        const px = ship.x + Math.cos(particleAngle) * (ship.radius + 8);
                        const py = ship.y + Math.sin(particleAngle) * (ship.radius + 8);
                        ctx.fillStyle = `rgba(0, 255, 255, ${shimmer * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }

                // Draw engine - turbine with fire particles
                if (gameState.systems) {
                    const enginePos = getSystemPosition(ship, gameState.systems.rudder.rotation);
                    const engineAngle = gameState.systems.rudder.rotation * Math.PI / 180;

                    // Turbine base (metallic gray rectangle)
                    ctx.save();
                    ctx.translate(enginePos.x, enginePos.y);
                    ctx.rotate(engineAngle);
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-10, -6, 20, 12);
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-10, -4, 20, 8);
                    ctx.restore();

                    // Fire/thrust particles (based on ship velocity, not tilt)
                    const shipSpeed = Math.hypot(ship.vx || 0, ship.vy || 0);
                    const maxSpeed = physicsSettings.maxSpeed; // Use settings value
                    const speedRatio = Math.min(shipSpeed / maxSpeed, 1); // 0-1

                    // Only show fire when ship is actually moving (uses settings threshold)
                    if (speedRatio > physicsSettings.fireThreshold) {
                        // Fire direction is opposite to ship movement (reactive thrust)
                        const movementAngle = Math.atan2(ship.vy || 0, ship.vx || 0);
                        const thrustAngle = movementAngle + Math.PI; // Opposite direction

                        const thrustIntensity = speedRatio * physicsSettings.fireIntensity; // Apply intensity multiplier
                        const particleCount = Math.max(2, Math.floor(physicsSettings.maxParticles * speedRatio));

                        // Gradient system: +5% flame size per energy level
                        let flameSizeBonus = 1.0;
                        if (gameState.thrustSystem === 'gradient' && gameState.energyLevel) {
                            flameSizeBonus = 1.0 + (gameState.energyLevel * 0.05); // +5% per level (max +25% at level 5)
                        }

                        for (let i = 0; i < particleCount; i++) {
                            const dist = 15 + i * 12 + Math.random() * 5;
                            const spread = (Math.random() - 0.5) * 0.3;
                            const x = enginePos.x + Math.cos(thrustAngle + spread) * dist;
                            const y = enginePos.y + Math.sin(thrustAngle + spread) * dist;
                            const alpha = (1 - i / particleCount) * 0.9 * Math.min(thrustIntensity, 1);
                            const hue = 30 + Math.random() * 30; // Orange to yellow
                            ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                            ctx.beginPath();
                            const baseRadius = Math.max(1, 8 - i * 1.5); // Prevent negative radius
                            const radius = baseRadius * flameSizeBonus; // Apply gradient bonus
                            ctx.arc(x, y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Draw weapon charging cone (only while charging)
                    if (gameState.weaponCharging && gameState.weaponEnergy > 0) {
                        const weaponPos = getSystemPosition(ship, gameState.systems.weaponDirection.rotation);
                        const weaponAngle = gameState.systems.weaponDirection.rotation * Math.PI / 180;

                        // Calculate cone parameters
                        const energy = gameState.weaponEnergy;
                        const powerLevel = Math.max(1, Math.min(10, Math.ceil(energy)));

                        // Size of future bullet
                        const futureSize = 4 + (powerLevel - 1) * (12 / 9);

                        // Cone dimensions
                        const coneLength = 80;
                        const coneStartWidth = futureSize * 0.5;
                        const coneEndWidth = futureSize * 1.5;

                        // Color based on energy level
                        let coneColor;
                        if (energy < 2) coneColor = '#00FFFF';      // –ì–æ–ª—É–±–æ–π
                        else if (energy < 4) coneColor = '#00FF00'; // –ó–µ–ª—ë–Ω—ã–π
                        else if (energy < 6) coneColor = '#FFFF00'; // –ñ—ë–ª—Ç—ã–π
                        else if (energy < 8) coneColor = '#FFA500'; // –û—Ä–∞–Ω–∂–µ–≤—ã–π
                        else coneColor = '#FF0000';                 // –ö—Ä–∞—Å–Ω—ã–π

                        ctx.save();
                        ctx.translate(weaponPos.x, weaponPos.y);
                        ctx.rotate(weaponAngle);

                        // Gradient cone
                        const gradient = ctx.createLinearGradient(0, 0, coneLength, 0);
                        gradient.addColorStop(0, coneColor + '80');
                        gradient.addColorStop(1, coneColor + '20');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(0, -coneStartWidth);
                        ctx.lineTo(coneLength, -coneEndWidth);
                        ctx.lineTo(coneLength, coneEndWidth);
                        ctx.lineTo(0, coneStartWidth);
                        ctx.closePath();
                        ctx.fill();

                        // Outline
                        ctx.strokeStyle = coneColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        ctx.restore();
                    }

                    // Draw weapon - old pirate cannon
                    const weaponPos = getSystemPosition(ship, gameState.systems.weaponDirection.rotation);
                    const weaponAngle = gameState.systems.weaponDirection.rotation * Math.PI / 180;

                    ctx.save();
                    ctx.translate(weaponPos.x, weaponPos.y);
                    ctx.rotate(weaponAngle);

                    // Cannon base (brown wood)
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-8, -8, 16, 16);

                    // Cannon barrel (dark gray metal)
                    ctx.fillStyle = '#333';
                    ctx.fillRect(5, -4, 15, 8);
                    ctx.fillStyle = '#222';
                    ctx.fillRect(5, -3, 15, 6);

                    // Cannon mouth (black circle)
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(20, 0, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Metal rim (gray highlight)
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.restore();
                }
            }

            ctx.restore();

            // Draw HUD (top)
            if (ship) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFF';
                ctx.fillText(`‚ù§Ô∏è ${ship.hearts}/10`, 20, 30);
                ctx.fillText(`üí∞ ${ship.coins}/${gameState.coinsToWin || 10}`, 20, 60);
            }

            // Player list (right side)
            if (gameState.players) {
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFF';
                let y = 30;
                const roleNames = {
                    engine: '–î–≤–∏–≥–∞—Ç–µ–ª—å',
                    rudder: '–†—É–ª—å',
                    weapon: '–û—Ä—É–∂–∏–µ',
                    weaponDirection: '–ü—Ä–∏—Ü–µ–ª',
                    shield: '–©–∏—Ç'
                };

                for (const player of gameState.players) {
                    if (!player.systemRole) continue;
                    ctx.fillStyle = player.color;
                    ctx.fillText(`${player.name} - ${roleNames[player.systemRole]}`, canvas.width - 20, y);
                    y += 25;
                }
            }

            // Render visual effects
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        function updateScoreboard() {
            if (!gameState) return;

            playerList.innerHTML = '';

            // Sort players by score
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);

            for (const player of sortedPlayers) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-score';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.style.color = player.color;
                nameSpan.textContent = player.name;

                const scoreSpan = document.createElement('span');
                scoreSpan.textContent = player.score;

                const statusSpan = document.createElement('div');
                statusSpan.className = 'player-status' + (player.alive ? '' : ' dead');
                statusSpan.textContent = player.alive ? '' : '–ú–µ—Ä—Ç–≤';

                playerDiv.appendChild(nameSpan);
                playerDiv.appendChild(scoreSpan);
                if (!player.alive) {
                    playerDiv.appendChild(statusSpan);
                }

                playerList.appendChild(playerDiv);
            }
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, ((num >> 16) & 0xFF) + percent);
            const g = Math.min(255, ((num >> 8) & 0xFF) + percent);
            const b = Math.min(255, (num & 0xFF) + percent);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Animation loop
        function animate() {
            if (gameState && canvas.classList.contains('active')) {
                updateEffects();
                render();
            }
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
