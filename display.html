<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinemon - Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .screen {
            text-align: center;
            padding: 10px;
            display: none;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        h2 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        p {
            font-size: 16px;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
        }

        .btn:hover {
            background: #45a049;
        }

        .game-select-btn {
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .game-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 400px;
        }

        #gameCanvas {
            border: 2px solid #333;
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        #gameCanvas.active {
            display: block;
        }

        #scoreboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
            pointer-events: none;
        }

        .player-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 18px;
        }

        .player-name {
            font-weight: bold;
            margin-right: 20px;
        }

        .player-status {
            font-size: 12px;
            opacity: 0.6;
        }

        .player-status.dead {
            color: #F44336;
        }

        /* Waiting for players screen styles */
        #waitingScreen {
            max-width: 600px;
        }

        .room-code {
            font-size: 72px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 12px;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
        }

        #qrcode {
            background: white;
            padding: 20px;
            border-radius: 15px;
            display: inline-block;
            margin: 20px 0;
        }

        .instruction {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .room-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
        }

        .room-label {
            font-size: 14px;
            opacity: 0.6;
        }

        .room-id-display {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 4px;
        }

        /* Settings screen styles */
        #settingsScreen {
            max-width: 100%;
            width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
        }

        #settingsForm {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .setting-group {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
        }

        .setting-group label {
            display: block;
            font-size: 14px;
            margin-bottom: 6px;
            color: #4CAF50;
            font-weight: bold;
        }

        .setting-group select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            cursor: pointer;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #66BB6A;
        }

        .setting-info {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }

        /* Live Physics Settings Panel */
        #physicsPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-top: 2px solid #4CAF50;
            padding: 15px 20px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-height: 50vh;
            overflow-y: auto;
        }

        #physicsPanel.open {
            transform: translateY(0);
        }

        #physicsToggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: #4CAF50;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s, background 0.2s;
        }

        #physicsToggle:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        #physicsToggle:active {
            transform: scale(0.95);
        }

        .physics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .physics-control {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
        }

        .physics-control label {
            display: block;
            font-size: 12px;
            color: #4CAF50;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .physics-control .value-display {
            float: right;
            color: #FFD700;
            font-family: monospace;
        }

        .physics-control input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        .physics-control input[type="range"]::-webkit-slider-thumb {
            background: #4CAF50;
        }

        .physics-control input[type="range"]::-moz-range-thumb {
            background: #4CAF50;
        }

        .physics-section {
            margin-bottom: 15px;
        }

        .physics-section h3 {
            font-size: 14px;
            color: #FFD700;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            padding-bottom: 5px;
        }

        /* Adaptive scaling for medium+ screens (tablets landscape, projectors) */
        @media (min-width: 1024px) {
            /* Scale down UI elements */
            h1 {
                font-size: 22px;
                margin-bottom: 8px;
            }

            h2 {
                font-size: 20px;
                margin-bottom: 10px;
            }

            p {
                font-size: 15px;
                margin-bottom: 18px;
            }

            .btn {
                padding: 11px 26px;
                font-size: 16px;
                margin: 8px;
            }

            input {
                padding: 13px;
                font-size: 16px;
                margin-bottom: 18px;
                max-width: 350px;
            }

            #persistentQRDisplay {
                width: 95px !important;
                height: 95px !important;
                bottom: 10px !important;
                left: 10px !important;
                padding: 3px !important;
            }

            #waitingQRCode {
                max-width: 380px;
                max-height: 380px;
                margin: 20px auto !important;
            }

            #waitingQRCode img {
                max-width: 100% !important;
                max-height: 100% !important;
                width: auto !important;
                height: auto !important;
                display: block !important;
                margin: 0 auto !important;
            }

            #waitingQRCode canvas {
                display: none !important; /* Canvas is only used for rendering, should be hidden */
            }
        }

        /* Adaptive scaling for large screens (Full HD projectors) */
        @media (min-width: 1920px), (min-height: 1080px) {
            /* Scale down UI elements more aggressively */
            h1 {
                font-size: 16px;
                margin-bottom: 5px;
            }

            h2 {
                font-size: 15px;
                margin-bottom: 6px;
            }

            p {
                font-size: 12px;
                margin-bottom: 10px;
            }

            .btn {
                padding: 8px 20px;
                font-size: 13px;
                margin: 5px;
            }

            input {
                padding: 9px;
                font-size: 13px;
                margin-bottom: 10px;
                max-width: 250px;
            }

            #scoreboard {
                top: 10px;
                right: 10px;
                padding: 10px;
                min-width: 120px;
            }

            .player-score {
                font-size: 12px;
                margin: 5px 0;
            }

            #persistentQRDisplay {
                width: 80px !important;
                height: 80px !important;
                bottom: 8px !important;
                left: 8px !important;
                padding: 3px !important;
            }

            #teamRosters {
                top: 10px;
                padding: 0 10px;
            }

            #teamRosters > div {
                padding: 4px !important;
                min-width: 120px !important;
                font-size: 10px !important;
            }

            #teamRosters h3 {
                font-size: 12px !important;
                margin-bottom: 4px !important;
            }

            #roomInfo {
                font-size: 12px;
            }

            #roomCodeDisplay {
                font-size: 16px;
            }

            #waitingQRCode {
                max-width: 300px;
                max-height: 300px;
                margin: 15px auto !important;
            }
        }

        /* Extra large screens (4K projectors, 2560x1440+) */
        @media (min-width: 2560px), (min-height: 1440px) {
            h1 {
                font-size: 14px;
                margin-bottom: 4px;
            }

            h2 {
                font-size: 13px;
                margin-bottom: 5px;
            }

            p {
                font-size: 11px;
                margin-bottom: 8px;
            }

            .btn {
                padding: 7px 18px;
                font-size: 11px;
                margin: 4px;
            }

            input {
                padding: 8px;
                font-size: 11px;
                max-width: 220px;
            }

            #scoreboard {
                padding: 8px;
                min-width: 100px;
            }

            .player-score {
                font-size: 10px;
            }

            #persistentQRDisplay {
                width: 65px !important;
                height: 65px !important;
                bottom: 6px !important;
                left: 6px !important;
                padding: 2px !important;
            }

            #teamRosters > div {
                padding: 4px !important;
                min-width: 100px !important;
                font-size: 9px !important;
            }

            #teamRosters h3 {
                font-size: 10px !important;
                margin-bottom: 3px !important;
            }

            #waitingQRCode {
                max-width: 250px;
                max-height: 250px;
                margin: 10px auto !important;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Settings Screen -->
        <div id="settingsScreen" class="screen active">
            <h1 id="gameTitle">üéÆ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã</h1>
            <button class="btn" id="startGameBtn" style="margin-bottom: 20px;">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            <div id="settingsForm">
                <!-- Settings will be populated by JavaScript based on game type -->
            </div>
            <div style="position: fixed; bottom: 10px; right: 10px; font-size: 12px; opacity: 0.5;">v3.22.0</div>
        </div>

        <!-- Connection Screen -->
        <div id="connectionScreen" class="screen">
            <h1>üñ•Ô∏è –≠–∫—Ä–∞–Ω –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</h1>
            <div id="connectionModeSelect" style="display: none; margin: 30px auto; max-width: 500px;">
                <h2 style="font-size: 24px; margin-bottom: 20px;">–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º</h2>
                <button class="btn" id="createRoomBtn" style="width: 100%; margin-bottom: 15px;">
                    üéÆ –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É
                </button>
                <button class="btn btn-secondary" id="joinRoomBtn" style="width: 100%; background: #607D8B;">
                    üì∫ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∏–≥—Ä–µ
                </button>
            </div>
            <div id="joinRoomInput" style="display: none; margin: 30px auto; max-width: 400px;">
                <h2 style="font-size: 24px; margin-bottom: 20px;">–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</h2>
                <input type="text" id="roomCodeInput" placeholder="–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: ABC123)"
                    style="width: 100%; padding: 15px; font-size: 18px; text-align: center; border: 2px solid #4CAF50; border-radius: 8px; margin-bottom: 15px; text-transform: uppercase;">
                <button class="btn" id="confirmJoinBtn" style="width: 100%; margin-bottom: 10px;">
                    ‚úÖ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è
                </button>
                <button class="btn btn-secondary" id="backToModeBtn" style="width: 100%; background: #607D8B;">
                    ‚Üê –ù–∞–∑–∞–¥
                </button>
            </div>
            <p id="connectionStatus">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...</p>
            <p style="font-size: 14px; opacity: 0.6; margin-top: 20px;">
                ‚è±Ô∏è –ü–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 30-60 —Å–µ–∫<br>
                (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –ø—Ä–æ—Å—ã–ø–∞–µ—Ç—Å—è)
            </p>
        </div>

        <!-- Waiting for Players Screen -->
        <div id="waitingScreen" class="screen">
            <h2>–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤</h2>
            <div class="room-code" id="roomCodeDisplay">------</div>
            <p style="font-size: 24px; margin: 10px 0;">–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</p>

            <div class="instruction">
                <p><strong>–ö–∞–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è:</strong></p>
                <p>üì± –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –∫–∞–º–µ—Ä–æ–π —Ç–µ–ª–µ—Ñ–æ–Ω–∞</p>
            </div>

            <div id="waitingQRCode" style="margin: 30px auto;"></div>

            <p id="playerCount" style="font-size: 20px; color: #4CAF50;">–ò–≥—Ä–æ–∫–æ–≤: 0</p>
        </div>

        <!-- Lobby Screen (Ship only) -->
        <div id="lobbyScreen" class="screen">
            <h2>üöÄ –õ–æ–±–±–∏</h2>
            <div class="room-code" id="lobbyRoomCode">------</div>
            <p style="font-size: 20px; margin-bottom: 40px;">–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</p>

            <!-- Single table for legacy games -->
            <table id="singleTeamTable" style="width: 100%; max-width: 600px; margin: 0 auto; border-collapse: collapse; font-size: 20px; display: none;">
                <thead>
                    <tr style="border-bottom: 2px solid #4CAF50;">
                        <th style="padding: 15px; text-align: left;">–†–æ–ª—å</th>
                        <th style="padding: 15px; text-align: left;">–ò–≥—Ä–æ–∫</th>
                        <th style="padding: 15px; text-align: center;">–°—Ç–∞—Ç—É—Å</th>
                    </tr>
                </thead>
                <tbody id="lobbyTableBody">
                    <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è -->
                </tbody>
            </table>

            <!-- Dual team tables for Ship game -->
            <div id="dualTeamTables" style="display: none; width: 100%; max-width: 1200px; margin: 0 auto;">
                <div style="display: flex; gap: 40px; justify-content: center; align-items: flex-start;">
                    <!-- Blue Team Table -->
                    <div style="flex: 1; max-width: 500px;">
                        <h2 style="text-align: center; color: #2196F3; margin-bottom: 20px;">üîµ –ì–æ–ª—É–±–∞—è –∫–æ–º–∞–Ω–¥–∞</h2>
                        <table style="width: 100%; border-collapse: collapse; font-size: 18px; border: 3px solid #2196F3; border-radius: 10px; overflow: hidden;">
                            <thead>
                                <tr style="background: rgba(33, 150, 243, 0.2); border-bottom: 2px solid #2196F3;">
                                    <th style="padding: 12px; text-align: left;">–†–æ–ª—å</th>
                                    <th style="padding: 12px; text-align: left;">–ò–≥—Ä–æ–∫</th>
                                    <th style="padding: 12px; text-align: center;">–ì–æ—Ç–æ–≤</th>
                                </tr>
                            </thead>
                            <tbody id="blueTeamTableBody">
                                <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è -->
                            </tbody>
                        </table>
                    </div>

                    <!-- Pink Team Table -->
                    <div style="flex: 1; max-width: 500px;">
                        <h2 style="text-align: center; color: #E91E63; margin-bottom: 20px;">ü©∑ –†–æ–∑–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞</h2>
                        <table style="width: 100%; border-collapse: collapse; font-size: 18px; border: 3px solid #E91E63; border-radius: 10px; overflow: hidden;">
                            <thead>
                                <tr style="background: rgba(233, 30, 99, 0.2); border-bottom: 2px solid #E91E63;">
                                    <th style="padding: 12px; text-align: left;">–†–æ–ª—å</th>
                                    <th style="padding: 12px; text-align: left;">–ò–≥—Ä–æ–∫</th>
                                    <th style="padding: 12px; text-align: center;">–ì–æ—Ç–æ–≤</th>
                                </tr>
                            </thead>
                            <tbody id="pinkTeamTableBody">
                                <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Countdown Display -->
            <div id="lobbyCountdownDisplay" style="display: none; margin-top: 50px; text-align: center; padding: 30px; background: rgba(76, 175, 80, 0.2); border-radius: 20px; border: 4px solid #4CAF50; max-width: 400px; margin-left: auto; margin-right: auto;">
                <h1 id="lobbyCountdownNumber" style="font-size: 120px; margin: 0; color: #4CAF50; font-weight: bold;">5</h1>
                <p style="margin: 20px 0 0 0; font-size: 24px; font-weight: bold;">–í—Å–µ –≥–æ—Ç–æ–≤—ã! –ò–≥—Ä–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è...</p>
            </div>
        </div>

        <!-- Win Screen -->
        <div id="winScreen" class="screen">
            <h1>üèÜ –ü–æ–±–µ–¥–∞!</h1>
            <p id="winnerName" style="font-size: 32px; margin: 20px 0;"></p>
            <p id="winMessage">–°–æ–±—Ä–∞–ª 50 –ø–∏—Ü—Ü!</p>

            <!-- Main action buttons -->
            <div id="mainActions" style="margin: 30px 0; display: flex; gap: 20px; justify-content: center;">
                <button id="replayBtn" class="btn" style="font-size: 24px; padding: 20px 40px;">
                    üîÑ –°—ã–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑
                </button>
                <button id="changeGameBtn" class="btn btn-secondary" style="font-size: 24px; padding: 20px 40px; background: #FF5722;">
                    üéÆ –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∏–≥—Ä—É
                </button>
            </div>

            <!-- Ship-specific role choice (only shown for Ship game) -->
            <div id="shipRoleChoice" style="display: none; margin-top: 20px;">
                <p style="font-size: 18px; margin-bottom: 15px; opacity: 0.8;">–î–ª—è –∏–≥—Ä—ã "–ö–æ—Ä–∞–±–ª—å":</p>
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button id="keepRolesBtn" class="btn" style="font-size: 20px; padding: 15px 30px;">
                        ‚ö° –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–º–∞–Ω–¥—ã
                    </button>
                    <button id="changeRolesBtn" class="btn btn-secondary" style="font-size: 20px; padding: 15px 30px;">
                        üîÄ –ò–∑–º–µ–Ω–∏—Ç—å —Ä–æ–ª–∏
                    </button>
                </div>
            </div>
        </div>

        <!-- Game Selection Screen (when changing games) -->
        <div id="gameSelectionScreen" class="screen">
            <h1>üéÆ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É</h1>
            <p style="font-size: 18px; margin-bottom: 40px; opacity: 0.8;">–í—Å–µ –∏–≥—Ä–æ–∫–∏ –æ—Å—Ç–∞–Ω—É—Ç—Å—è –ø–æ–¥–∫–ª—é—á–µ–Ω—ã</p>

            <div style="display: flex; flex-direction: column; gap: 20px; max-width: 400px; margin: 0 auto;">
                <button class="game-select-btn" data-game="pong" style="font-size: 24px; padding: 20px; background: #2196F3; color: white; border: none; border-radius: 12px; cursor: pointer;">
                    üèì Pong
                </button>
                <button class="game-select-btn" data-game="snake" style="font-size: 24px; padding: 20px; background: #4CAF50; color: white; border: none; border-radius: 12px; cursor: pointer;">
                    üêç Star Snake
                </button>
                <button class="game-select-btn" data-game="pushers" style="font-size: 24px; padding: 20px; background: #FF5722; color: white; border: none; border-radius: 12px; cursor: pointer;">
                    üî≤ –¢–æ–ª–∫–∞—Ç–µ–ª–∏
                </button>
                <button class="game-select-btn" data-game="ship" style="font-size: 24px; padding: 20px; background: #9C27B0; color: white; border: none; border-radius: 12px; cursor: pointer;">
                    üöÄ –ö–æ—Ä–∞–±–ª—å
                </button>
            </div>

            <button id="cancelGameChangeBtn" class="btn" style="margin-top: 30px; font-size: 18px; padding: 15px 30px; background: #666;">
                ‚ùå –û—Ç–º–µ–Ω–∞
            </button>
        </div>

        <!-- Game Display -->
        <canvas id="gameCanvas" width="600" height="800"></canvas>

        <!-- Pong Score Display (left and right of canvas) -->
        <div id="pongScores" style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            pointer-events: none;
            z-index: 500;
        ">
            <!-- Left Player -->
            <div id="pongLeftPlayer" style="
                position: absolute;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
                width: calc((100vw - 600px) / 2);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            ">
                <div id="pongLeftName" style="
                    font-size: 2vw;
                    font-weight: bold;
                    margin-bottom: 1vh;
                "></div>
                <div id="pongLeftScore" style="
                    font-size: 12vw;
                    font-weight: bold;
                    line-height: 1;
                "></div>
            </div>

            <!-- Right Player -->
            <div id="pongRightPlayer" style="
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: calc((100vw - 600px) / 2);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            ">
                <div id="pongRightName" style="
                    font-size: 2vw;
                    font-weight: bold;
                    margin-bottom: 1vh;
                "></div>
                <div id="pongRightScore" style="
                    font-size: 12vw;
                    font-weight: bold;
                    line-height: 1;
                "></div>
            </div>
        </div>

        <!-- Persistent QR Code (bottom-left corner) -->
        <div id="persistentQRDisplay" style="
            position: fixed;
            bottom: 15px;
            left: 15px;
            width: 120px;
            height: 120px;
            background: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
        "></div>

        <!-- Team Rosters (Ship game only, during gameplay) -->
        <div id="teamRosters" style="
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 900;
            pointer-events: none;
        ">
            <!-- Blue Team (Left) -->
            <div style="background: rgba(33, 150, 243, 0.15); border: 2px solid #2196F3; border-radius: 8px; padding: 8px; min-width: 200px; backdrop-filter: blur(4px);">
                <div style="font-size: 16px; font-weight: bold; color: #2196F3; margin-bottom: 5px; text-align: center;">
                    üí∞ <span id="blueCoinsDisplay">0</span>
                </div>
                <div id="blueTeamRoster" style="font-size: 11px; color: white; line-height: 1.4;"></div>
            </div>

            <!-- Pink Team (Right) -->
            <div style="background: rgba(233, 30, 99, 0.15); border: 2px solid #E91E63; border-radius: 8px; padding: 8px; min-width: 200px; backdrop-filter: blur(4px);">
                <div style="font-size: 16px; font-weight: bold; color: #E91E63; margin-bottom: 5px; text-align: center;">
                    üí∞ <span id="pinkCoinsDisplay">0</span>
                </div>
                <div id="pinkTeamRoster" style="font-size: 11px; color: white; line-height: 1.4;"></div>
            </div>
        </div>

        <div id="roomInfo" class="room-info" style="display: none;">
            <div class="room-label">–ö–æ–º–Ω–∞—Ç–∞</div>
            <div class="room-id-display" id="roomIdInfo">------</div>
        </div>

        <div id="scoreboard" style="display: none;">
            <h3>–ò–≥—Ä–æ–∫–∏</h3>
            <div id="playerList"></div>
        </div>
    </div>

    <!-- Physics Settings Toggle Button -->
    <button id="physicsToggle" style="display: none;">‚öôÔ∏è</button>

    <!-- Physics Settings Panel -->
    <div id="physicsPanel">
        <!-- Pump System Parameters -->
        <div id="pumpParams" class="physics-section" style="display: none;">
            <h3>‚ö° Pump System</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–≠–Ω–µ—Ä–≥–∏—è –æ—Ç –Ω–∞–∫–∞—á–∫–∏ <span class="value-display" id="pumpEnergyValue">16.0</span></label>
                    <input type="range" id="pumpEnergy" min="1" max="20" step="0.5" value="16">
                </div>
                <div class="physics-control">
                    <label>–ó–∞—Ç—É—Ö–∞–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ <span class="value-display" id="energyDecayValue">0.05</span></label>
                    <input type="range" id="energyDecay" min="0.01" max="0.2" step="0.01" value="0.05">
                </div>
                <div class="physics-control">
                    <label>–ú–∏–Ω. –¥–µ–ª—å—Ç–∞ pump <span class="value-display" id="pumpMinDeltaValue">0.15</span></label>
                    <input type="range" id="pumpMinDelta" min="0" max="0.5" step="0.01" value="0.15">
                </div>
            </div>
        </div>

        <!-- Gradient System Parameters -->
        <div id="gradientParams" class="physics-section">
            <h3>üìä Gradient System</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–ë–∞–∑–æ–≤–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ <span class="value-display" id="gradientBaseDecayValue">200</span> –µ–¥/—Å–µ–∫</label>
                    <input type="range" id="gradientBaseDecay" min="10" max="200" step="5" value="200">
                </div>
            </div>
        </div>

        <!-- Shared Parameters -->
        <div class="physics-section">
            <h3>üöÄ –î–≤–∏–∂–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ç—è–≥–∏ <span class="value-display" id="thrustMultValue">0.1</span></label>
                    <input type="range" id="thrustMult" min="0.1" max="2.0" step="0.1" value="0.1">
                </div>
                <div class="physics-control">
                    <label>–ò–Ω–µ—Ä—Ü–∏—è (—Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ) <span class="value-display" id="inertiaValue">50</span></label>
                    <input type="range" id="inertia" min="0" max="100" step="1" value="50">
                    <div class="setting-info">0 = –±—ã—Å—Ç—Ä–æ–µ —Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ, 100 = –¥–æ–ª–≥–∏–π –¥—Ä–µ–π—Ñ</div>
                </div>
                <div class="physics-control">
                    <label>–ú–∞–∫—Å. —Å–∫–æ—Ä–æ—Å—Ç—å <span class="value-display" id="maxSpeedValue">3.0</span></label>
                    <input type="range" id="maxSpeed" min="1" max="10" step="0.5" value="3">
                </div>
                <div class="physics-control">
                    <label>–ü–æ—Ä–æ–≥ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ <span class="value-display" id="stopThresholdValue">0.01</span></label>
                    <input type="range" id="stopThreshold" min="0.01" max="0.5" step="0.01" value="0.01">
                </div>
            </div>
        </div>

        <div class="physics-section">
            <h3>üî• –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –æ–≥–Ω—è</h3>
            <div class="physics-grid">
                <div class="physics-control">
                    <label>–ü–æ—Ä–æ–≥ –≤–∏–¥–∏–º–æ—Å—Ç–∏ <span class="value-display" id="fireThresholdValue">0.089</span></label>
                    <input type="range" id="fireThreshold" min="0.001" max="0.2" step="0.001" value="0.089">
                </div>
                <div class="physics-control">
                    <label>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –æ–≥–Ω—è <span class="value-display" id="fireIntensityValue">1.4</span></label>
                    <input type="range" id="fireIntensity" min="0.5" max="3.0" step="0.1" value="1.4">
                </div>
                <div class="physics-control">
                    <label>–ú–∞–∫—Å. —á–∞—Å—Ç–∏—Ü <span class="value-display" id="maxParticlesValue">15</span></label>
                    <input type="range" id="maxParticles" min="3" max="20" step="1" value="15">
                </div>
            </div>
        </div>
    </div>

    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <script>
        let ws = null;
        let gameState = null;
        let roomId = null;
        let gameType = null; // 'pong' or 'snake'
        let isJoinMode = false; // false = create room, true = join existing room
        let joinRoomCode = null; // room code to join

        let gameSettings = {}; // Store game settings

        // Centralized logging function - sends logs to server
        function logToServer(level, message, data = null) {
            // Also log locally
            if (level === 'ERROR') {
                console.error(message, data);
            } else if (level === 'WARN') {
                console.warn(message, data);
            } else {
                console.log(message, data);
            }

            // Send to server
            try {
                // Determine server URL from WebSocket connection
                let serverUrl = 'http://localhost:8080';
                if (ws && ws.url) {
                    if (ws.url.includes('kinemon.onrender.com')) {
                        serverUrl = 'https://kinemon.onrender.com';
                    } else if (ws.url.includes('localhost')) {
                        serverUrl = 'http://localhost:8080';
                    }
                }

                fetch(`${serverUrl}/api/log`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        clientType: 'display',
                        level: level,
                        message: message,
                        data: data
                    })
                }).catch(err => {
                    // Silently fail if server is unreachable
                    console.error('[LOG] Failed to send log to server:', err);
                });
            } catch (error) {
                // Ignore errors in logging system
            }
        }

        // Live physics settings (Ship game only)
        let physicsSettings = {
            // Pump system parameters
            pumpEnergy: 16.0,
            energyDecay: 0.05,
            pumpMinDelta: 0.15,

            // Gradient system parameters
            gradientBaseDecay: 100,    // Base decay rate (units/sec) for gradient system

            // Shared parameters
            thrustMult: 1.0,
            inertia: 50,               // Inertia parameter (0-100) controls friction
            maxSpeed: 3.0,
            stopThreshold: 0.01,
            fireThreshold: 0.089,
            fireIntensity: 1.4,
            maxParticles: 15
        };

        // Visual effects system
        const effects = {
            particles: [],
            screenShake: { active: false, offsetX: 0, offsetY: 0, intensity: 0, startTime: 0, duration: 0 },
            flash: { active: false, color: '#FFF', alpha: 0, startTime: 0, duration: 0 },
            scoreAnims: []
        };

        // Detect available viewport dimensions
        function getAvailableCanvasDimensions() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            console.log(`Viewport: ${availableWidth}x${availableHeight}`);
            return {
                width: Math.floor(availableWidth),
                height: Math.floor(availableHeight)
            };
        }

        const settingsScreen = document.getElementById('settingsScreen');
        const connectionScreen = document.getElementById('connectionScreen');
        const waitingScreen = document.getElementById('waitingScreen');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Disable image smoothing for crisp rendering (fixes blurry appearance)
        ctx.imageSmoothingEnabled = false;

        // Function to scale canvas to fit screen while maintaining aspect ratio
        function scaleCanvasToScreen() {
            if (!canvas.classList.contains('active')) return;

            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            const scaleX = windowWidth / canvasWidth;
            const scaleY = windowHeight / canvasHeight;
            const scale = Math.min(scaleX, scaleY);

            canvas.style.width = `${canvasWidth * scale}px`;
            canvas.style.height = `${canvasHeight * scale}px`;
        }

        // Scale canvas on resize and when it becomes active
        window.addEventListener('resize', scaleCanvasToScreen);

        const playerList = document.getElementById('playerList');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomIdInfo = document.getElementById('roomIdInfo');
        const roomInfo = document.getElementById('roomInfo');
        const scoreboard = document.getElementById('scoreboard');
        const playerCount = document.getElementById('playerCount');
        const startGameBtn = document.getElementById('startGameBtn');
        const gameTitle = document.getElementById('gameTitle');
        const settingsForm = document.getElementById('settingsForm');

        // Parse game type from URL
        const urlParams = new URLSearchParams(window.location.search);
        gameType = urlParams.get('game') || 'snake'; // default to snake if not specified

        // Set default server URL
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '';
        const defaultServerUrl = isLocalhost ? 'ws://localhost:8080' : 'wss://kinemon.onrender.com';

        // Populate settings based on game type
        function populateSettings() {
            if (gameType === 'pong') {
                gameTitle.textContent = 'üèì –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Pong';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="pongBallSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞</label>
                        <select id="pongBallSpeed">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω–∞—è</option>
                            <option value="2">–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3" selected>–ë—ã—Å—Ç—Ä–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞ –º—è—á–∞</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongPaddleSize">–†–∞–∑–º–µ—Ä —Ä–∞–∫–µ—Ç–∫–∏</label>
                        <select id="pongPaddleSize">
                            <option value="1">–ú–∞–ª–µ–Ω—å–∫–∞—è</option>
                            <option value="2" selected>–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3">–ë–æ–ª—å—à–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä —Ä–∞–∫–µ—Ç–æ–∫ –∏–≥—Ä–æ–∫–æ–≤</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongSpeedIncrease">–ü—Ä–∏—Ä–æ—Å—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –º—è—á–∞</label>
                        <select id="pongSpeedIncrease">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω—ã–π (+5%)</option>
                            <option value="2" selected>–°—Ä–µ–¥–Ω–∏–π (+15%)</option>
                            <option value="3">–ë—ã—Å—Ç—Ä—ã–π (+30%)</option>
                        </select>
                        <div class="setting-info">–£—Å–∫–æ—Ä–µ–Ω–∏–µ –º—è—á–∞ –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —É–¥–∞—Ä–∞</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongWinScore">–ü–æ–±–µ–¥–Ω—ã–π —Å—á–µ—Ç</label>
                        <select id="pongWinScore">
                            <option value="5">5 –æ—á–∫–æ–≤</option>
                            <option value="11" selected>11 –æ—á–∫–æ–≤</option>
                            <option value="21">21 –æ—á–∫–æ</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongBotDifficulty">–°–ª–æ–∂–Ω–æ—Å—Ç—å –±–æ—Ç–∞</label>
                        <select id="pongBotDifficulty">
                            <option value="easy">–õ—ë–≥–∫–∏–π</option>
                            <option value="medium" selected>–°—Ä–µ–¥–Ω–∏–π</option>
                            <option value="hard">–°–ª–æ–∂–Ω—ã–π</option>
                        </select>
                        <div class="setting-info">–£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –±–æ—Ç–∞ –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.ballSpeed = parseInt(localStorage.getItem('pongBallSpeed')) || 3;
                gameSettings.paddleSize = parseInt(localStorage.getItem('pongPaddleSize')) || 2;
                gameSettings.speedIncrease = parseInt(localStorage.getItem('pongSpeedIncrease')) || 2;
                gameSettings.winScore = parseInt(localStorage.getItem('pongWinScore')) || 11;
                gameSettings.botDifficulty = localStorage.getItem('pongBotDifficulty') || 'medium';

                document.getElementById('pongBallSpeed').value = gameSettings.ballSpeed;
                document.getElementById('pongPaddleSize').value = gameSettings.paddleSize;
                document.getElementById('pongSpeedIncrease').value = gameSettings.speedIncrease;
                document.getElementById('pongWinScore').value = gameSettings.winScore;
                document.getElementById('pongBotDifficulty').value = gameSettings.botDifficulty;

            } else if (gameType === 'pushers') {
                gameTitle.textContent = 'üî≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–æ–ª–∫–∞—Ç–µ–ª–∏';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="pushersWinScore">–û—á–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="pushersWinScore">
                            <option value="10">10 –æ—á–∫–æ–≤</option>
                            <option value="15" selected>15 –æ—á–∫–æ–≤</option>
                            <option value="20">20 –æ—á–∫–æ–≤</option>
                            <option value="25">25 –æ—á–∫–æ–≤</option>
                            <option value="30">30 –æ—á–∫–æ–≤</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–º–∞–π–ª–∏–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã –∫–æ–º–∞–Ω–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="pushersSingleSquare">–†–µ–∂–∏–º –∏–≥—Ä—ã</label>
                        <select id="pushersSingleSquare">
                            <option value="false">–û–±—ã—á–Ω—ã–π - –∫–∞–∂–¥—ã–π –∏–≥—Ä–æ–∫ —Å–≤–æ–π –∫–≤–∞–¥—Ä–∞—Ç</option>
                            <option value="true">–û–¥–∏–Ω –∫–≤–∞–¥—Ä–∞—Ç –Ω–∞ –∫–æ–º–∞–Ω–¥—É - –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤</option>
                        </select>
                        <div class="setting-info">–í –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–µ –¥–≤–∞ –∏–≥—Ä–æ–∫–∞ —É–ø—Ä–∞–≤–ª—è—é—Ç –æ–¥–Ω–∏–º –∫–≤–∞–¥—Ä–∞—Ç–æ–º (–æ–¥–∏–Ω –ø–æ X, –¥—Ä—É–≥–æ–π –ø–æ Y)</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.winScore = parseInt(localStorage.getItem('pushersWinScore')) || 15;
                const singleSquare = localStorage.getItem('pushersSingleSquare') || 'false';

                document.getElementById('pushersWinScore').value = gameSettings.winScore;
                document.getElementById('pushersSingleSquare').value = singleSquare;

            } else if (gameType === 'ship') {
                gameTitle.textContent = 'üöÄ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ö–æ—Ä–∞–±–ª—å';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="shipCoinsToWin">–ú–æ–Ω–µ—Ç –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="shipCoinsToWin">
                            <option value="5">5 –º–æ–Ω–µ—Ç</option>
                            <option value="10" selected>10 –º–æ–Ω–µ—Ç</option>
                            <option value="15">15 –º–æ–Ω–µ—Ç</option>
                            <option value="20">20 –º–æ–Ω–µ—Ç</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipAsteroidFrequency">–ß–∞—Å—Ç–æ—Ç–∞ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</label>
                        <select id="shipAsteroidFrequency">
                            <option value="none">–ë–µ–∑ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤ (–æ–±—É—á–µ–Ω–∏–µ)</option>
                            <option value="low">–ù–∏–∑–∫–∞—è (3 —Å–µ–∫)</option>
                            <option value="medium" selected>–°—Ä–µ–¥–Ω—è—è (2 —Å–µ–∫)</option>
                            <option value="high">–í—ã—Å–æ–∫–∞—è (1.2 —Å–µ–∫)</option>
                        </select>
                        <div class="setting-info">–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ—è–≤–ª–µ–Ω–∏—è –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipAutopilotEnabled">–ê–≤—Ç–æ–ø–∏–ª–æ—Ç—ã</label>
                        <select id="shipAutopilotEnabled">
                            <option value="false" selected>–í—ã–∫–ª—é—á–µ–Ω—ã</option>
                            <option value="true">–í–∫–ª—é—á–µ–Ω—ã</option>
                        </select>
                        <div class="setting-info">–ê–≤—Ç–æ–ø–∏–ª–æ—Ç—ã —É–ø—Ä–∞–≤–ª—è—é—Ç –Ω–µ–∑–∞–Ω—è—Ç—ã–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipCoinSpawn">–°–ø–∞—É–Ω –º–æ–Ω–µ—Ç</label>
                        <select id="shipCoinSpawn">
                            <option value="true" selected>–í–∫–ª—é—á–µ–Ω</option>
                            <option value="false">–í—ã–∫–ª—é—á–µ–Ω</option>
                        </select>
                        <div class="setting-info">–ï—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω, –º–æ–Ω–µ—Ç—ã –ø–æ—è–≤–ª—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–∑ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.coinsToWin = parseInt(localStorage.getItem('shipCoinsToWin')) || 10;
                gameSettings.asteroidFrequency = localStorage.getItem('shipAsteroidFrequency') || 'medium';
                gameSettings.autopilotEnabled = localStorage.getItem('shipAutopilotEnabled') === 'true' ? true : false;
                gameSettings.coinSpawn = localStorage.getItem('shipCoinSpawn') !== 'false'; // default true

                document.getElementById('shipCoinsToWin').value = gameSettings.coinsToWin;
                document.getElementById('shipAsteroidFrequency').value = gameSettings.asteroidFrequency;
                document.getElementById('shipAutopilotEnabled').value = gameSettings.autopilotEnabled.toString();
                document.getElementById('shipCoinSpawn').value = gameSettings.coinSpawn.toString();

            } else if (gameType === 'ballz') {
                gameTitle.textContent = 'üéØ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Ballz';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="ballzFieldWidth">–®–∏—Ä–∏–Ω–∞ –ø–æ–ª—è (–±–ª–æ–∫–æ–≤)</label>
                        <select id="ballzFieldWidth">
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7" selected>7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzFieldHeight">–í—ã—Å–æ—Ç–∞ –ø–æ–ª—è (–±–ª–æ–∫–æ–≤)</label>
                        <select id="ballzFieldHeight">
                            <option value="8">8</option>
                            <option value="10" selected>10</option>
                            <option value="12">12</option>
                            <option value="14">14</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzHPIncrease">HP —Ä–∞—Å—Ç—ë—Ç –∫–∞–∂–¥—ã–µ N —Ö–æ–¥–æ–≤</label>
                        <select id="ballzHPIncrease">
                            <option value="3">3</option>
                            <option value="5" selected>5</option>
                            <option value="7">7</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzMaxHP">–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π HP –±–ª–æ–∫–∞</label>
                        <select id="ballzMaxHP">
                            <option value="30">30</option>
                            <option value="50" selected>50</option>
                            <option value="75">75</option>
                            <option value="100">100</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzLowerHPChance">–®–∞–Ω—Å –Ω–∏–∑–∫–æ–≥–æ HP (%)</label>
                        <select id="ballzLowerHPChance">
                            <option value="0">0%</option>
                            <option value="20">20%</option>
                            <option value="30" selected>30%</option>
                            <option value="50">50%</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzChargeTime">–í—Ä–µ–º—è –∑–∞—Ä—è–¥–∫–∏</label>
                        <select id="ballzChargeTime">
                            <option value="1000">1 —Å–µ–∫—É–Ω–¥–∞</option>
                            <option value="2000" selected>2 —Å–µ–∫—É–Ω–¥—ã</option>
                            <option value="3000">3 —Å–µ–∫—É–Ω–¥—ã</option>
                            <option value="4000">4 —Å–µ–∫—É–Ω–¥—ã</option>
                            <option value="5000">5 —Å–µ–∫—É–Ω–¥</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzAimSensitivity">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–∏—Ü–µ–ª–∞</label>
                        <select id="ballzAimSensitivity">
                            <option value="0.001">–°—É–ø–µ—Ä-–Ω–∏–∑–∫–∞—è (0.1%)</option>
                            <option value="0.002">–û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è (0.2%)</option>
                            <option value="0.005" selected>–ù–∏–∑–∫–∞—è (0.5%)</option>
                            <option value="0.01">–°—Ä–µ–¥–Ω—è—è (1%)</option>
                            <option value="0.02">–í—ã—Å–æ–∫–∞—è (2%)</option>
                        </select>
                        <div class="setting-info">–ù–∞—Å–∫–æ–ª—å–∫–æ –ª–µ–≥–∫–æ —Å–±–∏–≤–∞–µ—Ç—Å—è –∑–∞—Ä—è–¥–∫–∞ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="ballzBallSpeed">–°–∫–æ—Ä–æ—Å—Ç—å —à–∞—Ä–∞</label>
                        <select id="ballzBallSpeed">
                            <option value="1" selected>–ú–µ–¥–ª–µ–Ω–Ω–æ</option>
                            <option value="1.5">–ù–µ–º–Ω–æ–≥–æ –±—ã—Å—Ç—Ä–µ–µ</option>
                            <option value="2">–°—Ä–µ–¥–Ω–µ</option>
                            <option value="2.5">–ë—ã—Å—Ç—Ä–æ</option>
                            <option value="3">–û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzLaunchDelay">–ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —à–∞—Ä–∞–º–∏</label>
                        <select id="ballzLaunchDelay">
                            <option value="50">50 –º—Å</option>
                            <option value="100" selected>100 –º—Å</option>
                            <option value="150">150 –º—Å</option>
                        </select>
                    </div>
                    <div class="setting-group">
                        <label for="ballzBonusSpawnRate">–®–∞–Ω—Å –±–æ–Ω—É—Å–Ω–æ–≥–æ —à–∞—Ä–∞</label>
                        <select id="ballzBonusSpawnRate">
                            <option value="5">5%</option>
                            <option value="10">10%</option>
                            <option value="15" selected>15%</option>
                            <option value="25">25%</option>
                        </select>
                    </div>
                `;

                // Load saved settings
                gameSettings.fieldWidth = parseInt(localStorage.getItem('ballzFieldWidth')) || 7;
                gameSettings.fieldHeight = parseInt(localStorage.getItem('ballzFieldHeight')) || 10;
                gameSettings.hpIncreaseEveryN = parseInt(localStorage.getItem('ballzHPIncrease')) || 5;
                gameSettings.maxBlockHP = parseInt(localStorage.getItem('ballzMaxHP')) || 50;
                gameSettings.lowerHPChance = parseInt(localStorage.getItem('ballzLowerHPChance')) || 30;
                gameSettings.chargeTime = parseInt(localStorage.getItem('ballzChargeTime')) || 2000;
                gameSettings.aimSensitivity = parseFloat(localStorage.getItem('ballzAimSensitivity')) || 0.005;
                gameSettings.ballSpeed = parseFloat(localStorage.getItem('ballzBallSpeed')) || 1;
                gameSettings.ballLaunchDelay = parseInt(localStorage.getItem('ballzLaunchDelay')) || 100;
                gameSettings.bonusBallSpawnRate = parseInt(localStorage.getItem('ballzBonusSpawnRate')) || 15;

                // Apply to form
                document.getElementById('ballzFieldWidth').value = gameSettings.fieldWidth;
                document.getElementById('ballzFieldHeight').value = gameSettings.fieldHeight;
                document.getElementById('ballzHPIncrease').value = gameSettings.hpIncreaseEveryN;
                document.getElementById('ballzMaxHP').value = gameSettings.maxBlockHP;
                document.getElementById('ballzLowerHPChance').value = gameSettings.lowerHPChance;
                document.getElementById('ballzChargeTime').value = gameSettings.chargeTime;
                document.getElementById('ballzAimSensitivity').value = gameSettings.aimSensitivity;
                document.getElementById('ballzBallSpeed').value = gameSettings.ballSpeed;
                document.getElementById('ballzLaunchDelay').value = gameSettings.ballLaunchDelay;
                document.getElementById('ballzBonusSpawnRate').value = gameSettings.bonusBallSpawnRate;
            } else { // snake
                gameTitle.textContent = 'üêç –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Star Snake';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="snakeTurnSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞</label>
                        <select id="snakeTurnSpeed">
                            <option value="1">1x - –ú–µ–¥–ª–µ–Ω–Ω–æ</option>
                            <option value="2" selected>2x - –ù–æ—Ä–º–∞–ª—å–Ω–æ</option>
                            <option value="3">3x - –ë—ã—Å—Ç—Ä–æ</option>
                            <option value="4">4x - –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ</option>
                            <option value="5">5x - –≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–æ</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞ –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeControlMapping">–†–µ–∂–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</label>
                        <select id="snakeControlMapping">
                            <option value="rotation_smooth" selected>–ü–æ–≤–æ—Ä–æ—Ç (–ø–ª–∞–≤–Ω—ã–π)</option>
                            <option value="center_straight">–¶–µ–Ω—Ç—Ä = –ø—Ä—è–º–æ</option>
                            <option value="rotation_linear">–ü–æ–≤–æ—Ä–æ—Ç (—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π)</option>
                            <option value="nonlinear_a">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π A (—Å—Ç–∞—Ä—ã–π)</option>
                            <option value="nonlinear_b">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π B (—Å—Ç–∞—Ä—ã–π)</option>
                            <option value="arrow_steering">–°—Ç—Ä–µ–ª–∫–∞</option>
                            <option value="arrow_instant">–ü–æ—Å–ª—É—à–Ω–∞—è —Å—Ç—Ä–µ–ª–∫–∞</option>
                        </select>
                        <div class="setting-info">–ö–∞–∫ –Ω–∞–∫–ª–æ–Ω –≤–ª–∏—è–µ—Ç –Ω–∞ –ø–æ–≤–æ—Ä–æ—Ç –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeMoveSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è</label>
                        <select id="snakeMoveSpeed">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω–∞—è</option>
                            <option value="2">–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3" selected>–ë—ã—Å—Ç—Ä–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeSize">–†–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏</label>
                        <select id="snakeSize">
                            <option value="1" selected>1 - –ú–∏–Ω–∏–º—É–º</option>
                            <option value="2">2 - –ú–∞–ª–µ–Ω—å–∫–∏–π</option>
                            <option value="3">3 - –°—Ä–µ–¥–Ω–∏–π</option>
                            <option value="4">4 - –ë–æ–ª—å—à–æ–π</option>
                            <option value="5">5 - –ú–∞–∫—Å–∏–º—É–º</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏ –∏ –ø–∏—Ü—Ü—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeWinScore">–ó–≤—ë–∑–¥ –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="snakeWinScore">
                            <option value="20">20 –∑–≤—ë–∑–¥</option>
                            <option value="30">30 –∑–≤—ë–∑–¥</option>
                            <option value="50" selected>50 –∑–≤—ë–∑–¥</option>
                            <option value="75">75 –∑–≤—ë–∑–¥</option>
                            <option value="100">100 –∑–≤—ë–∑–¥</option>
                            <option value="150">150 –∑–≤—ë–∑–¥</option>
                            <option value="200">200 –∑–≤—ë–∑–¥</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤—ë–∑–¥ –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeInitialPizzas">–ù–∞—á–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤—ë–∑–¥</label>
                        <select id="snakeInitialPizzas">
                            <option value="100" selected>100 –∑–≤—ë–∑–¥</option>
                            <option value="150">150 –∑–≤—ë–∑–¥</option>
                            <option value="200">200 –∑–≤—ë–∑–¥</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤—ë–∑–¥–Ω–æ–π –ø—ã–ª–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeGrowthSpeed">–°–∫–æ—Ä–æ—Å—Ç—å —Ä–æ—Å—Ç–∞ –∑–º–µ–π–∫–∏</label>
                        <select id="snakeGrowthSpeed">
                            <option value="1" selected>–ú–µ–¥–ª–µ–Ω–Ω–æ</option>
                            <option value="2">–°—Ä–µ–¥–Ω–µ (x2)</option>
                            <option value="4">–ë—ã—Å—Ç—Ä–æ (x4)</option>
                            <option value="8">–°—É–ø–µ—Ä –±—ã—Å—Ç—Ä–æ (x8)</option>
                        </select>
                        <div class="setting-info">–ö–∞–∫ –±—ã—Å—Ç—Ä–æ —Ä–∞—Å—Ç—ë—Ç –∑–º–µ–π–∫–∞ –ø–æ—Å–ª–µ –ø–æ–µ–¥–∞–Ω–∏—è –ø–∏—Ü—Ü—ã</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.turnSpeed = parseInt(localStorage.getItem('snakeTurnSpeed')) || 2;
                gameSettings.controlMapping = localStorage.getItem('snakeControlMapping') || 'rotation_smooth';
                gameSettings.moveSpeed = parseInt(localStorage.getItem('snakeMoveSpeed')) || 3;
                gameSettings.snakeSize = parseInt(localStorage.getItem('snakeSize')) || 1;
                gameSettings.winScore = parseInt(localStorage.getItem('snakeWinScore')) || 50;
                gameSettings.initialPizzas = parseInt(localStorage.getItem('snakeInitialPizzas')) || 100;
                gameSettings.growthSpeed = parseInt(localStorage.getItem('snakeGrowthSpeed')) || 1;

                document.getElementById('snakeTurnSpeed').value = gameSettings.turnSpeed;
                document.getElementById('snakeControlMapping').value = gameSettings.controlMapping;
                document.getElementById('snakeMoveSpeed').value = gameSettings.moveSpeed;
                document.getElementById('snakeSize').value = gameSettings.snakeSize;
                document.getElementById('snakeWinScore').value = gameSettings.winScore;
                document.getElementById('snakeInitialPizzas').value = gameSettings.initialPizzas;
                document.getElementById('snakeGrowthSpeed').value = gameSettings.growthSpeed;
            }
        }

        // Initialize settings on page load
        populateSettings();

        // Start game button - save settings and connect to server
        startGameBtn.addEventListener('click', () => {
            // Save settings to localStorage
            if (gameType === 'pong') {
                gameSettings.ballSpeed = parseInt(document.getElementById('pongBallSpeed').value);
                gameSettings.paddleSize = parseInt(document.getElementById('pongPaddleSize').value);
                gameSettings.speedIncrease = parseInt(document.getElementById('pongSpeedIncrease').value);
                gameSettings.winScore = parseInt(document.getElementById('pongWinScore').value);
                gameSettings.botDifficulty = document.getElementById('pongBotDifficulty').value;
                localStorage.setItem('pongBallSpeed', gameSettings.ballSpeed);
                localStorage.setItem('pongPaddleSize', gameSettings.paddleSize);
                localStorage.setItem('pongSpeedIncrease', gameSettings.speedIncrease);
                localStorage.setItem('pongWinScore', gameSettings.winScore);
                localStorage.setItem('pongBotDifficulty', gameSettings.botDifficulty);
            } else if (gameType === 'pushers') {
                gameSettings.winScore = parseInt(document.getElementById('pushersWinScore').value);
                gameSettings.singleSquare = document.getElementById('pushersSingleSquare').value === 'true';
                localStorage.setItem('pushersWinScore', gameSettings.winScore);
                localStorage.setItem('pushersSingleSquare', gameSettings.singleSquare);
            } else if (gameType === 'ship') {
                gameSettings.coinsToWin = parseInt(document.getElementById('shipCoinsToWin').value);
                gameSettings.asteroidFrequency = document.getElementById('shipAsteroidFrequency').value;
                gameSettings.autopilotEnabled = document.getElementById('shipAutopilotEnabled').value === 'true';
                gameSettings.coinSpawn = document.getElementById('shipCoinSpawn').value === 'true';
                localStorage.setItem('shipCoinsToWin', gameSettings.coinsToWin);
                localStorage.setItem('shipAsteroidFrequency', gameSettings.asteroidFrequency);
                localStorage.setItem('shipAutopilotEnabled', gameSettings.autopilotEnabled);
                localStorage.setItem('shipCoinSpawn', gameSettings.coinSpawn);
            } else if (gameType === 'ballz') {
                gameSettings.fieldWidth = parseInt(document.getElementById('ballzFieldWidth').value);
                gameSettings.fieldHeight = parseInt(document.getElementById('ballzFieldHeight').value);
                gameSettings.hpIncreaseEveryN = parseInt(document.getElementById('ballzHPIncrease').value);
                gameSettings.maxBlockHP = parseInt(document.getElementById('ballzMaxHP').value);
                gameSettings.lowerHPChance = parseInt(document.getElementById('ballzLowerHPChance').value);
                gameSettings.chargeTime = parseInt(document.getElementById('ballzChargeTime').value);
                gameSettings.aimSensitivity = parseFloat(document.getElementById('ballzAimSensitivity').value);
                gameSettings.ballSpeed = parseFloat(document.getElementById('ballzBallSpeed').value);
                gameSettings.ballLaunchDelay = parseInt(document.getElementById('ballzLaunchDelay').value);
                gameSettings.bonusBallSpawnRate = parseInt(document.getElementById('ballzBonusSpawnRate').value);
                localStorage.setItem('ballzFieldWidth', gameSettings.fieldWidth);
                localStorage.setItem('ballzFieldHeight', gameSettings.fieldHeight);
                localStorage.setItem('ballzHPIncrease', gameSettings.hpIncreaseEveryN);
                localStorage.setItem('ballzMaxHP', gameSettings.maxBlockHP);
                localStorage.setItem('ballzLowerHPChance', gameSettings.lowerHPChance);
                localStorage.setItem('ballzChargeTime', gameSettings.chargeTime);
                localStorage.setItem('ballzAimSensitivity', gameSettings.aimSensitivity);
                localStorage.setItem('ballzBallSpeed', gameSettings.ballSpeed);
                localStorage.setItem('ballzLaunchDelay', gameSettings.ballLaunchDelay);
                localStorage.setItem('ballzBonusSpawnRate', gameSettings.bonusBallSpawnRate);
            } else {
                gameSettings.turnSpeed = parseInt(document.getElementById('snakeTurnSpeed').value);
                gameSettings.controlMapping = document.getElementById('snakeControlMapping').value;
                gameSettings.moveSpeed = parseInt(document.getElementById('snakeMoveSpeed').value);
                gameSettings.snakeSize = parseInt(document.getElementById('snakeSize').value);
                gameSettings.winScore = parseInt(document.getElementById('snakeWinScore').value);
                gameSettings.initialPizzas = parseInt(document.getElementById('snakeInitialPizzas').value);
                gameSettings.growthSpeed = parseInt(document.getElementById('snakeGrowthSpeed').value);
                localStorage.setItem('snakeTurnSpeed', gameSettings.turnSpeed);
                localStorage.setItem('snakeControlMapping', gameSettings.controlMapping);
                localStorage.setItem('snakeMoveSpeed', gameSettings.moveSpeed);
                localStorage.setItem('snakeSize', gameSettings.snakeSize);
                localStorage.setItem('snakeWinScore', gameSettings.winScore);
                localStorage.setItem('snakeInitialPizzas', gameSettings.initialPizzas);
                localStorage.setItem('snakeGrowthSpeed', gameSettings.growthSpeed);
            }

            console.log('Game settings:', gameSettings);

            // Show connection screen and connect
            showScreen('connection');

            // Show mode selection after connection is established
            isJoinMode = false; // Default to create mode
            connectToServer();
        });

        // Handle mode selection buttons
        document.getElementById('createRoomBtn').addEventListener('click', () => {
            isJoinMode = false;
            document.getElementById('connectionModeSelect').style.display = 'none';
            document.getElementById('connectionStatus').textContent = '–°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã...';

            // Send create_room message
            if (ws && ws.readyState === WebSocket.OPEN) {
                const dimensions = getAvailableCanvasDimensions();
                if (gameType === 'snake' || gameType === 'ship') {
                    gameSettings.canvasWidth = dimensions.width;
                    gameSettings.canvasHeight = dimensions.height;
                }

                ws.send(JSON.stringify({
                    type: 'create_room',
                    gameType: gameType,
                    settings: gameSettings
                }));
            }
        });

        document.getElementById('joinRoomBtn').addEventListener('click', () => {
            document.getElementById('connectionModeSelect').style.display = 'none';
            document.getElementById('joinRoomInput').style.display = 'block';
            document.getElementById('connectionStatus').style.display = 'none';
        });

        document.getElementById('backToModeBtn').addEventListener('click', () => {
            document.getElementById('joinRoomInput').style.display = 'none';
            document.getElementById('connectionModeSelect').style.display = 'block';
            document.getElementById('connectionStatus').style.display = 'block';
        });

        document.getElementById('confirmJoinBtn').addEventListener('click', () => {
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã');
                return;
            }

            isJoinMode = true;
            joinRoomCode = roomCode;
            document.getElementById('joinRoomInput').style.display = 'none';
            document.getElementById('connectionStatus').style.display = 'block';
            document.getElementById('connectionStatus').textContent = `–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ ${roomCode}...`;

            // Send join message
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'join_room',
                    roomId: roomCode,
                    clientType: 'display'
                }));
            }
        });

        // Wake up Render server on page load (free tier spins down after inactivity)
        if (!isLocalhost) {
            console.log('üîÑ Waking up Render server...');
            fetch('https://kinemon.onrender.com')
                .then(() => console.log('‚úÖ Server wake-up request sent'))
                .catch((err) => console.log('‚ö†Ô∏è Server wake-up failed:', err));
        }

        function generatePersistentQR(qrData) {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            let persistentQRSize = 110; // Default (phones)

            if (screenWidth >= 2560 || screenHeight >= 1440) {
                persistentQRSize = 60; // 4K - very small
            } else if (screenWidth >= 1920 || screenHeight >= 1080) {
                persistentQRSize = 75; // Full HD - small
            } else if (screenWidth >= 1024 || screenHeight >= 768) {
                persistentQRSize = 90; // Tablets/medium
            }

            const persistentQR = document.getElementById('persistentQRDisplay');
            persistentQR.innerHTML = '';
            new QRCode(persistentQR, {
                text: qrData,
                width: persistentQRSize,
                height: persistentQRSize,
                colorDark: '#000000',
                colorLight: '#ffffff',
                correctLevel: QRCode.CorrectLevel.M
            });
        }

        // Get default settings for a game type (for game switching)
        function getDefaultSettingsForGame(gameType) {
            if (gameType === 'pong') {
                return {
                    ballSpeed: parseInt(localStorage.getItem('pongBallSpeed')) || 3,
                    paddleSize: parseInt(localStorage.getItem('pongPaddleSize')) || 2,
                    winScore: parseInt(localStorage.getItem('pongWinScore')) || 11,
                    speedIncrease: parseInt(localStorage.getItem('pongSpeedIncrease')) || 2 // 1=5%, 2=15% (default), 3=30%
                };
            } else if (gameType === 'snake') {
                return {
                    moveSpeed: parseInt(localStorage.getItem('snakeMoveSpeed')) || 3,
                    turnSpeed: parseInt(localStorage.getItem('snakeTurnSpeed')) || 2,
                    snakeSize: parseInt(localStorage.getItem('snakeSize')) || 2, // Changed: 1 ‚Üí 2 (–°—Ä–µ–¥–Ω–∏–π)
                    growthSpeed: parseInt(localStorage.getItem('snakeGrowthSpeed')) || 4, // Changed: 1 ‚Üí 4 (–ë—ã—Å—Ç—Ä–æ)
                    winScore: parseInt(localStorage.getItem('snakeWinScore')) || 50,
                    initialPizzas: parseInt(localStorage.getItem('snakeInitialPizzas')) || 100,
                    controlMapping: localStorage.getItem('snakeControlMapping') || 'rotation_smooth',
                    canvasWidth: canvas.width,
                    canvasHeight: canvas.height
                };
            } else if (gameType === 'pushers') {
                return {
                    winScore: parseInt(localStorage.getItem('pushersWinScore')) || 15
                };
            } else if (gameType === 'ship') {
                return {
                    coinsToWin: parseInt(localStorage.getItem('shipCoinsToWin')) || 10,
                    asteroidFrequency: localStorage.getItem('shipAsteroidFrequency') || 'medium',
                    autopilotEnabled: localStorage.getItem('shipAutopilotEnabled') === 'true',
                    coinSpawn: localStorage.getItem('shipCoinSpawn') !== 'false', // default true
                    canvasWidth: canvas.width,
                    canvasHeight: canvas.height
                };
            }
            return {};
        }

        function showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if (screenName === 'settings') {
                settingsScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'connection') {
                connectionScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'waiting') {
                waitingScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
                // Hide persistent QR on waiting screen (large QR shown instead)
                const persistentQR = document.getElementById('persistentQRDisplay');
                if (persistentQR) persistentQR.style.display = 'none';
            } else if (screenName === 'lobby') {
                document.getElementById('lobbyScreen').classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
                // Reset waiting QR flag when leaving waiting screen
                // Generate and show persistent QR on lobby screen (first time only)
                if (!window.persistentQRGenerated && window.persistentQRData) {
                    generatePersistentQR(window.persistentQRData);
                    window.persistentQRGenerated = true;
                }
                const persistentQR = document.getElementById('persistentQRDisplay');
                if (persistentQR) persistentQR.style.display = 'block';
            } else if (screenName === 'win') {
                document.getElementById('winScreen').classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
                // Reset waiting QR flag for potential new game
            } else if (screenName === 'gameSelection') {
                document.getElementById('gameSelectionScreen').classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'game') {
                canvas.classList.add('active');
                scaleCanvasToScreen(); // Scale when canvas becomes visible
                // Reset waiting QR flag when leaving waiting screen
                // Generate and show persistent QR on game screen (first time only)
                if (!window.persistentQRGenerated && window.persistentQRData) {
                    generatePersistentQR(window.persistentQRData);
                    window.persistentQRGenerated = true;
                }
                const persistentQR = document.getElementById('persistentQRDisplay');
                if (persistentQR) persistentQR.style.display = 'block';

                // Hide right panel for Pushers and Ship (team-based/cooperative games use canvas scoreboard)
                if (gameState && (gameState.gameType === 'pushers' || gameState.gameType === 'ship')) {
                    roomInfo.style.display = 'none';
                    scoreboard.style.display = 'none';

                    // Show physics toggle button for Ship game
                    if (gameState.gameType === 'ship') {
                        document.getElementById('physicsToggle').style.display = 'block';
                    }
                } else {
                    roomInfo.style.display = 'block';
                    scoreboard.style.display = 'block';
                }
            }
        }

        // Physics panel toggle
        document.getElementById('physicsToggle').addEventListener('click', () => {
            const panel = document.getElementById('physicsPanel');
            panel.classList.toggle('open');
        });

        // Physics settings event listeners
        function setupPhysicsControls() {
            const controls = [
                // Pump system
                { id: 'pumpEnergy', setting: 'pumpEnergy', display: 'pumpEnergyValue', decimals: 1 },
                { id: 'energyDecay', setting: 'energyDecay', display: 'energyDecayValue', decimals: 2 },
                { id: 'pumpMinDelta', setting: 'pumpMinDelta', display: 'pumpMinDeltaValue', decimals: 2 },
                // Gradient system
                { id: 'gradientBaseDecay', setting: 'gradientBaseDecay', display: 'gradientBaseDecayValue', decimals: 0 },
                // Shared
                { id: 'thrustMult', setting: 'thrustMult', display: 'thrustMultValue', decimals: 1 },
                { id: 'inertia', setting: 'inertia', display: 'inertiaValue', decimals: 0 },
                { id: 'maxSpeed', setting: 'maxSpeed', display: 'maxSpeedValue', decimals: 1 },
                { id: 'stopThreshold', setting: 'stopThreshold', display: 'stopThresholdValue', decimals: 2 },
                { id: 'fireThreshold', setting: 'fireThreshold', display: 'fireThresholdValue', decimals: 3 },
                { id: 'fireIntensity', setting: 'fireIntensity', display: 'fireIntensityValue', decimals: 1 },
                { id: 'maxParticles', setting: 'maxParticles', display: 'maxParticlesValue', decimals: 0 }
            ];

            controls.forEach(ctrl => {
                const slider = document.getElementById(ctrl.id);
                const display = document.getElementById(ctrl.display);

                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    physicsSettings[ctrl.setting] = value;
                    display.textContent = value.toFixed(ctrl.decimals);

                    // Send updated settings to server
                    if (ws && ws.readyState === WebSocket.OPEN && roomId) {
                        ws.send(JSON.stringify({
                            type: 'update_physics',
                            roomId: roomId,
                            physics: physicsSettings
                        }));
                    }
                });
            });
        }

        setupPhysicsControls();

        function connectToServer() {
            const serverUrl = defaultServerUrl;

            try {
                console.log('Connecting to:', serverUrl);

                ws = new WebSocket(serverUrl);

                // Timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        alert('‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.\n\n–°–µ—Ä–≤–µ—Ä Render –º–æ–∂–µ—Ç –ø—Ä–æ—Å—ã–ø–∞—Ç—å—Å—è (–ø–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–Ω–∏–º–∞–µ—Ç 30-60 —Å–µ–∫).\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.');
                        showScreen('settings');
                    }
                }, 60000); // 60 seconds timeout

                ws.onopen = () => {
                    clearTimeout(connectionTimeout);
                    console.log('‚úÖ Connected to server');

                    // Show mode selection UI
                    document.getElementById('connectionStatus').style.display = 'none';
                    document.getElementById('connectionModeSelect').style.display = 'block';
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå WebSocket error:', error);
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ Render: https://kinemon.onrender.com\n2. URL –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: ' + serverUrl + '\n3. –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
                    showScreen('settings');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    console.log('Disconnected from server. Code:', event.code, 'Reason:', event.reason);
                    showScreen('settings');

                    if (event.code !== 1000 && event.code !== 1001) {
                        alert('‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ.\n\nCode: ' + event.code);
                    }
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'room_created') {
                        // Room created, show QR code
                        roomId = data.roomId;

                        roomCodeDisplay.textContent = roomId;
                        roomIdInfo.textContent = roomId;

                        // Build controller URL with room, server, and game type parameters
                        // Add timestamp to bust browser cache on mobile devices
                        const baseUrl = window.location.origin + window.location.pathname.replace('display.html', 'controller.html');
                        const timestamp = Date.now();
                        const qrData = `${baseUrl}?room=${roomId}&game=${gameType}&server=${encodeURIComponent(serverUrl)}&t=${timestamp}`;

                        console.log('QR Code URL:', qrData);

                        // CRITICAL FIX (9th attempt - FINAL):
                        // Root cause: CSS was showing BOTH canvas AND img elements
                        // QRCode library creates canvas (for rendering) + img (visible QR)
                        // CSS at line 390 had "display: block !important" for BOTH
                        // Solution: Hide canvas, only show img (fixed in CSS)
                        const waitingQR = document.getElementById('waitingQRCode');

                        // ALWAYS clear container FIRST
                        waitingQR.innerHTML = '';

                        // Adaptive QR size based on screen resolution
                        const screenWidth = window.innerWidth;
                        const screenHeight = window.innerHeight;
                        let qrSize = 500; // Default for small screens (phones)

                        if (screenWidth >= 2560 || screenHeight >= 1440) {
                            qrSize = 250; // 4K projectors - very small
                        } else if (screenWidth >= 1920 || screenHeight >= 1080) {
                            qrSize = 300; // Full HD projectors - small
                        } else if (screenWidth >= 1024 || screenHeight >= 768) {
                            qrSize = 380; // Tablets/medium projectors
                        }

                        new QRCode(waitingQR, {
                            text: qrData,
                            width: qrSize,
                            height: qrSize,
                            colorDark: '#000000',
                            colorLight: '#ffffff',
                            correctLevel: QRCode.CorrectLevel.M
                        });

                        // Store QR data globally for later use (lobby/game screens)
                        window.persistentQRData = qrData;
                        window.persistentQRGenerated = false;

                        // Ensure persistentQR is hidden and empty on waiting screen
                        const persistentQR = document.getElementById('persistentQRDisplay');
                        if (persistentQR) {
                            persistentQR.innerHTML = '';
                            persistentQR.style.display = 'none';
                        }

                        showScreen('waiting');

                        // Join the room as display
                        ws.send(JSON.stringify({
                            type: 'join_display',
                            roomId: roomId,
                            gameType: gameType,
                            settings: gameSettings
                        }));

                    } else if (data.type === 'room_joined') {
                        // Joined existing room as spectator display
                        roomId = data.roomId;
                        gameType = data.gameType;
                        console.log('Joined room:', roomId, 'Game type:', gameType);

                        roomCodeDisplay.textContent = roomId;
                        roomIdInfo.textContent = roomId;

                        // Generate persistent QR data for spectator display (bottom-left QR)
                        const baseUrl = window.location.origin + window.location.pathname.replace('display.html', 'controller.html');
                        const qrData = `${baseUrl}?room=${roomId}&game=${gameType}&server=${encodeURIComponent(serverUrl)}`;
                        window.persistentQRData = qrData;
                        window.persistentQRGenerated = false;

                        // Determine which screen to show based on game state
                        if (data.gameState) {
                            gameState = data.gameState;

                            // Update canvas size if needed
                            if (gameState.canvas) {
                                canvas.width = gameState.canvas.width;
                                canvas.height = gameState.canvas.height;
                                scaleCanvasToScreen();
                            }

                            // Show appropriate screen based on game state
                            if (gameState.gameStarted) {
                                showScreen('game');
                            } else if (gameType === 'ship' && gameState.players && gameState.players.size > 0) {
                                showScreen('lobby');
                            } else {
                                showScreen('waiting');
                            }
                        } else {
                            showScreen('waiting');
                        }

                    } else if (data.type === 'error') {
                        console.error('Server error:', data.message);
                        alert('–û—à–∏–±–∫–∞: ' + data.message);
                        showScreen('settings');

                    } else if (data.type === 'init') {
                        logToServer('INFO', 'üîµ INIT received', {
                            gameType: gameType,
                            playersCount: data.gameState?.players?.length,
                            players: data.gameState?.players
                        });

                        gameState = data.gameState;

                        // Update canvas size from server
                        if (gameState.canvas) {
                            canvas.width = gameState.canvas.width;
                            canvas.height = gameState.canvas.height;
                            scaleCanvasToScreen(); // Scale after size update
                        }

                        updatePlayerCount();

                        // For non-Ship games: switch to game screen when first player joins
                        logToServer('INFO', 'üîç Check screen switch', {
                            gameType: gameType,
                            isNotShip: gameType !== 'ship',
                            playersLength: gameState.players?.length,
                            willSwitch: gameType !== 'ship' && gameState.players?.length > 0
                        });

                        if (gameType !== 'ship' && gameState.players && gameState.players.length > 0) {
                            logToServer('INFO', '‚úÖ Switching to game screen');
                            showScreen('game');
                        } else {
                            logToServer('INFO', '‚ùå NOT switching to game screen');
                        }

                    } else if (data.type === 'update') {
                        gameState = data.gameState;

                        // Update canvas size if it changed
                        if (gameState.canvas && (canvas.width !== gameState.canvas.width || canvas.height !== gameState.canvas.height)) {
                            canvas.width = gameState.canvas.width;
                            canvas.height = gameState.canvas.height;
                            scaleCanvasToScreen(); // Scale after size update
                        }

                        updatePlayerCount();

                        // For Ship game: show lobby instead of game until gameStarted
                        if (gameType === 'ship') {
                            if (gameState.players.length > 0 && !gameState.gameStarted) {
                                const lobbyScreen = document.getElementById('lobbyScreen');
                                if (!lobbyScreen.classList.contains('active')) {
                                    showScreen('lobby');
                                    document.getElementById('lobbyRoomCode').textContent = roomId;
                                }
                                updateLobbyTable(gameState);
                            } else if (gameState.gameStarted) {
                                const lobbyScreen = document.getElementById('lobbyScreen');
                                if (lobbyScreen.classList.contains('active')) {
                                    showScreen('game');
                                }
                                // Update team rosters during game
                                updateTeamRosters(gameState);
                            } else if (gameState.players.length === 0) {
                                showScreen('waiting');
                            }
                        } else {
                            // Other games: switch to game screen when first player joins
                            if (gameState.players.length > 0 && !canvas.classList.contains('active')) {
                                showScreen('game');
                            }

                            // Switch back to waiting screen if all players leave
                            if (gameState.players.length === 0 && canvas.classList.contains('active')) {
                                showScreen('waiting');
                            }
                        }
                    } else if (data.type === 'effect') {
                        handleEffect(data.effectType, data.data);
                    } else if (data.type === 'lobby_countdown') {
                        // Show countdown on lobby screen
                        const lobbyCountdownDisplay = document.getElementById('lobbyCountdownDisplay');
                        const lobbyCountdownNumber = document.getElementById('lobbyCountdownNumber');

                        if (lobbyCountdownDisplay && lobbyCountdownNumber) {
                            lobbyCountdownDisplay.style.display = 'block';

                            const startTime = data.startTime;
                            const duration = data.duration;

                            // Update countdown every 100ms for smooth display
                            window.lobbyCountdownInterval = setInterval(() => {
                                const elapsed = Date.now() - startTime;
                                const remaining = Math.max(0, duration - elapsed);
                                const count = Math.ceil(remaining / 1000);

                                lobbyCountdownNumber.textContent = count;

                                if (count === 0) {
                                    clearInterval(window.lobbyCountdownInterval);
                                    window.lobbyCountdownInterval = null;
                                    // Wait for update message with gameStarted=true
                                }
                            }, 100);
                        }
                    } else if (data.type === 'lobby_countdown_cancelled') {
                        // Hide countdown
                        const lobbyCountdownDisplay = document.getElementById('lobbyCountdownDisplay');
                        if (lobbyCountdownDisplay) {
                            lobbyCountdownDisplay.style.display = 'none';
                        }
                        // Stop countdown timer
                        if (window.lobbyCountdownInterval) {
                            clearInterval(window.lobbyCountdownInterval);
                            window.lobbyCountdownInterval = null;
                        }
                    } else if (data.type === 'game_restarted') {
                        // Game has been restarted
                        console.log('üîÑ Game restarted');

                        // Hide Ship-specific UI elements
                        const teamRosters = document.getElementById('teamRosters');
                        if (teamRosters) {
                            teamRosters.style.display = 'none';
                        }

                        // Return to appropriate screen
                        if (data.gameType === 'ship' && !data.preserveRoles) {
                            // Ship returned to lobby
                            showScreen('lobby');
                        } else {
                            // All other cases: go to game screen
                            showScreen('game');
                            canvas.classList.add('active');
                            canvas.style.display = 'block';

                            // Show/hide UI based on game type
                            if (data.gameType === 'ship' || data.gameType === 'pushers') {
                                // Team games use canvas scoreboard
                                roomInfo.style.display = 'none';
                                scoreboard.style.display = 'none';
                            } else {
                                // Individual games use right panel
                                roomInfo.style.display = 'block';
                                scoreboard.style.display = 'block';
                            }
                        }
                    } else if (data.type === 'show_game_selection') {
                        // Hide and clear canvas
                        canvas.classList.remove('active');
                        canvas.style.display = 'none';
                        roomInfo.style.display = 'none';
                        scoreboard.style.display = 'none';

                        // Show game selection screen
                        showScreen('gameSelection');

                        // Setup game selection buttons
                        const gameButtons = document.querySelectorAll('.game-select-btn');
                        gameButtons.forEach(btn => {
                            btn.onclick = () => {
                                const newGameType = btn.dataset.game;

                                ws.send(JSON.stringify({
                                    type: 'confirm_game_change',
                                    gameType: newGameType,
                                    settings: getDefaultSettingsForGame(newGameType)
                                }));
                            };
                        });

                        // Cancel button
                        document.getElementById('cancelGameChangeBtn').onclick = () => {
                            // Return to win screen
                            showWinScreen(gameState.winner, gameState.gameType);
                        };
                    } else if (data.type === 'room_migrated') {
                        // Room migrated to new game
                        roomId = data.newRoomId;
                        gameType = data.newGameType;

                        // Update UI
                        roomCodeDisplay.textContent = roomId;
                        roomIdInfo.textContent = roomId;

                        // Hide Ship game-specific UI elements
                        const teamRosters = document.getElementById('teamRosters');
                        if (teamRosters) {
                            teamRosters.style.display = 'none';
                        }

                        // Clear canvas immediately
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Show waiting screen until first update arrives
                        showScreen('waiting');
                        canvas.style.display = 'block'; // Re-enable canvas
                    } else if (data.type === 'update_qr_code') {
                        // Regenerate QR code for new room
                        const baseUrl = window.location.origin + window.location.pathname.replace('display.html', 'controller.html');
                        const timestamp = Date.now();
                        const qrData = `${baseUrl}?room=${data.roomId}&game=${data.gameType}&server=${encodeURIComponent(serverUrl)}&t=${timestamp}`;

                        // Update persistent QR data
                        window.persistentQRData = qrData;
                        window.persistentQRGenerated = false;
                        generatePersistentQR(qrData); // Regenerate QR with correct data

                        console.log(`QR code updated for new room ${data.roomId}, game ${data.gameType}`);

                        // Don't show screen here - wait for 'update' message with gameState
                        // The 'update' handler will show the correct screen based on gameState
                    }
                };
            } catch (error) {
                console.error('Connection error:', error);
                alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                showScreen('settings');
            }
        }

        function updatePlayerCount() {
            if (gameState) {
                playerCount.textContent = `–ò–≥—Ä–æ–∫–æ–≤: ${gameState.players.length}`;
            }
        }

        function updateLobbyTable(gameState) {
            if (!gameState || !gameState.players) return;

            const roleNames = {
                engine: '‚öôÔ∏è –¢—è–≥–∞',
                rudder: 'üß≠ –†—É–ª—å',
                weapon: 'üî´ –ü—É—à–∫–∞',
                weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                shield: 'üõ°Ô∏è –©–∏—Ç'
            };

            const roles = ['engine', 'rudder', 'weapon', 'weaponDirection', 'shield'];

            // Check if Ship game (always show dual tables for Ship game in v3.16+)
            const isDualShipMode = gameState.gameType === 'ship';

            if (isDualShipMode) {
                // Show dual team tables, hide single table
                document.getElementById('singleTeamTable').style.display = 'none';
                document.getElementById('dualTeamTables').style.display = 'block';

                // Update Blue Team Table
                const blueTeamTableBody = document.getElementById('blueTeamTableBody');
                if (blueTeamTableBody) {
                    blueTeamTableBody.innerHTML = '';
                    roles.forEach(role => {
                        const player = gameState.players.find(p => p.team === 'blue' && p.systemRole === role);

                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';

                        // Role cell
                        const roleCell = document.createElement('td');
                        roleCell.style.padding = '10px';
                        roleCell.textContent = roleNames[role];
                        row.appendChild(roleCell);

                        // Player cell
                        const playerCell = document.createElement('td');
                        playerCell.style.padding = '10px';
                        playerCell.textContent = player ? player.name : '‚Äî';
                        playerCell.style.color = player ? player.color : '#666';
                        row.appendChild(playerCell);

                        // Status cell
                        const statusCell = document.createElement('td');
                        statusCell.style.padding = '10px';
                        statusCell.style.textAlign = 'center';
                        statusCell.style.fontSize = '20px';
                        statusCell.textContent = player && player.ready ? '‚úÖ' : '‚Äî';
                        statusCell.style.color = player && player.ready ? '#4CAF50' : '#666';
                        row.appendChild(statusCell);

                        blueTeamTableBody.appendChild(row);
                    });
                }

                // Update Pink Team Table
                const pinkTeamTableBody = document.getElementById('pinkTeamTableBody');
                if (pinkTeamTableBody) {
                    pinkTeamTableBody.innerHTML = '';
                    roles.forEach(role => {
                        const player = gameState.players.find(p => p.team === 'pink' && p.systemRole === role);

                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';

                        // Role cell
                        const roleCell = document.createElement('td');
                        roleCell.style.padding = '10px';
                        roleCell.textContent = roleNames[role];
                        row.appendChild(roleCell);

                        // Player cell
                        const playerCell = document.createElement('td');
                        playerCell.style.padding = '10px';
                        playerCell.textContent = player ? player.name : '‚Äî';
                        playerCell.style.color = player ? player.color : '#666';
                        row.appendChild(playerCell);

                        // Status cell
                        const statusCell = document.createElement('td');
                        statusCell.style.padding = '10px';
                        statusCell.style.textAlign = 'center';
                        statusCell.style.fontSize = '20px';
                        statusCell.textContent = player && player.ready ? '‚úÖ' : '‚Äî';
                        statusCell.style.color = player && player.ready ? '#4CAF50' : '#666';
                        row.appendChild(statusCell);

                        pinkTeamTableBody.appendChild(row);
                    });
                }
            } else {
                // Single table mode (legacy or non-dual-ship games)
                document.getElementById('singleTeamTable').style.display = 'table';
                document.getElementById('dualTeamTables').style.display = 'none';

                const lobbyTableBody = document.getElementById('lobbyTableBody');
                if (lobbyTableBody) {
                    lobbyTableBody.innerHTML = '';

                    roles.forEach(role => {
                        const player = gameState.players.find(p => p.systemRole === role);

                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';

                        // Role cell
                        const roleCell = document.createElement('td');
                        roleCell.style.padding = '12px';
                        roleCell.textContent = roleNames[role];
                        row.appendChild(roleCell);

                        // Player cell
                        const playerCell = document.createElement('td');
                        playerCell.style.padding = '12px';
                        playerCell.textContent = player ? player.name : '‚Äî';
                        playerCell.style.color = player ? player.color : '#666';
                        row.appendChild(playerCell);

                        // Status cell
                        const statusCell = document.createElement('td');
                        statusCell.style.padding = '12px';
                        statusCell.style.textAlign = 'center';
                        statusCell.style.fontSize = '24px';
                        statusCell.textContent = player && player.ready ? '‚úì' : '‚úó';
                        statusCell.style.color = player && player.ready ? '#4CAF50' : '#FF5252';
                        row.appendChild(statusCell);

                        lobbyTableBody.appendChild(row);
                    });
                }
            }
        }

        // Update in-game team rosters
        function updateTeamRosters(gameState) {
            if (!gameState || gameState.gameType !== 'ship') return;

            const teamRosters = document.getElementById('teamRosters');
            if (!teamRosters) return;

            // Show rosters only during game
            if (gameState.gameStarted && gameState.players && gameState.players.length > 0) {
                teamRosters.style.display = 'flex';

                const roleNames = {
                    engine: '‚öôÔ∏è –¢—è–≥–∞',
                    rudder: 'üß≠ –†—É–ª—å',
                    weapon: 'üî´ –ü—É—à–∫–∞',
                    weaponDirection: 'üéØ –ü—Ä–∏—Ü–µ–ª',
                    shield: 'üõ°Ô∏è –©–∏—Ç'
                };

                const roles = ['engine', 'rudder', 'weapon', 'weaponDirection', 'shield'];

                // Update coin counts
                const blueCoins = gameState.ships && gameState.ships.blue ? (gameState.ships.blue.coins || 0) : 0;
                const pinkCoins = gameState.ships && gameState.ships.pink ? (gameState.ships.pink.coins || 0) : 0;
                const targetCoins = gameState.coinsToWin || 10;

                // v3.17: Build booster indicators
                let blueBoostersText = '';
                let pinkBoostersText = '';

                if (gameState.ships && gameState.ships.blue && gameState.ships.blue.boosters) {
                    const boosters = gameState.ships.blue.boosters;
                    if (boosters.extraBullets > 0) blueBoostersText += ` üîπ√ó${boosters.extraBullets}`;
                    if (boosters.laserSight) blueBoostersText += ` üî¥üéØ`;
                    if (boosters.attackShield.active) blueBoostersText += ` üõ°Ô∏è‚ö°${boosters.attackShield.sizeBonus}%`;
                    if (boosters.attackEngine.active) blueBoostersText += ` üî•Lv${boosters.attackEngine.level}`;
                }

                if (gameState.ships && gameState.ships.pink && gameState.ships.pink.boosters) {
                    const boosters = gameState.ships.pink.boosters;
                    if (boosters.extraBullets > 0) pinkBoostersText += ` üîπ√ó${boosters.extraBullets}`;
                    if (boosters.laserSight) pinkBoostersText += ` üî¥üéØ`;
                    if (boosters.attackShield.active) pinkBoostersText += ` üõ°Ô∏è‚ö°${boosters.attackShield.sizeBonus}%`;
                    if (boosters.attackEngine.active) pinkBoostersText += ` üî•Lv${boosters.attackEngine.level}`;
                }

                document.getElementById('blueCoinsDisplay').textContent = `${blueCoins}/${targetCoins}${blueBoostersText}`;
                document.getElementById('pinkCoinsDisplay').textContent = `${pinkCoins}/${targetCoins}${pinkBoostersText}`;

                // Update Blue team roster
                const blueTeamRoster = document.getElementById('blueTeamRoster');
                blueTeamRoster.innerHTML = '';
                roles.forEach(role => {
                    const player = gameState.players.find(p => p.team === 'blue' && p.systemRole === role);
                    const roleDiv = document.createElement('div');
                    roleDiv.style.padding = '4px 0';
                    roleDiv.style.fontSize = '14px';
                    roleDiv.style.whiteSpace = 'nowrap';
                    // Show "–ê–≤—Ç–æ–ø–∏–ª–æ—Ç" only if autopilot is enabled
                    const emptySlot = gameState.autopilotEnabled
                        ? '<span style="opacity: 0.6">ü§ñ –ê–≤—Ç–æ–ø–∏–ª–æ—Ç</span>'
                        : '<span style="opacity: 0.4">‚Äî</span>';
                    roleDiv.innerHTML = `${roleNames[role]}: ${player ? player.name : emptySlot}`;
                    blueTeamRoster.appendChild(roleDiv);
                });

                // Update Pink team roster
                const pinkTeamRoster = document.getElementById('pinkTeamRoster');
                pinkTeamRoster.innerHTML = '';
                roles.forEach(role => {
                    const player = gameState.players.find(p => p.team === 'pink' && p.systemRole === role);
                    const roleDiv = document.createElement('div');
                    roleDiv.style.padding = '4px 0';
                    roleDiv.style.fontSize = '14px';
                    roleDiv.style.whiteSpace = 'nowrap';
                    // Show "–ê–≤—Ç–æ–ø–∏–ª–æ—Ç" only if autopilot is enabled
                    const emptySlot = gameState.autopilotEnabled
                        ? '<span style="opacity: 0.6">ü§ñ –ê–≤—Ç–æ–ø–∏–ª–æ—Ç</span>'
                        : '<span style="opacity: 0.4">‚Äî</span>';
                    roleDiv.innerHTML = `${roleNames[role]}: ${player ? player.name : emptySlot}`;
                    pinkTeamRoster.appendChild(roleDiv);
                });
            } else {
                teamRosters.style.display = 'none';
            }
        }

        // Visual effects handlers
        function handleEffect(effectType, data) {
            switch (effectType) {
                case 'particle':
                    // For Ballz, data.x and data.y are relative (0-1), need conversion
                    // Store field dimensions for conversion (set in drawBallzGame)
                    if (gameType === 'ballz' && window.ballzFieldDimensions) {
                        const fieldWidth = window.ballzFieldDimensions.fieldWidth;
                        const fieldHeight = window.ballzFieldDimensions.fieldHeight;
                        const offsetX = window.ballzFieldDimensions.offsetX;
                        const offsetY = window.ballzFieldDimensions.offsetY;
                        // Convert relative to pixel coordinates
                        const pixelX = data.x * fieldWidth + offsetX;
                        const pixelY = data.y * fieldHeight + offsetY;
                        spawnParticles(pixelX, pixelY, data.color, data.count || 15);
                    } else {
                        spawnParticles(data.x, data.y, data.color, data.count || 15);
                    }
                    break;
                case 'flash':
                    triggerFlash(data.color, data.intensity || 0.3);
                    break;
                case 'shake':
                    triggerShake(data.intensity || 3);
                    break;
                case 'scoreAnim':
                    spawnScoreAnimation(data.x, data.y, data.text, data.color);
                    break;
                case 'sound':
                    console.log('Sound:', data.sound);
                    break;
            }
        }

        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 2 + Math.random() * 3;
                effects.particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3,
                    color: color,
                    alpha: 1.0,
                    lifetime: 0.4 + Math.random() * 0.3,
                    age: 0
                });
            }
        }

        function triggerFlash(color, intensity) {
            effects.flash = {
                active: true,
                color: color,
                alpha: intensity,
                startTime: Date.now(),
                duration: 200
            };
        }

        function triggerShake(intensity) {
            effects.screenShake = {
                active: true,
                intensity: intensity,
                duration: 200,
                startTime: Date.now(),
                offsetX: 0,
                offsetY: 0
            };
        }

        function spawnScoreAnimation(x, y, text, color) {
            effects.scoreAnims.push({
                x: x, y: y,
                text: text,
                color: color,
                alpha: 1.0,
                lifetime: 2.0,  // Doubled from 1.0 to 2.0 seconds for better readability
                age: 0
            });
        }

        function updateEffects() {
            const deltaTime = 1/60;

            // Update particles
            for (let i = effects.particles.length - 1; i >= 0; i--) {
                const p = effects.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.age += deltaTime;
                p.alpha = 1.0 - (p.age / p.lifetime);
                if (p.age >= p.lifetime) {
                    effects.particles.splice(i, 1);
                }
            }

            // Update screen shake
            if (effects.screenShake.active) {
                const elapsed = Date.now() - effects.screenShake.startTime;
                if (elapsed >= effects.screenShake.duration) {
                    effects.screenShake.active = false;
                    effects.screenShake.offsetX = 0;
                    effects.screenShake.offsetY = 0;
                } else {
                    const int = effects.screenShake.intensity;
                    effects.screenShake.offsetX = (Math.random() - 0.5) * int * 2;
                    effects.screenShake.offsetY = (Math.random() - 0.5) * int * 2;
                }
            }

            // Update flash
            if (effects.flash.active) {
                const elapsed = Date.now() - effects.flash.startTime;
                const progress = elapsed / effects.flash.duration;
                effects.flash.alpha = effects.flash.alpha * (1 - progress);
                if (elapsed >= effects.flash.duration) {
                    effects.flash.active = false;
                }
            }

            // Update score animations
            for (let i = effects.scoreAnims.length - 1; i >= 0; i--) {
                const anim = effects.scoreAnims[i];
                anim.y -= 1.5;
                anim.age += deltaTime;
                anim.alpha = 1.0 - (anim.age / anim.lifetime);
                if (anim.age >= anim.lifetime) {
                    effects.scoreAnims.splice(i, 1);
                }
            }
        }

        function render() {
            if (!gameState) return;

            // Check for game over (only if we're on the game screen)
            if (gameState.gameOver && gameState.winner) {
                const winScreen = document.getElementById('winScreen');
                const gameSelectionScreen = document.getElementById('gameSelectionScreen');

                // CRITICAL FIX: Don't interfere if game selection screen is active
                // User clicked "Change Game" button and selection screen must remain visible
                if (gameSelectionScreen && gameSelectionScreen.classList.contains('active')) {
                    // Game selection screen is active - don't render anything, just return
                    return;
                }

                // For Ballz: render leaderboard instead of win screen
                if (gameState.gameType === 'ballz' && gameState.leaderboard) {
                    renderBallzLeaderboard();
                    return;
                }

                // Only show win screen if not already on win/selection screens
                if (!winScreen.classList.contains('active')) {
                    showWinScreen(gameState.winner, gameState.gameType);
                }
                return;
            }

            // Manage Pong score display visibility
            const pongScores = document.getElementById('pongScores');
            if (pongScores) {
                pongScores.style.display = gameState.gameType === 'pong' ? 'block' : 'none';
            }

            if (gameState.gameType === 'pong') {
                renderPong();
            } else if (gameState.gameType === 'pushers') {
                renderPushers();
            } else if (gameState.gameType === 'ship') {
                renderShip();
            } else if (gameState.gameType === 'ballz') {
                renderBallz();
            } else {
                renderSnake();
            }

            // Update scoreboard
            updateScoreboard();
        }

        function showWinScreen(winner, gameType) {
            // Set winner name and message
            if (gameType === 'pushers') {
                document.getElementById('winnerName').textContent = `–ö–æ–º–∞–Ω–¥–∞ ${winner.team}`;
                document.getElementById('winMessage').textContent = `–ü–æ–±–µ–¥–∏–ª–∞ —Å ${winner.score} —Å–º–∞–π–ª–∏–∫–∞–º–∏!`;
            } else if (gameType === 'ship') {
                document.getElementById('winnerName').textContent = winner.team || '–≠–∫–∏–ø–∞–∂ –∫–æ—Ä–∞–±–ª—è';
                document.getElementById('winMessage').textContent = `–°–æ–±—Ä–∞–ª ${winner.score} –º–æ–Ω–µ—Ç!`;
            } else if (gameType === 'ballz') {
                document.getElementById('winnerName').textContent = winner.name;
                document.getElementById('winMessage').textContent = `Score: ${winner.score} | –•–æ–¥–æ–≤: ${winner.turnNumber}`;
            } else {
                document.getElementById('winnerName').textContent = winner.name;
                if (gameType === 'pong') {
                    document.getElementById('winMessage').textContent = `–ü–æ–±–µ–¥–∞ —Å–æ —Å—á—ë—Ç–æ–º ${winner.score}!`;
                } else {
                    document.getElementById('winMessage').textContent = `–°–æ–±—Ä–∞–ª ${winner.score} –∑–≤—ë–∑–¥!`;
                }
            }

            // Show win screen
            showScreen('win');

            // Hide game elements
            canvas.classList.remove('active');
            roomInfo.style.display = 'none';
            scoreboard.style.display = 'none';

            // Setup replay buttons
            const shipRoleChoice = document.getElementById('shipRoleChoice');
            const mainActions = document.getElementById('mainActions');
            const replayBtn = document.getElementById('replayBtn');

            if (gameType === 'ship') {
                // For Ship: show role choice, hide regular replay button
                shipRoleChoice.style.display = 'block';
                replayBtn.style.display = 'none';

                document.getElementById('keepRolesBtn').onclick = () => {
                    ws.send(JSON.stringify({
                        type: 'restart_game',
                        preserveRoles: true
                    }));
                };

                document.getElementById('changeRolesBtn').onclick = () => {
                    ws.send(JSON.stringify({
                        type: 'restart_game',
                        preserveRoles: false
                    }));
                };
            } else {
                // Other games: show regular replay button
                shipRoleChoice.style.display = 'none';
                replayBtn.style.display = 'inline-block';

                replayBtn.onclick = () => {
                    ws.send(JSON.stringify({
                        type: 'restart_game'
                    }));
                };
            }

            // Change game button (for all games)
            document.getElementById('changeGameBtn').onclick = () => {
                ws.send(JSON.stringify({
                    type: 'request_game_change'
                }));
            };
        }

        function renderPong() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.strokeStyle = '#333';
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Show waiting message if game hasn't started
            if (!gameState.gameStarted) {
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞...', canvas.width / 2, canvas.height / 2);

                ctx.font = '20px sans-serif';
                ctx.fillStyle = '#888';
                ctx.fillText(`–ü–æ–¥–∫–ª—é—á–µ–Ω–æ: ${gameState.players.length}/2`, canvas.width / 2, canvas.height / 2 + 50);
            }

            // Draw ball (hide during celebration blink)
            if (gameState.ball && (!gameState.goalCelebration || gameState.goalCelebration.ballVisible)) {
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw paddles
            const paddleWidth = 10;
            for (const player of gameState.players) {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.paddleX, player.paddleY, paddleWidth, gameState.paddleSize);
            }

            // SLOW-MO OVERLAY during goal celebration
            if (gameState.goalCelebration) {
                const elapsed = Date.now() - gameState.goalCelebration.startTime;
                const progress = Math.min(1, elapsed / gameState.goalCelebration.duration);

                // Dark overlay with pulsing effect
                const pulseAlpha = 0.3 + Math.sin(elapsed / 100) * 0.1;
                ctx.fillStyle = `rgba(0, 0, 0, ${pulseAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Radial gradient effect from center
                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                const victimColor = gameState.goalCelebration.victimPlayer?.color || '#FFFFFF';
                gradient.addColorStop(0, `${victimColor}00`); // Transparent center
                gradient.addColorStop(0.5, `${victimColor}20`); // Semi-transparent
                gradient.addColorStop(1, `${victimColor}40`); // More opaque at edges

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // SLOW-MO text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 60px sans-serif';
                ctx.textAlign = 'center';
                ctx.globalAlpha = 0.8;
                ctx.fillText('–ì–û–û–û–õ!', canvas.width / 2, canvas.height / 2 - 50);

                // Progress bar
                const barWidth = 400;
                const barHeight = 10;
                const barX = (canvas.width - barWidth) / 2;
                const barY = canvas.height / 2 + 30;

                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                ctx.fillStyle = victimColor;
                ctx.fillRect(barX, barY, barWidth * progress, barHeight);

                ctx.globalAlpha = 1.0;
            }

            ctx.restore();

            // Render visual effects
            // Particles
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Flash
            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Score animations
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;

            // Update HTML score display
            updatePongScoreDisplay();
        }

        function renderSnake() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bottom boundary
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 40);
            ctx.lineTo(canvas.width, canvas.height - 40);
            ctx.stroke();

            // Get dynamic sizes from server (with defaults)
            const pizzaSize = gameState.pizzaSize || 18;
            const segmentSize = gameState.segmentSize || 15;
            const pizzaRadius = pizzaSize / 2;
            const segmentRadius = segmentSize / 2;

            // Draw stardust particles (was pizzas)
            // Neon color palette
            const neonColors = [
                '#FF006E', // Hot pink
                '#8338EC', // Purple
                '#3A86FF', // Blue
                '#FFBE0B', // Yellow
                '#FB5607', // Orange
                '#06FFA5', // Cyan
                '#FF006E', // Magenta
                '#00F5FF', // Bright cyan
                '#CCFF00', // Lime
                '#FF1744'  // Red
            ];

            for (const pizza of gameState.pizzas) {
                // Assign consistent color based on pizza ID
                const colorIndex = (pizza.id ? String(pizza.id).split('').reduce((sum, char) => sum + char.charCodeAt(0), 0) : Math.floor(Math.random() * neonColors.length)) % neonColors.length;
                const color = neonColors[colorIndex];

                // Draw glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;

                // Draw stardust particle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pizza.x, pizza.y, pizzaRadius, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow for next draw
                ctx.shadowBlur = 0;
            }

            // Draw all players
            for (const player of gameState.players) {
                if (!player.alive) continue;

                // Draw body segments
                ctx.fillStyle = player.color;
                for (let i = 1; i < player.segments.length; i++) {
                    const seg = player.segments[i];
                    ctx.beginPath();
                    ctx.arc(seg.x, seg.y, segmentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw head
                const head = player.segments[0];
                ctx.save();
                ctx.translate(head.x, head.y);
                ctx.rotate(player.angle);

                // Head circle (lighter color)
                const headColor = lightenColor(player.color, 20);
                ctx.fillStyle = headColor;
                ctx.beginPath();
                ctx.arc(0, 0, segmentRadius, 0, Math.PI * 2);
                ctx.fill();

                // Eyes (white) - scaled proportionally
                const eyeRadius = segmentRadius * 0.27;
                const eyeOffsetX = segmentRadius * 0.53;
                const eyeOffsetY = segmentRadius * 0.4;
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (black) - scaled proportionally
                const pupilRadius = segmentRadius * 0.11;
                const pupilOffsetX = segmentRadius * 0.6;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(pupilOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.arc(pupilOffsetX, eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // –°—Ç—Ä–µ–ª–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ arrow_steering –∏ arrow_instant
                if ((player.controlScheme === 'arrow_steering' || player.controlScheme === 'arrow_instant') && player.targetAngle !== undefined) {
                    const head = player.segments[0];

                    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ–Ω–∫–æ–π –ª–∏–Ω–∏–∏ —Å–æ —Å–≤–µ—á–µ–Ω–∏–µ–º
                    const arrowDistance = segmentSize * 1.5;  // –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è –±–ª–∏–∂–µ –∫ –≥–æ–ª–æ–≤–µ
                    const arrowLength = segmentSize * 3.0;    // –î–ª–∏–Ω–Ω–µ–µ –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏

                    // –ü–æ–∑–∏—Ü–∏—è –Ω–∞—á–∞–ª–∞ –ª–∏–Ω–∏–∏ (–æ—Ç –≥–æ–ª–æ–≤—ã)
                    const arrowStartX = head.x + Math.cos(player.targetAngle) * arrowDistance;
                    const arrowStartY = head.y + Math.sin(player.targetAngle) * arrowDistance;

                    // –ü–æ–∑–∏—Ü–∏—è –∫–æ–Ω—Ü–∞ –ª–∏–Ω–∏–∏
                    const arrowEndX = arrowStartX + Math.cos(player.targetAngle) * arrowLength;
                    const arrowEndY = arrowStartY + Math.sin(player.targetAngle) * arrowLength;

                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = player.color;
                    ctx.lineWidth = 2;  // –¢–æ–Ω–∫–∞—è –ª–∏–Ω–∏—è
                    ctx.lineCap = 'round';

                    // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = player.color;

                    // –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é
                    ctx.beginPath();
                    ctx.moveTo(arrowStartX, arrowStartY);
                    ctx.lineTo(arrowEndX, arrowEndY);
                    ctx.stroke();

                    ctx.restore();
                }

                // Draw player name above head
                ctx.fillStyle = player.color;
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, head.x, head.y - segmentRadius - 5);
            }

            // Draw respawn countdown for dead players
            for (const player of gameState.players) {
                if (player.alive || !player.respawnCountdown || !player.respawnPosition) continue;

                const x = player.respawnPosition.x;
                const y = player.respawnPosition.y;
                const countdown = Math.ceil(player.respawnCountdown); // 3, 2, 1

                // Pulsing glow effect
                const pulseScale = 1 + Math.sin(Date.now() / 100) * 0.1;

                // Draw glow circle
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = player.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = player.color;
                ctx.beginPath();
                ctx.arc(x, y, 50 * pulseScale, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Draw countdown number
                ctx.fillStyle = player.color;
                ctx.font = 'bold 72px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 15;
                ctx.shadowColor = player.color;
                ctx.fillText(countdown.toString(), x, y);
                ctx.shadowBlur = 0;

                // Draw player name below
                ctx.font = 'bold 20px sans-serif';
                ctx.fillText(player.name, x, y + 50);
            }
        }

        function updatePongScoreDisplay() {
            const pongScores = document.getElementById('pongScores');
            if (!pongScores || !gameState.players) return;

            const leftPlayer = gameState.players.find(p => p.side === 'left');
            const rightPlayer = gameState.players.find(p => p.side === 'right');

            if (leftPlayer) {
                const leftName = document.getElementById('pongLeftName');
                const leftScore = document.getElementById('pongLeftScore');
                if (leftName && leftScore) {
                    leftName.textContent = leftPlayer.name;
                    leftName.style.color = leftPlayer.color;
                    leftScore.textContent = leftPlayer.score;
                    leftScore.style.color = leftPlayer.color;
                }
            }

            if (rightPlayer) {
                const rightName = document.getElementById('pongRightName');
                const rightScore = document.getElementById('pongRightScore');
                if (rightName && rightScore) {
                    rightName.textContent = rightPlayer.name;
                    rightName.style.color = rightPlayer.color;
                    rightScore.textContent = rightPlayer.score;
                    rightScore.style.color = rightPlayer.color;
                }
            }
        }

        function renderPushers() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Dark background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Field border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Center grid (dashed lines for orientation)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw skulls at corners
            if (gameState.skulls) {
                for (const skull of gameState.skulls) {
                    // Red glow for skull
                    ctx.fillStyle = '#F44336';
                    ctx.font = `${gameState.skullSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', skull.x, skull.y);
                }
            }

            // Draw ghosts
            if (gameState.ghosts) {
                for (const ghost of gameState.ghosts) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = `${gameState.ghostSize || 30}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëª', ghost.x, ghost.y);
                }
            }

            // Draw smiley
            if (gameState.smiley) {
                ctx.fillStyle = '#FFF';
                ctx.font = `${gameState.smileySize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üòä', gameState.smiley.x, gameState.smiley.y);
            }

            // Draw player squares
            if (gameState.players) {
                const renderedSquares = new Set(); // Track rendered team squares in single-square mode

                for (const player of gameState.players) {
                    const halfSize = gameState.squareSize / 2;

                    // In single-square mode, render only one square per team
                    if (gameState.singleSquareMode) {
                        if (renderedSquares.has(player.team)) {
                            continue; // Skip duplicate team
                        }
                        renderedSquares.add(player.team);
                    }

                    // Blinking effect for invulnerable players
                    if (player.invulnerable) {
                        // Blink every 200ms (5 times per second)
                        const blinkInterval = 200;
                        const currentTime = Date.now();
                        const isVisible = Math.floor(currentTime / blinkInterval) % 2 === 0;

                        if (!isVisible) {
                            continue; // Skip rendering this frame
                        }
                    }

                    // Draw square
                    ctx.fillStyle = player.color;
                    ctx.fillRect(
                        player.x - halfSize,
                        player.y - halfSize,
                        gameState.squareSize,
                        gameState.squareSize
                    );

                    // Draw label above square
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    if (gameState.singleSquareMode) {
                        // Show team name in single-square mode
                        ctx.fillText(player.team, player.x, player.y - halfSize - 5);
                    } else {
                        // Show player name in normal mode
                        ctx.fillText(player.name, player.x, player.y - halfSize - 5);
                    }

                    // Draw axis indicator below square (only in normal mode)
                    if (!gameState.singleSquareMode) {
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(player.axis, player.x, player.y + halfSize + 3);
                    }
                }
            }

            // Draw team scoreboard in top left corner (always show for Pushers)
            if (gameState.teamScores) {
                const teams = [
                    { name: 'Blue', color: '#2196F3' },
                    { name: 'Red', color: '#F44336' },
                    { name: 'Yellow', color: '#FFEB3B' },
                    { name: 'Green', color: '#4CAF50' },
                    { name: 'White', color: '#FFFFFF' }
                ];

                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                let y = 15;
                for (const team of teams) {
                    const score = gameState.teamScores[team.name] || 0;

                    // Show team if it has any players
                    const hasPlayers = gameState.players && gameState.players.some(p => p.team === team.name);

                    if (hasPlayers) {
                        ctx.fillStyle = team.color;
                        const winScore = gameState.winScore || 15;
                        ctx.fillText(`${team.name}: ${score}/${winScore}`, 15, y);
                        y += 20;
                    }
                }
            }

            ctx.restore();

            // Render visual effects
            // Particles
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Flash
            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Score animations
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        // Helper function for Ship rendering
        function getSystemPosition(ship, rotation) {
            const angle = rotation * Math.PI / 180;
            return {
                x: ship.x + Math.cos(angle) * ship.radius,
                y: ship.y + Math.sin(angle) * ship.radius
            };
        }

        // Unified function to render ship systems (engine, shield, weapon)
        // Works for both blue and pink ships by accepting systems as parameter
        function renderShipSystems(ship, systems, teamColor) {
            if (!systems) return;

            // 1. Energy Progress Bar (gradient thrust system)
            if (gameState.thrustSystem === 'gradient' && systems.engine) {
                const energy = systems.engine.energy || 0;
                if (energy > 0) {
                    const colors = [
                        { color: '#00BFFF', start: 0, end: 150 },      // Blue
                        { color: '#00FF00', start: 150, end: 300 },    // Green
                        { color: '#FFFF00', start: 300, end: 450 },    // Yellow
                        { color: '#FFA500', start: 450, end: 600 },    // Orange
                        { color: '#FF0000', start: 600, end: 750 }     // Red
                    ];

                    ctx.lineWidth = 8;
                    const innerRadius = ship.radius - 10;

                    colors.forEach((level, index) => {
                        if (energy > level.start) {
                            const levelEnergy = Math.min(energy, level.end) - level.start;
                            const levelProgress = levelEnergy / (level.end - level.start);
                            const segmentArc = (Math.PI * 2 / 5);
                            const arcLength = segmentArc * levelProgress;
                            const startAngle = -Math.PI / 2 + (index * segmentArc);
                            const endAngle = startAngle + arcLength;

                            ctx.strokeStyle = level.color;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = level.color;
                            ctx.beginPath();
                            ctx.arc(ship.x, ship.y, innerRadius, startAngle, endAngle);
                            ctx.stroke();
                        }
                    });

                    ctx.shadowBlur = 0;
                }
            }

            // 2. Shield Arc
            if (systems.shield && systems.shield.active) {
                ctx.save();
                const shieldRot = systems.shield.rotation * Math.PI / 180;
                let arcSize = systems.shield.arcSize * Math.PI / 180;

                // Check boosters for this team
                if (gameState.ships[teamColor] && gameState.ships[teamColor].boosters && gameState.ships[teamColor].boosters.attackShield && gameState.ships[teamColor].boosters.attackShield.active) {
                    const sizeBonus = gameState.ships[teamColor].boosters.attackShield.sizeBonus || 0;
                    arcSize *= (1 + sizeBonus / 100);
                }

                const shieldRadius = ship.radius + 15;
                const shieldStartAngle = shieldRot - arcSize / 2;
                const shieldEndAngle = shieldRot + arcSize / 2;

                ctx.globalAlpha = 0.4 + 0.1 * Math.sin(Date.now() / 200);
                const shieldColor = teamColor === 'blue' ? '#00BFFF' : '#E91E63';
                ctx.strokeStyle = shieldColor;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 15;
                ctx.shadowColor = shieldColor;

                ctx.beginPath();
                ctx.arc(ship.x, ship.y, shieldRadius, shieldStartAngle, shieldEndAngle);
                ctx.stroke();

                // Shield edges (bright dots)
                [shieldStartAngle, shieldEndAngle].forEach(angle => {
                    ctx.fillStyle = shieldColor;
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(
                        ship.x + Math.cos(angle) * shieldRadius,
                        ship.y + Math.sin(angle) * shieldRadius,
                        4, 0, Math.PI * 2
                    );
                    ctx.fill();
                });

                ctx.restore();
            }

            // 3. Engine (turbine + fire particles)
            const enginePos = getSystemPosition(ship, systems.rudder.rotation);
            const engineAngle = systems.rudder.rotation * Math.PI / 180;

            // Draw turbine
            ctx.save();
            ctx.translate(enginePos.x, enginePos.y);
            ctx.rotate(engineAngle);
            ctx.fillStyle = '#666';
            ctx.fillRect(-10, -6, 20, 12);
            ctx.fillStyle = '#444';
            ctx.fillRect(-10, -4, 20, 8);
            ctx.restore();

            // Fire particles (based on engine energy/amplitude)
            const engineEnergy = systems.engine ? (systems.engine.energy || 0) : 0;
            const engineAmplitude = systems.engine ? (systems.engine.amplitude || 0) : 0;
            const engineActive = engineEnergy > 0 || engineAmplitude > 0;
            const thrustIntensity = Math.max(engineEnergy / 750, engineAmplitude);

            if (engineActive && thrustIntensity > 0.05) {
                // Fire direction is opposite to ship movement (reactive thrust)
                const movementAngle = Math.atan2(ship.vy || 0, ship.vx || 0);
                const thrustAngle = movementAngle + Math.PI; // Opposite to movement direction
                const particleCount = Math.max(2, Math.floor(physicsSettings.maxParticles * thrustIntensity));

                // Gradient bonus
                let flameSizeBonus = 1.0;
                if (gameState.thrustSystem === 'gradient' && gameState.energyLevel) {
                    flameSizeBonus = 1.0 + (gameState.energyLevel * 0.05);
                }

                for (let i = 0; i < particleCount; i++) {
                    const dist = 15 + i * 12 + Math.random() * 5;
                    const spread = (Math.random() - 0.5) * 0.3;
                    const x = enginePos.x + Math.cos(thrustAngle + spread) * dist;
                    const y = enginePos.y + Math.sin(thrustAngle + spread) * dist;
                    const alpha = (1 - i / particleCount) * 0.9 * Math.min(thrustIntensity, 1);
                    const hue = 30 + Math.random() * 30;
                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                    ctx.beginPath();
                    const baseRadius = Math.max(1, 8 - i * 1.5);
                    const radius = baseRadius * flameSizeBonus;
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 4. Weapon Charging Cone
            if (systems.weapon && systems.weapon.energy > 0 && systems.weaponDirection) {
                const weaponPos = getSystemPosition(ship, systems.weaponDirection.rotation);
                const weaponAngle = systems.weaponDirection.rotation * Math.PI / 180;

                const energy = systems.weapon.energy;
                const powerLevel = Math.max(1, Math.min(10, Math.ceil(energy)));
                const futureSize = 4 + (powerLevel - 1) * (12 / 9);

                const coneLength = 80;
                const coneStartWidth = futureSize * 0.5;
                const coneEndWidth = futureSize * 1.5;

                ctx.save();
                ctx.translate(weaponPos.x, weaponPos.y);
                ctx.rotate(weaponAngle);

                const gradient = ctx.createLinearGradient(0, 0, coneLength, 0);
                const fillPercent = Math.min(energy / 10, 1);

                gradient.addColorStop(0, '#00FFFF');
                if (fillPercent > 0.2) gradient.addColorStop(0.2, '#00FF00');
                if (fillPercent > 0.4) gradient.addColorStop(0.4, '#FFFF00');
                if (fillPercent > 0.6) gradient.addColorStop(0.6, '#FFA500');
                if (fillPercent > 0.8) gradient.addColorStop(0.8, '#FF0000');

                gradient.addColorStop(fillPercent, fillPercent >= 0.8 ? '#FF0000' :
                                                   fillPercent >= 0.6 ? '#FFA500' :
                                                   fillPercent >= 0.4 ? '#FFFF00' :
                                                   fillPercent >= 0.2 ? '#00FF00' : '#00FFFF');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, -coneStartWidth);
                ctx.lineTo(coneLength, -coneEndWidth);
                ctx.lineTo(coneLength, coneEndWidth);
                ctx.lineTo(0, coneStartWidth);
                ctx.closePath();
                ctx.fill();

                const outlineColor = fillPercent >= 0.8 ? '#FF0000' :
                                    fillPercent >= 0.6 ? '#FFA500' :
                                    fillPercent >= 0.4 ? '#FFFF00' :
                                    fillPercent >= 0.2 ? '#00FF00' : '#00FFFF';
                ctx.strokeStyle = outlineColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // 5. Weapon Physical Render (cannon)
            if (systems.weaponDirection) {
                const weaponPos = getSystemPosition(ship, systems.weaponDirection.rotation);
                const weaponAngle = systems.weaponDirection.rotation * Math.PI / 180;

                ctx.save();
                ctx.translate(weaponPos.x, weaponPos.y);
                ctx.rotate(weaponAngle);

                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-8, -8, 16, 16);

                ctx.fillStyle = '#333';
                ctx.fillRect(5, -4, 15, 8);
                ctx.fillStyle = '#222';
                ctx.fillRect(5, -3, 15, 6);

                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(20, 0, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#555';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // 6. Laser Sight (if booster active)
            if (gameState.ships[teamColor] && gameState.ships[teamColor].boosters && gameState.ships[teamColor].boosters.laserSight && systems.weaponDirection) {
                const weaponPos = getSystemPosition(ship, systems.weaponDirection.rotation);
                const weaponAngle = systems.weaponDirection.rotation * Math.PI / 180;

                ctx.save();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(weaponPos.x, weaponPos.y);
                ctx.lineTo(
                    weaponPos.x + Math.cos(weaponAngle) * 5000,
                    weaponPos.y + Math.sin(weaponAngle) * 5000
                );
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }
        }

        function renderShip() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Clear canvas - space background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const ships = gameState.ships;
            const ship = ships ? ships.blue : gameState.ship;  // Backward compatibility

            // Draw coins
            if (gameState.coins) {
                for (const coin of gameState.coins) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', coin.x, coin.y);
                }
            }

            // Draw hearts
            if (gameState.hearts) {
                for (const heart of gameState.hearts) {
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ù§Ô∏è', heart.x, heart.y);
                }
            }

            // v3.17: Draw loot
            if (gameState.loot) {
                for (const loot of gameState.loot) {
                    ctx.save();
                    ctx.translate(loot.x, loot.y);

                    switch (loot.type) {
                        case 'coin':
                            // Gold circle with $ symbol
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(0, 0, loot.radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#000';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('$', 0, 0);
                            break;

                        case 'heart':
                            // Heart emoji
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('‚ù§Ô∏è', 0, 0);
                            break;

                        case 'bullet':
                            // Cyan circle with glow
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#00FFFF';
                            ctx.fillStyle = '#00FFFF';
                            ctx.beginPath();
                            ctx.arc(0, 0, loot.radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            break;

                        case 'laser':
                            // Red horizontal line with glow
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#FF0000';
                            ctx.strokeStyle = '#FF0000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(-loot.radius, 0);
                            ctx.lineTo(loot.radius, 0);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                            break;

                        case 'attackShield':
                            // Magenta arc with 3 small spikes
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#FF00FF';
                            ctx.strokeStyle = '#FF00FF';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, loot.radius, -Math.PI/3, Math.PI/3);
                            ctx.stroke();
                            // Draw 3 spikes
                            for (let i = 0; i < 3; i++) {
                                const angle = -Math.PI/3 + (i * Math.PI/3);
                                const x1 = Math.cos(angle) * (loot.radius - 3);
                                const y1 = Math.sin(angle) * (loot.radius - 3);
                                const x2 = Math.cos(angle) * (loot.radius + 5);
                                const y2 = Math.sin(angle) * (loot.radius + 5);
                                ctx.beginPath();
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                ctx.stroke();
                            }
                            ctx.shadowBlur = 0;
                            break;

                        case 'attackEngine':
                            // Orange triangle flame
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#FFA500';
                            ctx.fillStyle = '#FFA500';
                            ctx.beginPath();
                            ctx.moveTo(0, -loot.radius);
                            ctx.lineTo(-loot.radius * 0.7, loot.radius * 0.7);
                            ctx.lineTo(loot.radius * 0.7, loot.radius * 0.7);
                            ctx.closePath();
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            break;
                    }

                    ctx.restore();
                }
            }

            // Draw bullets - size and color based on power
            if (gameState.bullets) {
                for (const bullet of gameState.bullets) {
                    ctx.save();

                    // Color: custom color if specified (e.g. attacking engine), red for max power, team color otherwise
                    let baseColor, baseColorRGB;

                    if (bullet.color) {
                        // Custom color (e.g. #FFA500 for attacking engine)
                        baseColor = bullet.color;
                        // Parse hex to RGB
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        baseColorRGB = `${r}, ${g}, ${b}`;
                    } else if (bullet.powerLevel === 10) {
                        baseColor = '#FF0000';
                        baseColorRGB = '255, 0, 0';
                    } else if (bullet.team === 'pink') {
                        baseColor = '#E91E63';
                        baseColorRGB = '233, 30, 99';
                    } else {
                        // Blue team or legacy
                        baseColor = '#2196F3';
                        baseColorRGB = '33, 150, 243';
                    }

                    // Size from bullet params (4-16px)
                    const outerRadius = bullet.size || 8;
                    const innerRadius = outerRadius * 0.625;
                    const centerRadius = outerRadius * 0.25;

                    // Outer glow
                    ctx.shadowBlur = outerRadius * 2;
                    ctx.shadowColor = baseColor;
                    ctx.fillStyle = `rgba(${baseColorRGB}, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, outerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner bright core
                    ctx.shadowBlur = outerRadius * 1.25;
                    ctx.fillStyle = `rgba(${baseColorRGB}, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, innerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Brightest center
                    ctx.shadowBlur = outerRadius * 0.625;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, centerRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }

            // Draw asteroids
            if (gameState.asteroids) {
                for (const asteroid of gameState.asteroids) {
                    ctx.save();
                    ctx.translate(asteroid.x, asteroid.y);
                    ctx.rotate(asteroid.rotation);

                    // Flash white when hit
                    const isFlashing = Date.now() < asteroid.flashUntil;
                    ctx.fillStyle = isFlashing ? '#FFFFFF' : '#888888';

                    // Draw irregular polygon
                    const sides = 8;
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (Math.PI * 2 * i) / sides;
                        const variance = 0.7 + (Math.sin(i * 2.5) * 0.15);
                        const r = asteroid.radius * variance;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Health bar
                    if (asteroid.health < asteroid.maxHealth) {
                        const barWidth = asteroid.radius * 2;
                        const barHeight = 4;
                        const healthPct = asteroid.health / asteroid.maxHealth;

                        ctx.fillStyle = '#333';
                        ctx.fillRect(-barWidth/2, -asteroid.radius - 10, barWidth, barHeight);

                        ctx.fillStyle = healthPct > 0.5 ? '#4CAF50' : '#FF5722';
                        ctx.fillRect(-barWidth/2, -asteroid.radius - 10, barWidth * healthPct, barHeight);
                    }

                    ctx.restore();
                }
            }

            // Draw ship (only if alive)
            if (ship && ship.alive !== false) {
                // Ship body - flash red when damaged
                const timeSinceDamage = Date.now() - ship.lastDamageTime;
                const isRedFlash = timeSinceDamage < 200;

                // Invulnerable smooth blink (fade in/out)
                if (ship.invulnerable && ship.spawnTime) {
                    const elapsed = Date.now() - ship.spawnTime;
                    const blinkCycle = 500; // 500ms per blink cycle
                    const phase = (elapsed % blinkCycle) / blinkCycle; // 0 to 1
                    // Smooth sine wave: alpha oscillates between 0.3 and 1.0
                    const alpha = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
                    ctx.globalAlpha = alpha;
                } else if (ship.invulnerable) {
                    // Fallback for old invulnerability (without spawnTime)
                    const blinkVisible = Math.floor(Date.now() / 150) % 2 === 0;
                    if (!blinkVisible) {
                        ctx.globalAlpha = 0.5;
                    }
                }

                ctx.fillStyle = isRedFlash ? '#FF0000' : '#2196F3';
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0;

                // Ship hull outline
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Health bar above ship (two-team mode)
                if (ships && ship.health !== undefined) {
                    const barWidth = 60;
                    const barHeight = 8;
                    const healthPercent = ship.health / ship.maxHealth;

                    ctx.fillStyle = '#f44336';
                    ctx.fillRect(ship.x - barWidth / 2, ship.y - 40, barWidth, barHeight);

                    ctx.fillStyle = '#2196F3';
                    ctx.fillRect(ship.x - barWidth / 2, ship.y - 40, barWidth * healthPercent, barHeight);

                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(ship.x - barWidth / 2, ship.y - 40, barWidth, barHeight);

                    ctx.fillStyle = 'white';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.ceil(ship.health)}`, ship.x, ship.y - 45);
                }

                // Render ship systems (engine, shield, weapon) using unified function
                if (gameState.teamSystems && gameState.teamSystems.blue) {
                    // Use team-specific systems data
                    renderShipSystems(ship, gameState.teamSystems.blue, 'blue');
                } else if (gameState.systems) {
                    // Backward compatibility: single-ship mode
                    renderShipSystems(ship, gameState.systems, 'blue');
                }
            }

            // Draw second ship (pink team) if in two-team mode and alive
            if (ships && ships.pink && ships.pink.alive !== false) {
                const pinkShip = ships.pink;

                // Invulnerable smooth blink
                if (pinkShip.invulnerable && pinkShip.spawnTime) {
                    const elapsed = Date.now() - pinkShip.spawnTime;
                    const blinkCycle = 500;
                    const phase = (elapsed % blinkCycle) / blinkCycle;
                    const alpha = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(phase * Math.PI * 2));
                    ctx.globalAlpha = alpha;
                }

                ctx.fillStyle = '#E91E63';  // Pink team color
                ctx.beginPath();
                ctx.arc(pinkShip.x, pinkShip.y, pinkShip.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0;

                // Pink ship outline
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Health bar above pink ship
                if (pinkShip.health < pinkShip.maxHealth) {
                    const barWidth = 60;
                    const barHeight = 8;
                    const healthPercent = pinkShip.health / pinkShip.maxHealth;

                    ctx.fillStyle = '#f44336';
                    ctx.fillRect(pinkShip.x - barWidth / 2, pinkShip.y - 40, barWidth, barHeight);

                    ctx.fillStyle = '#E91E63';
                    ctx.fillRect(pinkShip.x - barWidth / 2, pinkShip.y - 40, barWidth * healthPercent, barHeight);

                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(pinkShip.x - barWidth / 2, pinkShip.y - 40, barWidth, barHeight);

                    ctx.fillStyle = 'white';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.ceil(pinkShip.health)}`, pinkShip.x, pinkShip.y - 45);
                }

                // Draw pink ship systems using unified function
                if (gameState.teamSystems && gameState.teamSystems.pink) {
                    renderShipSystems(pinkShip, gameState.teamSystems.pink, 'pink');
                }
            }

            ctx.restore();

            // Draw HUD (top)
            if (ships) {
                // Two-team mode: coin counters shown in team rosters overlay (no canvas rendering)
            } else if (ship) {
                // Old single-ship mode
                ctx.font = '24px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFF';
                ctx.fillText(`‚ù§Ô∏è ${ship.hearts}/10`, 20, 30);
                ctx.fillText(`üí∞ ${ship.coins}/${gameState.coinsToWin || 10}`, 20, 60);
            }

            // Render visual effects
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        function updateScoreboard() {
            if (!gameState) return;

            playerList.innerHTML = '';

            // Sort players by score
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);

            for (const player of sortedPlayers) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-score';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.style.color = player.color;
                nameSpan.textContent = player.name;

                const scoreSpan = document.createElement('span');
                scoreSpan.textContent = player.score;

                const statusSpan = document.createElement('div');
                statusSpan.className = 'player-status' + (player.alive ? '' : ' dead');
                statusSpan.textContent = player.alive ? '' : '–ú–µ—Ä—Ç–≤';

                playerDiv.appendChild(nameSpan);
                playerDiv.appendChild(scoreSpan);
                if (!player.alive) {
                    playerDiv.appendChild(statusSpan);
                }

                playerList.appendChild(playerDiv);
            }
        }

        // ========================================================================
        // BALLZ RENDERING
        // ========================================================================

        // ==================== BALLZ v3.25.0 - Single Player ====================

function renderBallz() {
    // Black background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // v3.25.0: Single player only
    const player = gameState.players && gameState.players[0];
    if (!player) return;

    // Game over screen
    if (player.gameOver) {
        drawBallzGameOver(player);
        return;
    }

    // Calculate field dimensions with aspect ratio
    const aspectRatio = gameState.aspectRatio || 0.75; // 3:4 default
    const cols = gameState.cols || 7;
    const rows = gameState.rows || 14;
    const ballSpeed = gameState.ballSpeed || 0.33; // For trajectory calculation

    // Adaptive canvas sizing
    let fieldWidth, fieldHeight;
    if (canvas.width / canvas.height > aspectRatio) {
        // Canvas wider than needed - fit by height
        fieldHeight = canvas.height;
        fieldWidth = fieldHeight * aspectRatio;
    } else {
        // Canvas taller than needed - fit by width
        fieldWidth = canvas.width;
        fieldHeight = fieldWidth / aspectRatio;
    }

    // Center the field
    const offsetX = (canvas.width - fieldWidth) / 2;
    const offsetY = (canvas.height - fieldHeight) / 2;

    // Store dimensions globally for particle effects coordinate conversion
    window.ballzFieldDimensions = {
        fieldWidth: fieldWidth,
        fieldHeight: fieldHeight,
        offsetX: offsetX,
        offsetY: offsetY
    };

    ctx.save();
    ctx.translate(offsetX, offsetY);

    // UI overlay ABOVE the field (drawn before translating down)
    const uiHeight = 40;
    drawBallzUI(player, fieldWidth, -uiHeight); // Draw above field at y=-40

    // Field border
    ctx.strokeStyle = player.color || '#4CAF50';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, fieldWidth, fieldHeight);

    // Launch line (at y = 1.0 = bottom)
    const launchLineY = fieldHeight * 0.95; // 95% down
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, launchLineY);
    ctx.lineTo(fieldWidth, launchLineY);
    ctx.stroke();

    // Blocks (relative gridX, gridY) - RECTANGLES to match collision!
    const blockWidth = fieldWidth / cols;
    const blockHeight = fieldHeight / rows;

    for (const block of player.blocks || []) {
        const x = block.gridX * blockWidth + blockWidth / 2;
        const y = block.gridY * blockHeight + blockHeight / 2;
        drawBallzBlock(x, y, blockWidth, blockHeight, block.hp, block.maxHp);
    }

    // Bonus balls
    for (const bonus of player.bonusBalls || []) {
        const x = bonus.gridX * blockWidth + blockWidth / 2;
        const y = bonus.gridY * blockHeight + blockHeight / 2;
        ctx.fillStyle = '#FFD700';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#FFD700';
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // Flying balls (relative 0-1 coordinates)
    for (const ball of player.balls || []) {
        if (!ball.active) continue;
        const x = ball.x * fieldWidth;
        const y = ball.y * fieldHeight;
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Launch ball (only when aiming/charging)
    if (player.turnState === 'aiming' || player.turnState === 'charging') {
        const launchX = player.launchX !== null ? player.launchX * fieldWidth : fieldWidth / 2;
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(launchX, launchLineY, 5, 0, Math.PI * 2);
        ctx.fill();

        // Aim line with charge effect
        drawBallzAimLine(player, launchX, launchLineY, fieldWidth, fieldHeight, cols, rows, ballSpeed);
    }

    ctx.restore();

    // Render visual effects (particles, score animations)
    for (const p of effects.particles) {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'center';
    for (const anim of effects.scoreAnims) {
        ctx.globalAlpha = anim.alpha;
        ctx.fillStyle = anim.color;
        ctx.fillText(anim.text, anim.x, anim.y);
    }

    ctx.globalAlpha = 1.0;
}

function drawBallzBlock(centerX, centerY, width, height, hp, maxHp) {
    const halfW = width / 2;
    const halfH = height / 2;

    // HP-based color
    let color;
    if (hp <= 5) color = '#4CAF50'; // Green (1-5)
    else if (hp <= 10) color = '#2196F3'; // Blue (6-10)
    else if (hp <= 20) color = '#9C27B0'; // Purple (11-20)
    else if (hp <= 30) color = '#FF9800'; // Orange (21-30)
    else if (hp <= 50) color = '#F44336'; // Red (31-50)
    else color = '#B71C1C'; // Dark red (51+)

    // Block fill
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.8;
    ctx.fillRect(centerX - halfW, centerY - halfH, width, height);
    ctx.globalAlpha = 1.0;

    // Border
    ctx.strokeStyle = '#FFF';
    ctx.lineWidth = 2;
    ctx.strokeRect(centerX - halfW, centerY - halfH, width, height);

    // HP text
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(hp, centerX, centerY);
}

function drawBallzAimLine(player, launchX, launchY, fieldWidth, fieldHeight, cols, rows, ballSpeed) {
    const angle = player.aimAngle;
    const blockWidth = fieldWidth / cols;
    const blockHeight = fieldHeight / rows;

    // Calculate trajectory with reflections
    const trajectory = calculateBallzTrajectory(
        launchX, launchY, angle,
        fieldWidth, fieldHeight,
        player.blocks || [],
        blockWidth, blockHeight,
        ballSpeed || 0.33 // Default ballSpeed if not provided
    );

    // Draw trajectory segments
    const color = player.isInDeadZone ? '#FF0000' : '#FFFFFF';
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.5;
    ctx.setLineDash([5, 10]);
    ctx.beginPath();

    if (trajectory.length > 0) {
        ctx.moveTo(trajectory[0].x, trajectory[0].y);
        for (let i = 1; i < trajectory.length; i++) {
            ctx.lineTo(trajectory[i].x, trajectory[i].y);
        }
    }

    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = 1.0;

    // Charge effect (fill line along trajectory)
    if (player.turnState === 'charging' && player.chargeProgress > 0 && !player.isInDeadZone) {
        // Calculate total trajectory length
        let totalLength = 0;
        for (let i = 1; i < trajectory.length; i++) {
            const dx = trajectory[i].x - trajectory[i-1].x;
            const dy = trajectory[i].y - trajectory[i-1].y;
            totalLength += Math.sqrt(dx * dx + dy * dy);
        }

        // Find point at chargeProgress along trajectory
        const targetLength = totalLength * player.chargeProgress;
        let currentLength = 0;
        let endX = launchX, endY = launchY;

        for (let i = 1; i < trajectory.length; i++) {
            const dx = trajectory[i].x - trajectory[i-1].x;
            const dy = trajectory[i].y - trajectory[i-1].y;
            const segmentLength = Math.sqrt(dx * dx + dy * dy);

            if (currentLength + segmentLength >= targetLength) {
                const t = (targetLength - currentLength) / segmentLength;
                endX = trajectory[i-1].x + dx * t;
                endY = trajectory[i-1].y + dy * t;
                break;
            }

            currentLength += segmentLength;
        }

        // Draw charged portion
        const progress = player.chargeProgress;
        let chargeColor;
        if (progress < 0.33) chargeColor = '#00FF00';
        else if (progress < 0.66) chargeColor = '#FFFF00';
        else chargeColor = '#FF0000';

        ctx.strokeStyle = chargeColor;
        ctx.lineWidth = 4;
        ctx.shadowBlur = 10;
        ctx.shadowColor = chargeColor;
        ctx.beginPath();

        ctx.moveTo(launchX, launchY);
        currentLength = 0;
        for (let i = 1; i < trajectory.length; i++) {
            const dx = trajectory[i].x - trajectory[i-1].x;
            const dy = trajectory[i].y - trajectory[i-1].y;
            const segmentLength = Math.sqrt(dx * dx + dy * dy);

            if (currentLength + segmentLength >= targetLength) {
                ctx.lineTo(endX, endY);
                break;
            }

            ctx.lineTo(trajectory[i].x, trajectory[i].y);
            currentLength += segmentLength;
        }

        ctx.stroke();
        ctx.shadowBlur = 0;

        // Pulsing indicator
        const pulseSize = 5 + Math.sin(Date.now() / 100) * 2;
        ctx.fillStyle = chargeColor;
        ctx.beginPath();
        ctx.arc(endX, endY, pulseSize, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Calculate ball trajectory with reflections
function calculateBallzTrajectory(startX, startY, angle, fieldWidth, fieldHeight, blocks, blockWidth, blockHeight, ballSpeed = 0.33) {
    const trajectory = [{x: startX, y: startY}];
    let x = startX, y = startY;
    // CRITICAL: Match server physics! speed = ballSpeed / 100, then multiply by direction
    const speed = ballSpeed / 100;
    let vx = Math.cos(angle) * speed * fieldWidth; // Convert to pixels per frame
    let vy = -Math.sin(angle) * speed * fieldHeight; // Convert to pixels per frame
    const maxSteps = 1000; // max trajectory length
    const ballRadius = fieldWidth * 0.01; // Match server: 1% of field width

    for (let i = 0; i < maxSteps; i++) {
        x += vx;
        y += vy;

        // Left/right wall bounce
        if (x <= ballRadius) {
            x = ballRadius;
            vx = Math.abs(vx);
        } else if (x >= fieldWidth - ballRadius) {
            x = fieldWidth - ballRadius;
            vx = -Math.abs(vx);
        }

        // Top wall bounce
        if (y <= ballRadius) {
            y = ballRadius;
            vy = Math.abs(vy);
        }

        // Bottom - stop trajectory
        if (y >= fieldHeight * 0.95) {
            trajectory.push({x, y: fieldHeight * 0.95});
            break;
        }

        // Check block collisions (AABB with rectangles)
        for (const block of blocks) {
            const blockCenterX = block.gridX * blockWidth + blockWidth / 2;
            const blockCenterY = block.gridY * blockHeight + blockHeight / 2;
            const halfWidth = blockWidth / 2;
            const halfHeight = blockHeight / 2;

            if (x >= blockCenterX - halfWidth - ballRadius &&
                x <= blockCenterX + halfWidth + ballRadius &&
                y >= blockCenterY - halfHeight - ballRadius &&
                y <= blockCenterY + halfHeight + ballRadius) {

                // Simple bounce - reverse velocity (match server logic)
                const dx = x - blockCenterX;
                const dy = y - blockCenterY;
                if (Math.abs(dx) > Math.abs(dy)) {
                    vx = -vx;
                } else {
                    vy = -vy;
                }

                // Push ball out of block
                x += vx * 2;
                y += vy * 2;
                break;
            }
        }

        trajectory.push({x, y});
    }

    return trajectory;
}

function drawBallzUI(player, fieldWidth, yOffset = 0) {
    const uiHeight = 40;

    // UI background
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, yOffset, fieldWidth, uiHeight);

    // Player name (left)
    ctx.fillStyle = player.color || '#4CAF50';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(player.name, 10, yOffset + uiHeight / 2);

    // Ball count (center)
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`x${player.ballCount}`, fieldWidth / 2, yOffset + uiHeight / 2);

    // Score (right)
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`${player.score}`, fieldWidth - 10, yOffset + uiHeight / 2);
}

function drawBallzGameOver(player) {
    // Semi-transparent overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Player color border
    ctx.strokeStyle = player.color || '#4CAF50';
    ctx.lineWidth = 5;
    ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);

    // "GAME OVER"
    ctx.fillStyle = '#FF0000';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height * 0.3);

    // Score
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 36px sans-serif';
    ctx.fillText(`Score: ${player.score}`, canvas.width / 2, canvas.height * 0.5);

    // Turn number
    ctx.font = '24px sans-serif';
    ctx.fillText(`–•–æ–¥–æ–≤: ${player.turnNumber}`, canvas.width / 2, canvas.height * 0.65);

    // Player name
    ctx.fillStyle = player.color || '#4CAF50';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText(player.name, canvas.width / 2, canvas.height * 0.8);
}

function renderBallzLeaderboard() {
    // This function is only called for multiplayer (which v3.25.0 doesn't have)
    // Keeping it for compatibility, but single-player uses drawBallzGameOver instead
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Single Player Mode', canvas.width / 2, canvas.height / 2);
}

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, ((num >> 16) & 0xFF) + percent);
            const g = Math.min(255, ((num >> 8) & 0xFF) + percent);
            const b = Math.min(255, (num & 0xFF) + percent);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Animation loop
        function animate() {
            if (gameState && canvas.classList.contains('active')) {
                updateEffects();
                render();
            }
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
