<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinemon - Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .screen {
            text-align: center;
            padding: 10px;
            display: none;
        }

        .screen.active {
            display: block;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        h2 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        p {
            font-size: 16px;
            margin-bottom: 20px;
            opacity: 0.8;
        }

        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
        }

        .btn:hover {
            background: #45a049;
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            padding: 15px;
            font-size: 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 400px;
        }

        #gameCanvas {
            border: 2px solid #333;
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        #gameCanvas.active {
            display: block;
        }

        #scoreboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
            pointer-events: none;
        }

        .player-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 18px;
        }

        .player-name {
            font-weight: bold;
            margin-right: 20px;
        }

        .player-status {
            font-size: 12px;
            opacity: 0.6;
        }

        .player-status.dead {
            color: #F44336;
        }

        /* Waiting for players screen styles */
        #waitingScreen {
            max-width: 600px;
        }

        .room-code {
            font-size: 72px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 12px;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
        }

        #qrcode {
            background: white;
            padding: 20px;
            border-radius: 15px;
            display: inline-block;
            margin: 20px 0;
        }

        .instruction {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .room-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
        }

        .room-label {
            font-size: 14px;
            opacity: 0.6;
        }

        .room-id-display {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            letter-spacing: 4px;
        }

        /* Settings screen styles */
        #settingsScreen {
            max-width: 100%;
            width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
        }

        #settingsForm {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .setting-group {
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
        }

        .setting-group label {
            display: block;
            font-size: 14px;
            margin-bottom: 6px;
            color: #4CAF50;
            font-weight: bold;
        }

        .setting-group select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            cursor: pointer;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #66BB6A;
        }

        .setting-info {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Settings Screen -->
        <div id="settingsScreen" class="screen active">
            <h1 id="gameTitle">üéÆ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã</h1>
            <button class="btn" id="startGameBtn" style="margin-bottom: 20px;">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            <div id="settingsForm">
                <!-- Settings will be populated by JavaScript based on game type -->
            </div>
        </div>

        <!-- Connection Screen -->
        <div id="connectionScreen" class="screen">
            <h1>üñ•Ô∏è –≠–∫—Ä–∞–Ω –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</h1>
            <p>–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–µ—Ä–≤–µ—Ä—É...</p>
            <p style="font-size: 14px; opacity: 0.6; margin-top: 20px;">
                ‚è±Ô∏è –ü–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 30-60 —Å–µ–∫<br>
                (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –ø—Ä–æ—Å—ã–ø–∞–µ—Ç—Å—è)
            </p>
        </div>

        <!-- Waiting for Players Screen -->
        <div id="waitingScreen" class="screen">
            <h2>–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤</h2>
            <div class="room-code" id="roomCodeDisplay">------</div>
            <p style="font-size: 24px; margin: 10px 0;">–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</p>

            <div id="qrcode"></div>

            <div class="instruction">
                <p><strong>–ö–∞–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è:</strong></p>
                <p>üì± –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –∫–∞–º–µ—Ä–æ–π —Ç–µ–ª–µ—Ñ–æ–Ω–∞</p>
                <p style="font-size: 14px; opacity: 0.5;">–∏–ª–∏</p>
                <p>‚å®Ô∏è –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã –≤—Ä—É—á–Ω—É—é</p>
            </div>

            <p id="playerCount" style="font-size: 20px; color: #4CAF50;">–ò–≥—Ä–æ–∫–æ–≤: 0</p>
        </div>

        <!-- Win Screen -->
        <div id="winScreen" class="screen">
            <h1>üèÜ –ü–æ–±–µ–¥–∞!</h1>
            <p id="winnerName" style="font-size: 32px; margin: 20px 0;"></p>
            <p id="winMessage">–°–æ–±—Ä–∞–ª 50 –ø–∏—Ü—Ü!</p>
            <button class="btn" onclick="window.location.href='index.html'">–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é</button>
        </div>

        <!-- Game Display -->
        <canvas id="gameCanvas" width="600" height="800"></canvas>

        <div id="roomInfo" class="room-info" style="display: none;">
            <div class="room-label">–ö–æ–º–Ω–∞—Ç–∞</div>
            <div class="room-id-display" id="roomIdInfo">------</div>
        </div>

        <div id="scoreboard" style="display: none;">
            <h3>–ò–≥—Ä–æ–∫–∏</h3>
            <div id="playerList"></div>
        </div>
    </div>

    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <script>
        let ws = null;
        let gameState = null;
        let roomId = null;
        let gameType = null; // 'pong' or 'snake'
        let gameSettings = {}; // Store game settings

        // Visual effects system
        const effects = {
            particles: [],
            screenShake: { active: false, offsetX: 0, offsetY: 0, intensity: 0, startTime: 0, duration: 0 },
            flash: { active: false, color: '#FFF', alpha: 0, startTime: 0, duration: 0 },
            scoreAnims: []
        };

        // Detect available viewport dimensions
        function getAvailableCanvasDimensions() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;
            console.log(`Viewport: ${availableWidth}x${availableHeight}`);
            return {
                width: Math.floor(availableWidth),
                height: Math.floor(availableHeight)
            };
        }

        const settingsScreen = document.getElementById('settingsScreen');
        const connectionScreen = document.getElementById('connectionScreen');
        const waitingScreen = document.getElementById('waitingScreen');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerList = document.getElementById('playerList');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomIdInfo = document.getElementById('roomIdInfo');
        const roomInfo = document.getElementById('roomInfo');
        const scoreboard = document.getElementById('scoreboard');
        const playerCount = document.getElementById('playerCount');
        const startGameBtn = document.getElementById('startGameBtn');
        const gameTitle = document.getElementById('gameTitle');
        const settingsForm = document.getElementById('settingsForm');

        // Parse game type from URL
        const urlParams = new URLSearchParams(window.location.search);
        gameType = urlParams.get('game') || 'snake'; // default to snake if not specified

        // Set default server URL
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.hostname === '';
        const defaultServerUrl = isLocalhost ? 'ws://localhost:8080' : 'wss://kinemon.onrender.com';

        // Populate settings based on game type
        function populateSettings() {
            if (gameType === 'pong') {
                gameTitle.textContent = 'üèì –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Pong';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="pongBallSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞</label>
                        <select id="pongBallSpeed">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω–∞—è</option>
                            <option value="2">–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3" selected>–ë—ã—Å—Ç—Ä–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª–µ—Ç–∞ –º—è—á–∞</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongPaddleSize">–†–∞–∑–º–µ—Ä —Ä–∞–∫–µ—Ç–∫–∏</label>
                        <select id="pongPaddleSize">
                            <option value="1">–ú–∞–ª–µ–Ω—å–∫–∞—è</option>
                            <option value="2" selected>–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3">–ë–æ–ª—å—à–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä —Ä–∞–∫–µ—Ç–æ–∫ –∏–≥—Ä–æ–∫–æ–≤</div>
                    </div>
                    <div class="setting-group">
                        <label for="pongWinScore">–ü–æ–±–µ–¥–Ω—ã–π —Å—á–µ—Ç</label>
                        <select id="pongWinScore">
                            <option value="5">5 –æ—á–∫–æ–≤</option>
                            <option value="11" selected>11 –æ—á–∫–æ–≤</option>
                            <option value="21">21 –æ—á–∫–æ</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.ballSpeed = parseInt(localStorage.getItem('pongBallSpeed')) || 3;
                gameSettings.paddleSize = parseInt(localStorage.getItem('pongPaddleSize')) || 2;
                gameSettings.winScore = parseInt(localStorage.getItem('pongWinScore')) || 11;

                document.getElementById('pongBallSpeed').value = gameSettings.ballSpeed;
                document.getElementById('pongPaddleSize').value = gameSettings.paddleSize;
                document.getElementById('pongWinScore').value = gameSettings.winScore;

            } else if (gameType === 'pushers') {
                gameTitle.textContent = 'üî≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–æ–ª–∫–∞—Ç–µ–ª–∏';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="pushersWinScore">–û—á–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="pushersWinScore">
                            <option value="10">10 –æ—á–∫–æ–≤</option>
                            <option value="15" selected>15 –æ—á–∫–æ–≤</option>
                            <option value="20">20 –æ—á–∫–æ–≤</option>
                            <option value="25">25 –æ—á–∫–æ–≤</option>
                            <option value="30">30 –æ—á–∫–æ–≤</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–º–∞–π–ª–∏–∫–æ–≤ –¥–ª—è –ø–æ–±–µ–¥—ã –∫–æ–º–∞–Ω–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="pushersSingleSquare">–†–µ–∂–∏–º –∏–≥—Ä—ã</label>
                        <select id="pushersSingleSquare">
                            <option value="false">–û–±—ã—á–Ω—ã–π - –∫–∞–∂–¥—ã–π –∏–≥—Ä–æ–∫ —Å–≤–æ–π –∫–≤–∞–¥—Ä–∞—Ç</option>
                            <option value="true">–û–¥–∏–Ω –∫–≤–∞–¥—Ä–∞—Ç –Ω–∞ –∫–æ–º–∞–Ω–¥—É - –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤</option>
                        </select>
                        <div class="setting-info">–í –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–µ –¥–≤–∞ –∏–≥—Ä–æ–∫–∞ —É–ø—Ä–∞–≤–ª—è—é—Ç –æ–¥–Ω–∏–º –∫–≤–∞–¥—Ä–∞—Ç–æ–º (–æ–¥–∏–Ω –ø–æ X, –¥—Ä—É–≥–æ–π –ø–æ Y)</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.winScore = parseInt(localStorage.getItem('pushersWinScore')) || 15;
                const singleSquare = localStorage.getItem('pushersSingleSquare') || 'false';

                document.getElementById('pushersWinScore').value = gameSettings.winScore;
                document.getElementById('pushersSingleSquare').value = singleSquare;

            } else if (gameType === 'ship') {
                gameTitle.textContent = 'üöÄ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ö–æ—Ä–∞–±–ª—å';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="shipEngineFormula">–§–æ—Ä–º—É–ª–∞ –¥–≤–∏–≥–∞—Ç–µ–ª—è</label>
                        <select id="shipEngineFormula">
                            <option value="balanced" selected>–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è</option>
                            <option value="speed">–°–∫–æ—Ä–æ—Å—Ç—å (–±—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–∫—Ü–∏—è)</option>
                            <option value="combo">–ö–æ–º–±–æ (–Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ)</option>
                        </select>
                        <div class="setting-info">–ö–∞–∫ –∞–º–ø–ª–∏—Ç—É–¥–∞ –∏ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Ç—è–≥—É</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipWeaponFormula">–§–æ—Ä–º—É–ª–∞ –æ—Ä—É–∂–∏—è</label>
                        <select id="shipWeaponFormula">
                            <option value="standard" selected>–°—Ç–∞–Ω–¥–∞—Ä—Ç</option>
                            <option value="sniper">–°–Ω–∞–π–ø–µ—Ä (–¥–∞–ª—å–Ω–æ–±–æ–π–Ω–æ—Å—Ç—å)</option>
                            <option value="rapid">–ë—ã—Å—Ç—Ä—ã–π (–∫–æ—Ä–æ—Ç–∫–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è)</option>
                        </select>
                        <div class="setting-info">–î–∞–ª—å–Ω–æ—Å—Ç—å –∏ —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª—å</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipCoinsToWin">–ú–æ–Ω–µ—Ç –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="shipCoinsToWin">
                            <option value="5">5 –º–æ–Ω–µ—Ç</option>
                            <option value="10" selected>10 –º–æ–Ω–µ—Ç</option>
                            <option value="15">15 –º–æ–Ω–µ—Ç</option>
                            <option value="20">20 –º–æ–Ω–µ—Ç</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–Ω–µ—Ç –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="shipAsteroidFrequency">–ß–∞—Å—Ç–æ—Ç–∞ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</label>
                        <select id="shipAsteroidFrequency">
                            <option value="low">–ù–∏–∑–∫–∞—è (3 —Å–µ–∫)</option>
                            <option value="medium" selected>–°—Ä–µ–¥–Ω—è—è (2 —Å–µ–∫)</option>
                            <option value="high">–í—ã—Å–æ–∫–∞—è (1.2 —Å–µ–∫)</option>
                        </select>
                        <div class="setting-info">–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ—è–≤–ª–µ–Ω–∏—è –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.engineFormula = localStorage.getItem('shipEngineFormula') || 'balanced';
                gameSettings.weaponFormula = localStorage.getItem('shipWeaponFormula') || 'standard';
                gameSettings.coinsToWin = parseInt(localStorage.getItem('shipCoinsToWin')) || 10;
                gameSettings.asteroidFrequency = localStorage.getItem('shipAsteroidFrequency') || 'medium';

                document.getElementById('shipEngineFormula').value = gameSettings.engineFormula;
                document.getElementById('shipWeaponFormula').value = gameSettings.weaponFormula;
                document.getElementById('shipCoinsToWin').value = gameSettings.coinsToWin;
                document.getElementById('shipAsteroidFrequency').value = gameSettings.asteroidFrequency;

            } else { // snake
                gameTitle.textContent = 'üêç –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Pizza Snake';
                settingsForm.innerHTML = `
                    <div class="setting-group">
                        <label for="snakeTurnSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞</label>
                        <select id="snakeTurnSpeed">
                            <option value="1">1x - –ú–µ–¥–ª–µ–Ω–Ω–æ</option>
                            <option value="2" selected>2x - –ù–æ—Ä–º–∞–ª—å–Ω–æ</option>
                            <option value="3">3x - –ë—ã—Å—Ç—Ä–æ</option>
                            <option value="4">4x - –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ</option>
                            <option value="5">5x - –≠–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–æ</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞ –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeControlMapping">–†–µ–∂–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</label>
                        <select id="snakeControlMapping">
                            <option value="rotation_smooth" selected>–ü–æ–≤–æ—Ä–æ—Ç (–ø–ª–∞–≤–Ω—ã–π)</option>
                            <option value="center_straight">–¶–µ–Ω—Ç—Ä = –ø—Ä—è–º–æ</option>
                            <option value="rotation_linear">–ü–æ–≤–æ—Ä–æ—Ç (—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π)</option>
                            <option value="nonlinear_a">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π A (—Å—Ç–∞—Ä—ã–π)</option>
                            <option value="nonlinear_b">–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π B (—Å—Ç–∞—Ä—ã–π)</option>
                        </select>
                        <div class="setting-info">–ö–∞–∫ –Ω–∞–∫–ª–æ–Ω –≤–ª–∏—è–µ—Ç –Ω–∞ –ø–æ–≤–æ—Ä–æ—Ç –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeMoveSpeed">–°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è</label>
                        <select id="snakeMoveSpeed">
                            <option value="1">–ú–µ–¥–ª–µ–Ω–Ω–∞—è</option>
                            <option value="2">–°—Ä–µ–¥–Ω—è—è</option>
                            <option value="3" selected>–ë—ã—Å—Ç—Ä–∞—è</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è –∑–º–µ–π–∫–∏</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeSize">–†–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏</label>
                        <select id="snakeSize">
                            <option value="1" selected>1 - –ú–∏–Ω–∏–º—É–º</option>
                            <option value="2">2 - –ú–∞–ª–µ–Ω—å–∫–∏–π</option>
                            <option value="3">3 - –°—Ä–µ–¥–Ω–∏–π</option>
                            <option value="4">4 - –ë–æ–ª—å—à–æ–π</option>
                            <option value="5">5 - –ú–∞–∫—Å–∏–º—É–º</option>
                        </select>
                        <div class="setting-info">–í–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä –∑–º–µ–π–∫–∏ –∏ –ø–∏—Ü—Ü—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeWinScore">–ü–∏—Ü—Ü –¥–ª—è –ø–æ–±–µ–¥—ã</label>
                        <select id="snakeWinScore">
                            <option value="20">20 –ø–∏—Ü—Ü</option>
                            <option value="30">30 –ø–∏—Ü—Ü</option>
                            <option value="50" selected>50 –ø–∏—Ü—Ü</option>
                            <option value="75">75 –ø–∏—Ü—Ü</option>
                            <option value="100">100 –ø–∏—Ü—Ü</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏—Ü—Ü –¥–ª—è –ø–æ–±–µ–¥—ã</div>
                    </div>
                    <div class="setting-group">
                        <label for="snakeInitialPizzas">–ù–∞—á–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—ã–ª–∏</label>
                        <select id="snakeInitialPizzas">
                            <option value="100" selected>100 —á–∞—Å—Ç–∏—Ü</option>
                            <option value="150">150 —á–∞—Å—Ç–∏—Ü</option>
                            <option value="200">200 —á–∞—Å—Ç–∏—Ü</option>
                        </select>
                        <div class="setting-info">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤—ë–∑–¥–Ω–æ–π –ø—ã–ª–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ</div>
                    </div>
                `;
                // Load saved settings
                gameSettings.turnSpeed = parseInt(localStorage.getItem('snakeTurnSpeed')) || 2;
                gameSettings.controlMapping = localStorage.getItem('snakeControlMapping') || 'rotation_smooth';
                gameSettings.moveSpeed = parseInt(localStorage.getItem('snakeMoveSpeed')) || 3;
                gameSettings.snakeSize = parseInt(localStorage.getItem('snakeSize')) || 1;
                gameSettings.winScore = parseInt(localStorage.getItem('snakeWinScore')) || 50;
                gameSettings.initialPizzas = parseInt(localStorage.getItem('snakeInitialPizzas')) || 100;

                document.getElementById('snakeTurnSpeed').value = gameSettings.turnSpeed;
                document.getElementById('snakeControlMapping').value = gameSettings.controlMapping;
                document.getElementById('snakeMoveSpeed').value = gameSettings.moveSpeed;
                document.getElementById('snakeSize').value = gameSettings.snakeSize;
                document.getElementById('snakeWinScore').value = gameSettings.winScore;
                document.getElementById('snakeInitialPizzas').value = gameSettings.initialPizzas;
            }
        }

        // Initialize settings on page load
        populateSettings();

        // Start game button - save settings and connect to server
        startGameBtn.addEventListener('click', () => {
            // Save settings to localStorage
            if (gameType === 'pong') {
                gameSettings.ballSpeed = parseInt(document.getElementById('pongBallSpeed').value);
                gameSettings.paddleSize = parseInt(document.getElementById('pongPaddleSize').value);
                gameSettings.winScore = parseInt(document.getElementById('pongWinScore').value);
                localStorage.setItem('pongBallSpeed', gameSettings.ballSpeed);
                localStorage.setItem('pongPaddleSize', gameSettings.paddleSize);
                localStorage.setItem('pongWinScore', gameSettings.winScore);
            } else if (gameType === 'pushers') {
                gameSettings.winScore = parseInt(document.getElementById('pushersWinScore').value);
                gameSettings.singleSquare = document.getElementById('pushersSingleSquare').value === 'true';
                localStorage.setItem('pushersWinScore', gameSettings.winScore);
                localStorage.setItem('pushersSingleSquare', gameSettings.singleSquare);
            } else if (gameType === 'ship') {
                gameSettings.engineFormula = document.getElementById('shipEngineFormula').value;
                gameSettings.weaponFormula = document.getElementById('shipWeaponFormula').value;
                gameSettings.coinsToWin = parseInt(document.getElementById('shipCoinsToWin').value);
                gameSettings.asteroidFrequency = document.getElementById('shipAsteroidFrequency').value;
                localStorage.setItem('shipEngineFormula', gameSettings.engineFormula);
                localStorage.setItem('shipWeaponFormula', gameSettings.weaponFormula);
                localStorage.setItem('shipCoinsToWin', gameSettings.coinsToWin);
                localStorage.setItem('shipAsteroidFrequency', gameSettings.asteroidFrequency);
            } else {
                gameSettings.turnSpeed = parseInt(document.getElementById('snakeTurnSpeed').value);
                gameSettings.controlMapping = document.getElementById('snakeControlMapping').value;
                gameSettings.moveSpeed = parseInt(document.getElementById('snakeMoveSpeed').value);
                gameSettings.snakeSize = parseInt(document.getElementById('snakeSize').value);
                gameSettings.winScore = parseInt(document.getElementById('snakeWinScore').value);
                gameSettings.initialPizzas = parseInt(document.getElementById('snakeInitialPizzas').value);
                localStorage.setItem('snakeTurnSpeed', gameSettings.turnSpeed);
                localStorage.setItem('snakeControlMapping', gameSettings.controlMapping);
                localStorage.setItem('snakeMoveSpeed', gameSettings.moveSpeed);
                localStorage.setItem('snakeSize', gameSettings.snakeSize);
                localStorage.setItem('snakeWinScore', gameSettings.winScore);
                localStorage.setItem('snakeInitialPizzas', gameSettings.initialPizzas);
            }

            console.log('Game settings:', gameSettings);

            // Show connection screen and connect
            showScreen('connection');
            connectToServer();
        });

        // Wake up Render server on page load (free tier spins down after inactivity)
        if (!isLocalhost) {
            console.log('üîÑ Waking up Render server...');
            fetch('https://kinemon.onrender.com')
                .then(() => console.log('‚úÖ Server wake-up request sent'))
                .catch((err) => console.log('‚ö†Ô∏è Server wake-up failed:', err));
        }

        function showScreen(screenName) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));

            if (screenName === 'settings') {
                settingsScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'connection') {
                connectionScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'waiting') {
                waitingScreen.classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'win') {
                document.getElementById('winScreen').classList.add('active');
                canvas.classList.remove('active');
                roomInfo.style.display = 'none';
                scoreboard.style.display = 'none';
            } else if (screenName === 'game') {
                canvas.classList.add('active');
                // Hide right panel for Pushers and Ship (team-based/cooperative games use canvas scoreboard)
                if (gameState && (gameState.gameType === 'pushers' || gameState.gameType === 'ship')) {
                    roomInfo.style.display = 'none';
                    scoreboard.style.display = 'none';
                } else {
                    roomInfo.style.display = 'block';
                    scoreboard.style.display = 'block';
                }
            }
        }

        function connectToServer() {
            const serverUrl = defaultServerUrl;

            try {
                console.log('Connecting to:', serverUrl);

                ws = new WebSocket(serverUrl);

                // Timeout for connection
                const connectionTimeout = setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        alert('‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è.\n\n–°–µ—Ä–≤–µ—Ä Render –º–æ–∂–µ—Ç –ø—Ä–æ—Å—ã–ø–∞—Ç—å—Å—è (–ø–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–Ω–∏–º–∞–µ—Ç 30-60 —Å–µ–∫).\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.');
                        showScreen('settings');
                    }
                }, 60000); // 60 seconds timeout

                ws.onopen = () => {
                    clearTimeout(connectionTimeout);
                    console.log('‚úÖ Connected to server');

                    // Get viewport dimensions for Snake and Ship
                    const dimensions = getAvailableCanvasDimensions();
                    if (gameType === 'snake' || gameType === 'ship') {
                        gameSettings.canvasWidth = dimensions.width;
                        gameSettings.canvasHeight = dimensions.height;
                    }

                    // Request room creation with game type and settings
                    ws.send(JSON.stringify({
                        type: 'create_room',
                        gameType: gameType,
                        settings: gameSettings
                    }));
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå WebSocket error:', error);
                    alert('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ Render: https://kinemon.onrender.com\n2. URL –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π: ' + serverUrl + '\n3. –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
                    showScreen('settings');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    console.log('Disconnected from server. Code:', event.code, 'Reason:', event.reason);
                    showScreen('settings');

                    if (event.code !== 1000 && event.code !== 1001) {
                        alert('‚ö†Ô∏è –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ.\n\nCode: ' + event.code);
                    }
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'room_created') {
                        // Room created, show QR code
                        roomId = data.roomId;
                        console.log('Room created:', roomId);

                        roomCodeDisplay.textContent = roomId;
                        roomIdInfo.textContent = roomId;

                        // Generate QR code with direct link (for camera scanning)
                        document.getElementById('qrcode').innerHTML = '';

                        // Build controller URL with room, server, and game type parameters
                        const baseUrl = window.location.origin + window.location.pathname.replace('display.html', 'controller.html');
                        const qrData = `${baseUrl}?room=${roomId}&game=${gameType}&server=${encodeURIComponent(serverUrl)}`;

                        console.log('QR Code URL:', qrData);

                        new QRCode(document.getElementById('qrcode'), {
                            text: qrData,
                            width: 256,
                            height: 256,
                            colorDark: '#000000',
                            colorLight: '#ffffff',
                            correctLevel: QRCode.CorrectLevel.H
                        });

                        showScreen('waiting');

                        // Join the room as display
                        ws.send(JSON.stringify({
                            type: 'join_display',
                            roomId: roomId,
                            gameType: gameType,
                            settings: gameSettings
                        }));

                    } else if (data.type === 'init') {
                        gameState = data.gameState;

                        // Update canvas size from server
                        if (gameState.canvas) {
                            canvas.width = gameState.canvas.width;
                            canvas.height = gameState.canvas.height;
                        }

                        updatePlayerCount();

                    } else if (data.type === 'update') {
                        gameState = data.gameState;

                        // Update canvas size if it changed
                        if (gameState.canvas && (canvas.width !== gameState.canvas.width || canvas.height !== gameState.canvas.height)) {
                            canvas.width = gameState.canvas.width;
                            canvas.height = gameState.canvas.height;
                        }

                        updatePlayerCount();

                        // Switch to game screen when first player joins
                        if (gameState.players.length > 0 && !canvas.classList.contains('active')) {
                            showScreen('game');
                        }

                        // Switch back to waiting screen if all players leave
                        if (gameState.players.length === 0 && canvas.classList.contains('active')) {
                            showScreen('waiting');
                        }
                    } else if (data.type === 'effect') {
                        handleEffect(data.effectType, data.data);
                    }
                };
            } catch (error) {
                console.error('Connection error:', error);
                alert('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + error.message);
                showScreen('settings');
            }
        }

        function updatePlayerCount() {
            if (gameState) {
                playerCount.textContent = `–ò–≥—Ä–æ–∫–æ–≤: ${gameState.players.length}`;
            }
        }

        // Visual effects handlers
        function handleEffect(effectType, data) {
            switch (effectType) {
                case 'particle':
                    spawnParticles(data.x, data.y, data.color, data.count || 15);
                    break;
                case 'flash':
                    triggerFlash(data.color, data.intensity || 0.3);
                    break;
                case 'shake':
                    triggerShake(data.intensity || 3);
                    break;
                case 'scoreAnim':
                    spawnScoreAnimation(data.x, data.y, data.text, data.color);
                    break;
                case 'sound':
                    console.log('Sound:', data.sound);
                    break;
            }
        }

        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const speed = 2 + Math.random() * 3;
                effects.particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3,
                    color: color,
                    alpha: 1.0,
                    lifetime: 0.4 + Math.random() * 0.3,
                    age: 0
                });
            }
        }

        function triggerFlash(color, intensity) {
            effects.flash = {
                active: true,
                color: color,
                alpha: intensity,
                startTime: Date.now(),
                duration: 200
            };
        }

        function triggerShake(intensity) {
            effects.screenShake = {
                active: true,
                intensity: intensity,
                duration: 200,
                startTime: Date.now(),
                offsetX: 0,
                offsetY: 0
            };
        }

        function spawnScoreAnimation(x, y, text, color) {
            effects.scoreAnims.push({
                x: x, y: y,
                text: text,
                color: color,
                alpha: 1.0,
                lifetime: 1.0,
                age: 0
            });
        }

        function updateEffects() {
            const deltaTime = 1/60;

            // Update particles
            for (let i = effects.particles.length - 1; i >= 0; i--) {
                const p = effects.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.age += deltaTime;
                p.alpha = 1.0 - (p.age / p.lifetime);
                if (p.age >= p.lifetime) {
                    effects.particles.splice(i, 1);
                }
            }

            // Update screen shake
            if (effects.screenShake.active) {
                const elapsed = Date.now() - effects.screenShake.startTime;
                if (elapsed >= effects.screenShake.duration) {
                    effects.screenShake.active = false;
                    effects.screenShake.offsetX = 0;
                    effects.screenShake.offsetY = 0;
                } else {
                    const int = effects.screenShake.intensity;
                    effects.screenShake.offsetX = (Math.random() - 0.5) * int * 2;
                    effects.screenShake.offsetY = (Math.random() - 0.5) * int * 2;
                }
            }

            // Update flash
            if (effects.flash.active) {
                const elapsed = Date.now() - effects.flash.startTime;
                const progress = elapsed / effects.flash.duration;
                effects.flash.alpha = effects.flash.alpha * (1 - progress);
                if (elapsed >= effects.flash.duration) {
                    effects.flash.active = false;
                }
            }

            // Update score animations
            for (let i = effects.scoreAnims.length - 1; i >= 0; i--) {
                const anim = effects.scoreAnims[i];
                anim.y -= 1.5;
                anim.age += deltaTime;
                anim.alpha = 1.0 - (anim.age / anim.lifetime);
                if (anim.age >= anim.lifetime) {
                    effects.scoreAnims.splice(i, 1);
                }
            }
        }

        function render() {
            if (!gameState) return;

            // Check for game over
            if (gameState.gameOver && gameState.winner) {
                showWinScreen(gameState.winner, gameState.gameType);
                return;
            }

            if (gameState.gameType === 'pong') {
                renderPong();
            } else if (gameState.gameType === 'pushers') {
                renderPushers();
            } else if (gameState.gameType === 'ship') {
                renderShip();
            } else {
                renderSnake();
            }

            // Update scoreboard
            updateScoreboard();
        }

        function showWinScreen(winner, gameType) {
            // Set winner name and message
            if (gameType === 'pushers') {
                document.getElementById('winnerName').textContent = `–ö–æ–º–∞–Ω–¥–∞ ${winner.team}`;
                document.getElementById('winMessage').textContent = `–ü–æ–±–µ–¥–∏–ª–∞ —Å ${winner.score} —Å–º–∞–π–ª–∏–∫–∞–º–∏!`;
            } else if (gameType === 'ship') {
                document.getElementById('winnerName').textContent = winner.team || '–≠–∫–∏–ø–∞–∂ –∫–æ—Ä–∞–±–ª—è';
                document.getElementById('winMessage').textContent = `–°–æ–±—Ä–∞–ª ${winner.score} –º–æ–Ω–µ—Ç!`;
            } else {
                document.getElementById('winnerName').textContent = winner.name;
                if (gameType === 'pong') {
                    document.getElementById('winMessage').textContent = `–ü–æ–±–µ–¥–∞ —Å–æ —Å—á—ë—Ç–æ–º ${winner.score}!`;
                } else {
                    document.getElementById('winMessage').textContent = `–°–æ–±—Ä–∞–ª ${winner.score} –ø–∏—Ü—Ü!`;
                }
            }

            // Show win screen
            showScreen('win');

            // Hide game elements
            canvas.classList.remove('active');
            roomInfo.style.display = 'none';
            scoreboard.style.display = 'none';
        }

        function renderPong() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line
            ctx.strokeStyle = '#333';
            ctx.setLineDash([5, 15]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Show waiting message if game hasn't started
            if (!gameState.gameStarted) {
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞...', canvas.width / 2, canvas.height / 2);

                ctx.font = '20px sans-serif';
                ctx.fillStyle = '#888';
                ctx.fillText(`–ü–æ–¥–∫–ª—é—á–µ–Ω–æ: ${gameState.players.length}/2`, canvas.width / 2, canvas.height / 2 + 50);
            }

            // Draw ball
            if (gameState.ball) {
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw paddles
            const paddleWidth = 10;
            for (const player of gameState.players) {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.paddleX, player.paddleY, paddleWidth, gameState.paddleSize);

                // Draw player name above paddle
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                const nameX = player.side === 'left' ? player.paddleX + paddleWidth / 2 + 30 : player.paddleX + paddleWidth / 2 - 30;
                ctx.fillText(player.name, nameX, 30);
            }

            ctx.restore();

            // Render visual effects
            // Particles
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Flash
            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Score animations
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        function renderSnake() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bottom boundary
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 40);
            ctx.lineTo(canvas.width, canvas.height - 40);
            ctx.stroke();

            // Get dynamic sizes from server (with defaults)
            const pizzaSize = gameState.pizzaSize || 18;
            const segmentSize = gameState.segmentSize || 15;
            const pizzaRadius = pizzaSize / 2;
            const segmentRadius = segmentSize / 2;

            // Draw stardust particles (was pizzas)
            // Neon color palette
            const neonColors = [
                '#FF006E', // Hot pink
                '#8338EC', // Purple
                '#3A86FF', // Blue
                '#FFBE0B', // Yellow
                '#FB5607', // Orange
                '#06FFA5', // Cyan
                '#FF006E', // Magenta
                '#00F5FF', // Bright cyan
                '#CCFF00', // Lime
                '#FF1744'  // Red
            ];

            for (const pizza of gameState.pizzas) {
                // Assign consistent color based on pizza ID
                const colorIndex = (pizza.id ? String(pizza.id).split('').reduce((sum, char) => sum + char.charCodeAt(0), 0) : Math.floor(Math.random() * neonColors.length)) % neonColors.length;
                const color = neonColors[colorIndex];

                // Draw glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;

                // Draw stardust particle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pizza.x, pizza.y, pizzaRadius, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow for next draw
                ctx.shadowBlur = 0;
            }

            // Draw all players
            for (const player of gameState.players) {
                if (!player.alive) continue;

                // Draw body segments
                ctx.fillStyle = player.color;
                for (let i = 1; i < player.segments.length; i++) {
                    const seg = player.segments[i];
                    ctx.beginPath();
                    ctx.arc(seg.x, seg.y, segmentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw head
                const head = player.segments[0];
                ctx.save();
                ctx.translate(head.x, head.y);
                ctx.rotate(player.angle);

                // Head circle (lighter color)
                const headColor = lightenColor(player.color, 20);
                ctx.fillStyle = headColor;
                ctx.beginPath();
                ctx.arc(0, 0, segmentRadius, 0, Math.PI * 2);
                ctx.fill();

                // Eyes (white) - scaled proportionally
                const eyeRadius = segmentRadius * 0.27;
                const eyeOffsetX = segmentRadius * 0.53;
                const eyeOffsetY = segmentRadius * 0.4;
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(eyeOffsetX, -eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (black) - scaled proportionally
                const pupilRadius = segmentRadius * 0.11;
                const pupilOffsetX = segmentRadius * 0.6;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(pupilOffsetX, -eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.arc(pupilOffsetX, eyeOffsetY, pupilRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Draw player name above head
                ctx.fillStyle = player.color;
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(player.name, head.x, head.y - segmentRadius - 5);
            }
        }

        function renderPushers() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Dark background
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Field border
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Center grid (dashed lines for orientation)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw skulls at corners
            if (gameState.skulls) {
                for (const skull of gameState.skulls) {
                    // Red glow for skull
                    ctx.fillStyle = '#F44336';
                    ctx.font = `${gameState.skullSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', skull.x, skull.y);
                }
            }

            // Draw ghosts
            if (gameState.ghosts) {
                for (const ghost of gameState.ghosts) {
                    ctx.fillStyle = '#FFF';
                    ctx.font = `${gameState.ghostSize || 30}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëª', ghost.x, ghost.y);
                }
            }

            // Draw smiley
            if (gameState.smiley) {
                ctx.fillStyle = '#FFF';
                ctx.font = `${gameState.smileySize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üòä', gameState.smiley.x, gameState.smiley.y);
            }

            // Draw player squares
            if (gameState.players) {
                const renderedSquares = new Set(); // Track rendered team squares in single-square mode

                for (const player of gameState.players) {
                    const halfSize = gameState.squareSize / 2;

                    // In single-square mode, render only one square per team
                    if (gameState.singleSquareMode) {
                        if (renderedSquares.has(player.team)) {
                            continue; // Skip duplicate team
                        }
                        renderedSquares.add(player.team);
                    }

                    // Blinking effect for invulnerable players
                    if (player.invulnerable) {
                        // Blink every 200ms (5 times per second)
                        const blinkInterval = 200;
                        const currentTime = Date.now();
                        const isVisible = Math.floor(currentTime / blinkInterval) % 2 === 0;

                        if (!isVisible) {
                            continue; // Skip rendering this frame
                        }
                    }

                    // Draw square
                    ctx.fillStyle = player.color;
                    ctx.fillRect(
                        player.x - halfSize,
                        player.y - halfSize,
                        gameState.squareSize,
                        gameState.squareSize
                    );

                    // Draw label above square
                    ctx.fillStyle = player.color;
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    if (gameState.singleSquareMode) {
                        // Show team name in single-square mode
                        ctx.fillText(player.team, player.x, player.y - halfSize - 5);
                    } else {
                        // Show player name in normal mode
                        ctx.fillText(player.name, player.x, player.y - halfSize - 5);
                    }

                    // Draw axis indicator below square (only in normal mode)
                    if (!gameState.singleSquareMode) {
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(player.axis, player.x, player.y + halfSize + 3);
                    }
                }
            }

            // Draw team scoreboard in top left corner (always show for Pushers)
            if (gameState.teamScores) {
                const teams = [
                    { name: 'Blue', color: '#2196F3' },
                    { name: 'Red', color: '#F44336' },
                    { name: 'Yellow', color: '#FFEB3B' },
                    { name: 'Green', color: '#4CAF50' },
                    { name: 'White', color: '#FFFFFF' }
                ];

                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                let y = 15;
                for (const team of teams) {
                    const score = gameState.teamScores[team.name] || 0;

                    // Show team if it has any players
                    const hasPlayers = gameState.players && gameState.players.some(p => p.team === team.name);

                    if (hasPlayers) {
                        ctx.fillStyle = team.color;
                        const winScore = gameState.winScore || 15;
                        ctx.fillText(`${team.name}: ${score}/${winScore}`, 15, y);
                        y += 20;
                    }
                }
            }

            ctx.restore();

            // Render visual effects
            // Particles
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Flash
            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            // Score animations
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        // Helper function for Ship rendering
        function getSystemPosition(ship, rotation) {
            const angle = rotation * Math.PI / 180;
            return {
                x: ship.x + Math.cos(angle) * ship.radius,
                y: ship.y + Math.sin(angle) * ship.radius
            };
        }

        function renderShip() {
            // Apply screen shake
            ctx.save();
            if (effects.screenShake.active) {
                ctx.translate(effects.screenShake.offsetX, effects.screenShake.offsetY);
            }

            // Clear canvas - space background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const ship = gameState.ship;

            // Draw coins
            if (gameState.coins) {
                for (const coin of gameState.coins) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', coin.x, coin.y);
                }
            }

            // Draw hearts
            if (gameState.hearts) {
                for (const heart of gameState.hearts) {
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ù§Ô∏è', heart.x, heart.y);
                }
            }

            // Draw bullets - glowing energy particles
            if (gameState.bullets) {
                for (const bullet of gameState.bullets) {
                    ctx.save();

                    // Outer glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00FFFF';
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner bright core
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Brightest center
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }

            // Draw asteroids
            if (gameState.asteroids) {
                for (const asteroid of gameState.asteroids) {
                    ctx.save();
                    ctx.translate(asteroid.x, asteroid.y);
                    ctx.rotate(asteroid.rotation);

                    // Flash white when hit
                    const isFlashing = Date.now() < asteroid.flashUntil;
                    ctx.fillStyle = isFlashing ? '#FFFFFF' : '#888888';

                    // Draw irregular polygon
                    const sides = 8;
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (Math.PI * 2 * i) / sides;
                        const variance = 0.7 + (Math.sin(i * 2.5) * 0.15);
                        const r = asteroid.radius * variance;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Health bar
                    if (asteroid.health < asteroid.maxHealth) {
                        const barWidth = asteroid.radius * 2;
                        const barHeight = 4;
                        const healthPct = asteroid.health / asteroid.maxHealth;

                        ctx.fillStyle = '#333';
                        ctx.fillRect(-barWidth/2, -asteroid.radius - 10, barWidth, barHeight);

                        ctx.fillStyle = healthPct > 0.5 ? '#4CAF50' : '#FF5722';
                        ctx.fillRect(-barWidth/2, -asteroid.radius - 10, barWidth * healthPct, barHeight);
                    }

                    ctx.restore();
                }
            }

            // Draw ship
            if (ship) {
                // Ship body - flash red when damaged
                const timeSinceDamage = Date.now() - ship.lastDamageTime;
                const isRedFlash = timeSinceDamage < 200;

                // Invulnerable blink
                if (ship.invulnerable) {
                    const blinkVisible = Math.floor(Date.now() / 150) % 2 === 0;
                    if (!blinkVisible) {
                        ctx.globalAlpha = 0.5;
                    }
                }

                ctx.fillStyle = isRedFlash ? '#FF0000' : '#2196F3';
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, ship.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1.0;

                // Ship hull outline
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw shield arc - semi-transparent with shimmer
                if (gameState.systems && gameState.systems.shield && gameState.systems.shield.active) {
                    ctx.save();
                    const shieldRot = gameState.systems.shield.rotation * Math.PI / 180;
                    const arcSize = gameState.systems.shield.arcSize * Math.PI / 180;

                    // Shimmer effect (pulsing opacity)
                    const shimmer = 0.4 + Math.sin(Date.now() / 200) * 0.2;

                    // Outer glow
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shimmer * 0.5})`;
                    ctx.lineWidth = 12;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00FFFF';
                    ctx.beginPath();
                    ctx.arc(
                        ship.x, ship.y,
                        ship.radius + 8,
                        shieldRot - arcSize/2,
                        shieldRot + arcSize/2
                    );
                    ctx.stroke();

                    // Inner solid line
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shimmer})`;
                    ctx.lineWidth = 6;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(
                        ship.x, ship.y,
                        ship.radius + 8,
                        shieldRot - arcSize/2,
                        shieldRot + arcSize/2
                    );
                    ctx.stroke();

                    // Energy particles along shield
                    ctx.shadowBlur = 5;
                    for (let i = 0; i < 5; i++) {
                        const particleAngle = shieldRot - arcSize/2 + (arcSize * i / 4);
                        const px = ship.x + Math.cos(particleAngle) * (ship.radius + 8);
                        const py = ship.y + Math.sin(particleAngle) * (ship.radius + 8);
                        ctx.fillStyle = `rgba(0, 255, 255, ${shimmer * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }

                // Draw engine - turbine with fire particles
                if (gameState.systems) {
                    const enginePos = getSystemPosition(ship, gameState.systems.rudder.rotation);
                    const engineAngle = gameState.systems.rudder.rotation * Math.PI / 180;

                    // Turbine base (metallic gray rectangle)
                    ctx.save();
                    ctx.translate(enginePos.x, enginePos.y);
                    ctx.rotate(engineAngle);
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-10, -6, 20, 12);
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-10, -4, 20, 8);
                    ctx.restore();

                    // Fire/thrust particles (only when player is actively thrusting)
                    const thrustAngle = engineAngle; // Fire goes in engine direction (ship moves opposite)
                    const amplitude = gameState.systems.engine.amplitude || 0;
                    const hasEnginePlayer = gameState.systems.engine.hasPlayer || false;
                    const isActiveThrust = hasEnginePlayer && amplitude > 0.5;

                    if (isActiveThrust) {
                        const thrustIntensity = (amplitude - 0.5) * 2; // 0-1 for upward tilt only
                        const particleCount = Math.max(3, Math.floor(8 * thrustIntensity));

                        for (let i = 0; i < particleCount; i++) {
                            const dist = 15 + i * 12 + Math.random() * 5;
                            const spread = (Math.random() - 0.5) * 0.3;
                            const x = enginePos.x + Math.cos(thrustAngle + spread) * dist;
                            const y = enginePos.y + Math.sin(thrustAngle + spread) * dist;
                            const alpha = (1 - i / particleCount) * 0.9 * thrustIntensity;
                            const hue = 30 + Math.random() * 30; // Orange to yellow
                            ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                            ctx.beginPath();
                            const radius = Math.max(1, 8 - i * 1.5); // Prevent negative radius
                            ctx.arc(x, y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Draw weapon - old pirate cannon
                    const weaponPos = getSystemPosition(ship, gameState.systems.weaponDirection.rotation);
                    const weaponAngle = gameState.systems.weaponDirection.rotation * Math.PI / 180;

                    ctx.save();
                    ctx.translate(weaponPos.x, weaponPos.y);
                    ctx.rotate(weaponAngle);

                    // Cannon base (brown wood)
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-8, -8, 16, 16);

                    // Cannon barrel (dark gray metal)
                    ctx.fillStyle = '#333';
                    ctx.fillRect(5, -4, 15, 8);
                    ctx.fillStyle = '#222';
                    ctx.fillRect(5, -3, 15, 6);

                    // Cannon mouth (black circle)
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(20, 0, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Metal rim (gray highlight)
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.restore();
                }
            }

            ctx.restore();

            // Draw HUD (top)
            if (ship) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#FFF';
                ctx.fillText(`‚ù§Ô∏è ${ship.hearts}/10`, 20, 30);
                ctx.fillText(`üí∞ ${ship.coins}/${gameState.coinsToWin || 10}`, 20, 60);
            }

            // Player list (right side)
            if (gameState.players) {
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFF';
                let y = 30;
                const roleNames = {
                    engine: '–î–≤–∏–≥–∞—Ç–µ–ª—å',
                    rudder: '–†—É–ª—å',
                    weapon: '–û—Ä—É–∂–∏–µ',
                    weaponDirection: '–ü—Ä–∏—Ü–µ–ª',
                    shield: '–©–∏—Ç'
                };

                for (const player of gameState.players) {
                    if (!player.systemRole) continue;
                    ctx.fillStyle = player.color;
                    ctx.fillText(`${player.name} - ${roleNames[player.systemRole]}`, canvas.width - 20, y);
                    y += 25;
                }
            }

            // Render visual effects
            for (const p of effects.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            if (effects.flash.active) {
                ctx.fillStyle = effects.flash.color;
                ctx.globalAlpha = effects.flash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }

            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            for (const anim of effects.scoreAnims) {
                ctx.globalAlpha = anim.alpha;
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            ctx.globalAlpha = 1.0;
        }

        function updateScoreboard() {
            if (!gameState) return;

            playerList.innerHTML = '';

            // Sort players by score
            const sortedPlayers = [...gameState.players].sort((a, b) => b.score - a.score);

            for (const player of sortedPlayers) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-score';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.style.color = player.color;
                nameSpan.textContent = player.name;

                const scoreSpan = document.createElement('span');
                scoreSpan.textContent = player.score;

                const statusSpan = document.createElement('div');
                statusSpan.className = 'player-status' + (player.alive ? '' : ' dead');
                statusSpan.textContent = player.alive ? '' : '–ú–µ—Ä—Ç–≤';

                playerDiv.appendChild(nameSpan);
                playerDiv.appendChild(scoreSpan);
                if (!player.alive) {
                    playerDiv.appendChild(statusSpan);
                }

                playerList.appendChild(playerDiv);
            }
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, ((num >> 16) & 0xFF) + percent);
            const g = Math.min(255, ((num >> 8) & 0xFF) + percent);
            const b = Math.min(255, (num & 0xFF) + percent);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Animation loop
        function animate() {
            if (gameState && canvas.classList.contains('active')) {
                updateEffects();
                render();
            }
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
